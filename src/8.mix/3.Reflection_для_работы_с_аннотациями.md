# Reflection для работы с аннотациями в Java

## Оглавление
1. [Введение в аннотации](#введение-в-аннотации)
2. [Основы Reflection API](#основы-reflection-api)
3. [Работа с аннотациями через Reflection](#работа-с-аннотациями-через-reflection)
4. [Практические примеры](#практические-примеры)
5. [Производительность и лучшие практики](#производительность-и-лучшие-практики)
6. [Продвинутые техники](#продвинутые-техники)

## Введение в аннотации

### Что такое аннотации?
Аннотации - это метаданные, которые добавляются в исходный код Java для предоставления дополнительной информации о программе.

```java
// Встроенные аннотации
@Override
@Deprecated
@SuppressWarnings

// Пользовательские аннотации
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
public @interface CustomAnnotation {
    String value() default "";
    int priority() default 0;
}
```

### Типы удержания (Retention Policy)
- **SOURCE** - аннотация доступна только в исходном коде
- **CLASS** - аннотация сохраняется в байт-коде, но недоступна во время выполнения
- **RUNTIME** - аннотация доступна во время выполнения через Reflection

## Основы Reflection API

### Получение Class объекта
```java
// Различные способы получения Class объекта
Class<?> stringClass = String.class;
Class<?> classFromInstance = "hello".getClass();
Class<?> classFromName = Class.forName("java.lang.String");
```

### Исследование структуры класса
```java
public class ClassInspector {
    public static void inspectClass(Class<?> clazz) {
        System.out.println("Class: " + clazz.getName());
        
        // Поля
        Field[] fields = clazz.getDeclaredFields();
        for (Field field : fields) {
            System.out.println("Field: " + field.getName() + " - " + field.getType());
        }
        
        // Методы
        Method[] methods = clazz.getDeclaredMethods();
        for (Method method : methods) {
            System.out.println("Method: " + method.getName());
        }
        
        // Конструкторы
        Constructor<?>[] constructors = clazz.getDeclaredConstructors();
        for (Constructor<?> constructor : constructors) {
            System.out.println("Constructor: " + constructor.getName());
        }
    }
}
```

## Работа с аннотациями через Reflection

### Создание пользовательских аннотаций
```java
// Аннотация для валидации
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.FIELD)
public @interface Validate {
    int min() default 0;
    int max() default 100;
    String regex() default "";
    boolean required() default false;
}

// Аннотация для кэширования
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Cacheable {
    long ttl() default 3600; // time to live in seconds
    String cacheName() default "default";
}

// Аннотация для транзакций
@Retention(RetentionPolicy.RUNTIME)
@Target(ElementType.METHOD)
public @interface Transactional {
    boolean readOnly() default false;
    int timeout() default 30;
}
```

### Обнаружение аннотаций
```java
public class AnnotationScanner {
    
    // Проверка наличия аннотации на классе
    public static boolean isClassAnnotated(Class<?> clazz, 
                                         Class<? extends Annotation> annotation) {
        return clazz.isAnnotationPresent(annotation);
    }
    
    // Получение всех аннотаций класса
    public static void scanClassAnnotations(Class<?> clazz) {
        Annotation[] annotations = clazz.getAnnotations();
        for (Annotation annotation : annotations) {
            System.out.println("Class annotation: " + annotation.annotationType().getName());
        }
    }
    
    // Поиск аннотированных методов
    public static List<Method> getAnnotatedMethods(Class<?> clazz, 
                                                 Class<? extends Annotation> annotation) {
        return Arrays.stream(clazz.getDeclaredMethods())
                .filter(method -> method.isAnnotationPresent(annotation))
                .collect(Collectors.toList());
    }
    
    // Поиск аннотированных полей
    public static List<Field> getAnnotatedFields(Class<?> clazz, 
                                               Class<? extends Annotation> annotation) {
        return Arrays.stream(clazz.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(annotation))
                .collect(Collectors.toList());
    }
}
```

### Извлечение значений аннотаций
```java
public class AnnotationValueExtractor {
    
    public static <T extends Annotation> T getAnnotation(AnnotatedElement element, 
                                                       Class<T> annotationClass) {
        return element.getAnnotation(annotationClass);
    }
    
    public static void extractFieldAnnotationValues(Field field) {
        if (field.isAnnotationPresent(Validate.class)) {
            Validate validate = field.getAnnotation(Validate.class);
            System.out.println("Field: " + field.getName());
            System.out.println("Min: " + validate.min());
            System.out.println("Max: " + validate.max());
            System.out.println("Required: " + validate.required());
        }
    }
    
    public static void extractMethodAnnotationValues(Method method) {
        if (method.isAnnotationPresent(Cacheable.class)) {
            Cacheable cacheable = method.getAnnotation(Cacheable.class);
            System.out.println("Method: " + method.getName());
            System.out.println("TTL: " + cacheable.ttl());
            System.out.println("Cache name: " + cacheable.cacheName());
        }
    }
}
```

## Практические примеры

### Пример 1: Валидация объектов
```java
public class Validator {
    
    public static List<String> validate(Object obj) {
        List<String> errors = new ArrayList<>();
        Class<?> clazz = obj.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Validate.class)) {
                Validate validate = field.getAnnotation(Validate.class);
                field.setAccessible(true);
                
                try {
                    Object value = field.get(obj);
                    
                    // Проверка обязательности
                    if (validate.required() && value == null) {
                        errors.add(field.getName() + " is required");
                        continue;
                    }
                    
                    if (value != null) {
                        // Проверка числовых значений
                        if (value instanceof Number) {
                            Number number = (Number) value;
                            if (number.doubleValue() < validate.min() || 
                                number.doubleValue() > validate.max()) {
                                errors.add(field.getName() + " must be between " + 
                                          validate.min() + " and " + validate.max());
                            }
                        }
                        
                        // Проверка строк по регулярному выражению
                        if (value instanceof String && !validate.regex().isEmpty()) {
                            String stringValue = (String) value;
                            if (!stringValue.matches(validate.regex())) {
                                errors.add(field.getName() + " doesn't match pattern");
                            }
                        }
                    }
                    
                } catch (IllegalAccessException e) {
                    errors.add("Cannot access field: " + field.getName());
                }
            }
        }
        
        return errors;
    }
}

// Использование валидатора
public class User {
    @Validate(required = true, min = 3, max = 50)
    private String username;
    
    @Validate(required = true, regex = "^(?=.*[A-Za-z])(?=.*\\d)[A-Za-z\\d]{8,}$")
    private String password;
    
    @Validate(min = 0, max = 150)
    private int age;
    
    // constructors, getters, setters
}
```

### Пример 2: Кэширование методов
```java
public class CacheManager {
    private static final Map<String, CacheEntry> cache = new ConcurrentHashMap<>();
    
    public static Object invokeCached(Method method, Object target, Object[] args) 
            throws Exception {
        String cacheKey = generateCacheKey(method, args);
        
        if (cache.containsKey(cacheKey)) {
            CacheEntry entry = cache.get(cacheKey);
            if (System.currentTimeMillis() < entry.expiryTime) {
                return entry.value;
            } else {
                cache.remove(cacheKey);
            }
        }
        
        Object result = method.invoke(target, args);
        Cacheable cacheable = method.getAnnotation(Cacheable.class);
        
        if (cacheable != null) {
            long expiryTime = System.currentTimeMillis() + (cacheable.ttl() * 1000);
            cache.put(cacheKey, new CacheEntry(result, expiryTime));
        }
        
        return result;
    }
    
    private static String generateCacheKey(Method method, Object[] args) {
        return method.getName() + Arrays.deepHashCode(args);
    }
    
    private static class CacheEntry {
        Object value;
        long expiryTime;
        
        CacheEntry(Object value, long expiryTime) {
            this.value = value;
            this.expiryTime = expiryTime;
        }
    }
}

// Прокси для кэширования
public class CacheProxy implements InvocationHandler {
    private final Object target;
    
    public CacheProxy(Object target) {
        this.target = target;
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        if (method.isAnnotationPresent(Cacheable.class)) {
            return CacheManager.invokeCached(method, target, args);
        }
        return method.invoke(target, args);
    }
    
    @SuppressWarnings("unchecked")
    public static <T> T create(T target, Class<T> interfaceClass) {
        return (T) Proxy.newProxyInstance(
            interfaceClass.getClassLoader(),
            new Class<?>[]{interfaceClass},
            new CacheProxy(target)
        );
    }
}
```

### Пример 3: Обработка транзакций
```java
public class TransactionManager {
    
    public static Object invokeTransactional(Method method, Object target, Object[] args) 
            throws Exception {
        Transactional transactional = method.getAnnotation(Transactional.class);
        
        if (transactional == null) {
            return method.invoke(target, args);
        }
        
        Connection connection = null;
        try {
            // Начало транзакции
            connection = DataSource.getConnection();
            connection.setAutoCommit(false);
            connection.setTransactionIsolation(
                transactional.readOnly() ? 
                Connection.TRANSACTION_READ_COMMITTED : 
                Connection.TRANSACTION_REPEATABLE_READ
            );
            
            // Выполнение метода
            Object result = method.invoke(target, args);
            
            // Коммит транзакции
            connection.commit();
            return result;
            
        } catch (Exception e) {
            // Откат транзакции
            if (connection != null) {
                connection.rollback();
            }
            throw e;
        } finally {
            if (connection != null) {
                connection.close();
            }
        }
    }
}
```

## Производительность и лучшие практики

### Кэширование Reflection операций
```java
public class ReflectionCache {
    private static final Map<Class<?>, List<Field>> fieldCache = new ConcurrentHashMap<>();
    private static final Map<Class<?>, List<Method>> methodCache = new ConcurrentHashMap<>();
    
    public static List<Field> getAnnotatedFields(Class<?> clazz, 
                                               Class<? extends Annotation> annotation) {
        return fieldCache.computeIfAbsent(clazz, k -> 
            Arrays.stream(clazz.getDeclaredFields())
                .filter(field -> field.isAnnotationPresent(annotation))
                .collect(Collectors.toList())
        );
    }
    
    public static List<Method> getAnnotatedMethods(Class<?> clazz, 
                                                 Class<? extends Annotation> annotation) {
        return methodCache.computeIfAbsent(clazz, k -> 
            Arrays.stream(clazz.getDeclaredMethods())
                .filter(method -> method.isAnnotationPresent(annotation))
                .collect(Collectors.toList())
        );
    }
}
```

### Использование MethodHandle для лучшей производительности
```java
public class MethodHandleExecutor {
    private static final Map<Method, MethodHandle> handleCache = new ConcurrentHashMap<>();
    
    public static Object invokeMethod(Method method, Object target, Object... args) 
            throws Throwable {
        MethodHandle handle = handleCache.computeIfAbsent(method, m -> {
            try {
                MethodHandles.Lookup lookup = MethodHandles.lookup();
                return lookup.unreflect(m);
            } catch (IllegalAccessException e) {
                throw new RuntimeException(e);
            }
        });
        
        return handle.bindTo(target).invokeWithArguments(args);
    }
}
```

## Продвинутые техники

### Динамическое создание прокси классов
```java
public class AnnotationAwareProxy implements InvocationHandler {
    private final Object target;
    private final Map<Method, List<Annotation>> methodAnnotations;
    
    public AnnotationAwareProxy(Object target) {
        this.target = target;
        this.methodAnnotations = extractMethodAnnotations(target.getClass());
    }
    
    private Map<Method, List<Annotation>> extractMethodAnnotations(Class<?> clazz) {
        return Arrays.stream(clazz.getDeclaredMethods())
                .collect(Collectors.toMap(
                    Function.identity(),
                    method -> Arrays.asList(method.getAnnotations())
                ));
    }
    
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        List<Annotation> annotations = methodAnnotations.get(method);
        
        // Предварительная обработка на основе аннотаций
        for (Annotation annotation : annotations) {
            if (annotation instanceof Cacheable) {
                // Логика кэширования
            } else if (annotation instanceof Transactional) {
                // Логика транзакций
            }
        }
        
        Object result = method.invoke(target, args);
        
        // Пост-обработка на основе аннотаций
        for (Annotation annotation : annotations) {
            if (annotation instanceof Cacheable) {
                // Сохранение в кэш
            }
        }
        
        return result;
    }
}
```

### Сканирование пакетов для поиска аннотированных классов
```java
public class PackageScanner {
    
    public static Set<Class<?>> findAnnotatedClasses(String packageName, 
                                                   Class<? extends Annotation> annotation) {
        Set<Class<?>> classes = new HashSet<>();
        
        ClassLoader classLoader = Thread.currentThread().getContextClassLoader();
        String path = packageName.replace('.', '/');
        
        try {
            Enumeration<URL> resources = classLoader.getResources(path);
            while (resources.hasMoreElements()) {
                URL resource = resources.nextElement();
                if (resource.getProtocol().equals("file")) {
                    classes.addAll(findClassesInDirectory(
                        new File(resource.getFile()), packageName, annotation));
                } else if (resource.getProtocol().equals("jar")) {
                    classes.addAll(findClassesInJar(resource, packageName, annotation));
                }
            }
        } catch (IOException e) {
            throw new RuntimeException("Failed to scan package: " + packageName, e);
        }
        
        return classes;
    }
    
    private static Set<Class<?>> findClassesInDirectory(File directory, String packageName, 
                                                      Class<? extends Annotation> annotation) {
        Set<Class<?>> classes = new HashSet<>();
        
        if (!directory.exists()) {
            return classes;
        }
        
        File[] files = directory.listFiles();
        if (files == null) {
            return classes;
        }
        
        for (File file : files) {
            if (file.isDirectory()) {
                classes.addAll(findClassesInDirectory(file, 
                    packageName + "." + file.getName(), annotation));
            } else if (file.getName().endsWith(".class")) {
                String className = packageName + '.' + 
                    file.getName().substring(0, file.getName().length() - 6);
                try {
                    Class<?> clazz = Class.forName(className);
                    if (clazz.isAnnotationPresent(annotation)) {
                        classes.add(clazz);
                    }
                } catch (ClassNotFoundException e) {
                    // Пропускаем классы, которые не могут быть загружены
                }
            }
        }
        
        return classes;
    }
}
```

### Интеграция с Spring-like контейнером
```java
public class AnnotationConfigApplicationContext {
    private final Map<String, Object> beans = new ConcurrentHashMap<>();
    private final Map<String, Class<?>> beanDefinitions = new ConcurrentHashMap<>();
    
    public void scan(String... basePackages) {
        for (String basePackage : basePackages) {
            Set<Class<?>> componentClasses = PackageScanner.findAnnotatedClasses(
                basePackage, Component.class);
            
            for (Class<?> clazz : componentClasses) {
                registerBean(clazz);
            }
        }
        
        initializeBeans();
    }
    
    private void registerBean(Class<?> clazz) {
        String beanName = getBeanName(clazz);
        beanDefinitions.put(beanName, clazz);
    }
    
    private void initializeBeans() {
        for (Map.Entry<String, Class<?>> entry : beanDefinitions.entrySet()) {
            Object bean = createBean(entry.getValue());
            beans.put(entry.getKey(), bean);
        }
        
        // Внедрение зависимостей
        for (Object bean : beans.values()) {
            injectDependencies(bean);
        }
    }
    
    private Object createBean(Class<?> clazz) {
        try {
            Constructor<?> constructor = clazz.getDeclaredConstructor();
            constructor.setAccessible(true);
            return constructor.newInstance();
        } catch (Exception e) {
            throw new RuntimeException("Failed to create bean: " + clazz.getName(), e);
        }
    }
    
    private void injectDependencies(Object bean) {
        Class<?> clazz = bean.getClass();
        
        for (Field field : clazz.getDeclaredFields()) {
            if (field.isAnnotationPresent(Autowired.class)) {
                Object dependency = beans.get(getBeanName(field.getType()));
                if (dependency != null) {
                    field.setAccessible(true);
                    try {
                        field.set(bean, dependency);
                    } catch (IllegalAccessException e) {
                        throw new RuntimeException("Failed to inject dependency", e);
                    }
                }
            }
        }
    }
    
    private String getBeanName(Class<?> clazz) {
        Component component = clazz.getAnnotation(Component.class);
        return component != null && !component.value().isEmpty() ? 
               component.value() : 
               clazz.getSimpleName();
    }
    
    @SuppressWarnings("unchecked")
    public <T> T getBean(Class<T> requiredType) {
        return (T) beans.get(getBeanName(requiredType));
    }
}
```

## Заключение

Reflection для работы с аннотациями - мощный инструмент в арсенале Senior Java разработчика. Он позволяет создавать гибкие, расширяемые приложения с минимальным количеством boilerplate кода. Однако важно помнить о производительности и использовать Reflection разумно, кэшируя результаты и предпочитая более эффективные альтернативы там, где это возможно.

Ключевые моменты:
- Всегда кэшируйте Reflection операции
- Используйте MethodHandle для лучшей производительности
- Обрабатывайте исключения должным образом
- Документируйте поведение аннотаций
- Тестируйте код, использующий Reflection