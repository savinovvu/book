Конечно! Разберём отличия `data class` от обычного класса в Kotlin с точки зрения senior backend-разработчика.

## 1. Основное предназначение

**Data class** - класс для хранения данных:
```kotlin
data class User(
    val id: Long,
    val name: String,
    val email: String,
    val createdAt: LocalDateTime
)
```

**Обычный класс** - для логики и поведения:
```kotlin
class UserService(
    private val userRepository: UserRepository,
    private val emailService: EmailService
) {
    fun createUser(name: String, email: String): User {
        // бизнес-логика
    }
}
```

## 2. Автоматически генерируемый код

**Data class** генерирует:
- `equals()` и `hashCode()`
- `toString()`
- `copy()`
- `componentN()` функции (для деструктуризации)

```kotlin
// Автоматически генерируется:
val user = User(1, "John", "john@email.com", LocalDateTime.now())
val copy = user.copy(name = "Jane") // copy
val (id, name, email, createdAt) = user // деструктуризация
println(user) // читабельный toString
```

**Обычный класс** - ничего не генерируется автоматически.

## 3. Требования к объявлению

**Data class**:
- Минимум один параметр в конструкторе
- Параметры должны быть `val` или `var`
- Не могут быть `open`, `abstract`, `sealed`, `inner`

**Обычный класс** - никаких ограничений

## 4. Use cases в backend-разработке

### Data class для:
- **DTO** (Data Transfer Objects)
- **Модели данных** БД
- **Response/Request** модели в API
- **Конфигурационные** классы

```kotlin
// DTO для REST API
data class CreateUserRequest(
    val name: String,
    val email: String,
    @JsonProperty("password") val rawPassword: String
)

data class UserResponse(
    val id: Long,
    val name: String,
    val email: String,
    val createdAt: String
)

// Entity для БД
@Entity
data class UserEntity(
    @Id val id: Long,
    val name: String,
    val email: String,
    val createdAt: LocalDateTime
)
```

### Обычный класс для:
- **Сервисные** классы
- **Репозитории**
- **Контроллеры**
- **Компоненты бизнес-логики**

```kotlin
@Service
class UserService(
    private val userRepository: UserRepository,
    private val passwordEncoder: PasswordEncoder,
    private val eventPublisher: ApplicationEventPublisher
) {
    fun createUser(request: CreateUserRequest): UserResponse {
        // валидация, преобразование, бизнес-правила
    }
}
```

## 5. Практические преимущества для backend

### Сравнение и коллекции
```kotlin
// Data class - идеально для ключей в мапах, множествах
data class CacheKey(
    val userId: Long,
    val resourceType: String
)

val cache = mutableMapOf<CacheKey, String>()
val key = CacheKey(1, "profile")
cache[key] = "cached_data" // корректная работа equals/hashCode
```

### Неизменяемость и thread-safety
```kotlin
data class Configuration(
    val databaseUrl: String,
    val maxConnections: Int,
    val timeout: Duration
)

// Безопасно передавать между потоками
val config = Configuration("jdbc:postgresql://localhost/db", 10, Duration.ofSeconds(30))
```

### JSON сериализация
```kotlin
@JsonClass(generateAdapter = true)
data class ApiResponse<T>(
    val data: T,
    val status: String,
    val timestamp: Long
)

// Чистая структура данных для сериализации
```

## 6. Антипаттерны

**Не используйте data class когда:**
- Нужно наследование
- Требуется кастомная логика equals/hashCode
- Класс содержит сложное состояние с побочными эффектами

```kotlin
// ПЛОХО - data class с бизнес-логикой
data class Order(
    val items: List<OrderItem>,
    val total: BigDecimal
) {
    fun processPayment() { // побочный эффект
        // логика оплаты
    }
}

// ЛУЧШЕ - разделить на data class и сервис
data class Order(val items: List<OrderItem>, val total: BigDecimal)

class OrderService {
    fun processPayment(order: Order) { ... }
}
```

## 7. Производительность

**Data class** обычно быстрее в:
- Сравнении объектов
- Работе с коллекциями (хеш-таблицы)
- Копировании объектов

## Вывод для senior разработчика

Используйте **data class** для чистых структур данных, которые primarily хранят состояние. Используйте **обычные классы** для компонентов с поведением, зависимостями и бизнес-логикой.

Это разделение соответствует принципам Clean Architecture и упрощает тестирование, поддержку и понимание кода.