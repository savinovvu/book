Отличный вопрос! Обработка исключений в корутинах — критически важная тема для любого Senior Kotlin разработчика. Разберём её системно и подробно.

## 1. Базовые концепции

### Исключения в корутинах vs обычных потоках

```kotlin
// ❌ Обычный подход не работает
fun main() {
    try {
        GlobalScope.launch {
            throw RuntimeException("Ошибка в корутине!")
        }
    } catch (e: Exception) {
        println("Не сработает: $e") // Это никогда не выполнится
    }
    Thread.sleep(1000)
}
```

**Почему?** Корутины работают асинхронно, и исключения возникают в другом контексте выполнения.

## 2. Обработка исключений в launch-корутинах

### CoroutineExceptionHandler

```kotlin
val exceptionHandler = CoroutineExceptionHandler { coroutineContext, throwable ->
    println("Поймано исключение: ${throwable.message}")
    // Логирование, уведомление, метрики
}

fun main() = runBlocking {
    val job = GlobalScope.launch(exceptionHandler) {
        println("Запускаем корутину")
        throw RuntimeException("Что-то пошло не так!")
    }
    
    job.join() // Ждём завершения
}
```

## 3. Обработка исключений в async-корутинах

### Подход с Deferred

```kotlin
fun main() = runBlocking {
    val deferred = GlobalScope.async {
        // Симуляция работы
        delay(500)
        if (Random.nextBoolean()) {
            "Успешный результат"
        } else {
            throw RuntimeException("Ошибка в async!")
        }
    }
    
    try {
        val result = deferred.await() // Исключение выбрасывается здесь
        println("Результат: $result")
    } catch (e: Exception) {
        println("Поймано при await: ${e.message}")
    }
}
```

## 4. SupervisorJob vs обычный Job

### Обычный Job (отмена всех при ошибке)

```kotlin
fun main() = runBlocking {
    val scope = CoroutineScope(Job())
    
    scope.launch {
        delay(100)
        println("Первая корутина") // Не выполнится из-за ошибки во второй
    }
    
    scope.launch {
        throw RuntimeException("Ошибка!")
    }
    
    delay(1000)
}
```

### SupervisorJob (изолированные ошибки)

```kotlin
fun main() = runBlocking {
    val scope = CoroutineScope(SupervisorJob())
    
    scope.launch {
        delay(100)
        println("Первая корутина выполнилась!") // ✅ Выполнится несмотря на ошибку
    }
    
    scope.launch {
        throw RuntimeException("Ошибка во второй корутине!")
    }
    
    delay(1000)
}
```

## 5. SupervisorScope

```kotlin
fun main() = runBlocking {
    supervisorScope {
        val child1 = launch {
            delay(1000)
            println("Child 1 completed")
        }
        
        val child2 = launch {
            delay(500)
            throw RuntimeException("Child 2 failed!")
        }
        
        // child1 продолжит работу несмотря на ошибку в child2
        child1.join()
        println("Supervisor scope completed")
    }
}
```

## 6. Продвинутые паттерны

### Ретри с экспоненциальной задержкой

```kotlin
suspend fun <T> retryWithBackoff(
    times: Int = 3,
    initialDelay: Long = 100,
    maxDelay: Long = 1000,
    factor: Double = 2.0,
    block: suspend () -> T
): T {
    var currentDelay = initialDelay
    repeat(times - 1) { attempt ->
        try {
            return block()
        } catch (e: Exception) {
            println("Attempt ${attempt + 1} failed: ${e.message}")
        }
        delay(currentDelay)
        currentDelay = (currentDelay * factor).toLong().coerceAtMost(maxDelay)
    }
    return block() // последняя попытка
}

// Использование
fun main() = runBlocking {
    val result = retryWithBackoff {
        if (Random.nextInt(10) < 8) {
            throw RuntimeException("Временная ошибка")
        } else {
            "Успех!"
        }
    }
    println("Результат: $result")
}
```

### Обработка разных типов исключений

```kotlin
sealed class AppError : Exception() {
    data class NetworkError(val code: Int) : AppError()
    data class DatabaseError(val query: String) : AppError()
    object TimeoutError : AppError()
}

suspend fun handleOperation() {
    try {
        performRiskyOperation()
    } catch (e: AppError) {
        when (e) {
            is AppError.NetworkError -> handleNetworkError(e.code)
            is AppError.DatabaseError -> handleDatabaseError(e.query)
            AppError.TimeoutError -> handleTimeout()
        }
    } catch (e: CancellationException) {
        // Особый случай - не логируем, это нормальное завершение
        throw e
    } catch (e: Exception) {
        logError(e)
        showUserFriendlyMessage()
    }
}
```

## 7. Интеграция с DI и архитектурой

### Фабрика корутин с обработкой ошибок

```kotlin
class CoroutineScopes(
    private val errorHandler: ErrorHandler
) {
    private val applicationScope = CoroutineScope(
        SupervisorJob() + Dispatchers.Default + 
        CoroutineExceptionHandler { _, throwable ->
            errorHandler.handleError(throwable)
        }
    )
    
    private val ioScope = CoroutineScope(
        SupervisorJob() + Dispatchers.IO +
        CoroutineExceptionHandler { _, throwable ->
            errorHandler.handleError(throwable)
        }
    )
    
    fun getApplicationScope() = applicationScope
    fun getIoScope() = ioScope
}

interface ErrorHandler {
    fun handleError(throwable: Throwable)
}
```

## 8. Best Practices для Senior разработчика

### 1. Всегда явно обрабатывайте исключения

```kotlin
// ❌ Плохо
fun loadData() = scope.launch {
    val data = api.getData() // Может упасть без обработки
    updateUI(data)
}

// ✅ Хорошо
fun loadData() = scope.launch {
    try {
        val data = api.getData()
        updateUI(data)
    } catch (e: IOException) {
        showNetworkError()
    } catch (e: Exception) {
        logError(e)
        showGenericError()
    }
}
```

### 2. Используйте appropriate scope для разных случаев

```kotlin
class UserRepository(
    private val api: UserApi,
    private val scope: CoroutineScope
) {
    // Для операций, где ошибка одной не должна влиять на другие
    fun updateUserInParallel(users: List<User>) = scope.launch {
        users.forEach { user ->
            // Каждая корутина изолирована
            launch(SupervisorJob()) {
                api.updateUser(user)
            }
        }
    }
}
```

### 3. Логируйте правильно

```kotlin
val loggingExceptionHandler = CoroutineExceptionHandler { context, exception ->
    logger.error(
        "Корутина упала: ${context[CoroutineName]}",
        exception
    )
    // Отправка в мониторинг
    metrics.increment("coroutine.failure")
}
```

### 4. Тестирование обработки исключений

```kotlin
@Test
fun `should handle network error gracefully`() = runTest {
    val repository = UserRepository(failingApi)
    
    repository.loadUser().test {
        assertTrue(awaitItem() is Loading)
        assertTrue(awaitItem() is Error)
        cancelAndIgnoreRemainingEvents()
    }
}
```

## 9. Распространённые антипаттерны

```kotlin
// ❌ Тихий провал
launch {
    try {
        riskyCall()
    } catch (e: Exception) {
        // Ничего не делаем - очень опасно!
    }
}

// ❌ Слишком широкий catch
launch {
    try {
        riskyCall()
    } catch (e: Throwable) { // Ловим даже CancellationException!
        // Нарушает механизм отмены корутин
    }
}

// ✅ Правильно
launch {
    try {
        riskyCall()
    } catch (e: CancellationException) {
        throw e // Пробрасываем дальше
    } catch (e: Exception) {
        handleBusinessError(e)
    }
}
```

Ключевые моменты для Senior разработчика:
- **Понимание распространения исключений** в иерархии корутин
- **Правильный выбор стратегии** (SupervisorJob vs обычный Job)
- **Интеграция с мониторингом** и системой логирования
- **Тестирование сценариев ошибок**
- **Пользовательский опыт** при ошибках

Эта глубина понимания отличает Senior разработчика от Middle!