# Внутреннее устройство коллекций Java: коллизии, equals() и hashCode()

## 1. Контракт между equals() и hashCode()

### Основные правила:
```java
public boolean equals(Object obj) { ... }
public int hashCode() { ... }
```

**Контракт:**
1. Если `obj1.equals(obj2) == true`, то `obj1.hashCode() == obj2.hashCode()`
2. Если `obj1.hashCode() == obj2.hashCode()`, то НЕ обязательно `obj1.equals(obj2)`
3. Если `obj1.hashCode() != obj2.hashCode()`, то `obj1.equals(obj2) == false`

### Пример нарушения контракта:
```java
class BadKey {
    private String name;
    
    public BadKey(String name) { this.name = name; }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BadKey badKey = (BadKey) o;
        return Objects.equals(name, badKey.name);
    }
    
    // hashCode() не переопределен - НАРУШЕНИЕ!
}
```

## 2. HashMap: внутреннее устройство

### Структура данных:
```java
// Упрощенная структура HashMap
class HashMap<K,V> {
    static class Node<K,V> {
        final int hash;
        final K key;
        V value;
        Node<K,V> next;  // для разрешения коллизий
    }
    
    Node<K,V>[] table;   // массив бакетов
    int size;
    float loadFactor;
}
```

### Процесс помещения элемента:
```java
public V put(K key, V value) {
    // 1. Вычисление хеша
    int hash = hash(key);
    
    // 2. Определение индекса бакета
    int index = (table.length - 1) & hash;
    
    // 3. Обработка коллизий
    for (Node<K,V> e = table[index]; e != null; e = e.next) {
        if (e.hash == hash && 
            (e.key == key || (key != null && key.equals(e.key)))) {
            // Ключ найден - обновление значения
            V oldValue = e.value;
            e.value = value;
            return oldValue;
        }
    }
    
    // 4. Добавление нового узла
    addNode(hash, key, value, index);
}
```

## 3. Типы коллизий и их разрешение

### Коллизия первого уровня - одинаковый индекс:
```java
// Два разных ключа попадают в один бакет
Key1: hashCode() = 100 → index = 100 & 15 = 4
Key2: hashCode() = 116 → index = 116 & 15 = 4
```

### Коллизия второго уровня - одинаковый хеш:
```java
// Разные ключи имеют одинаковый hashCode()
Key1: "Aa" → hashCode() = 2112
Key2: "BB" → hashCode() = 2112
```

### Разрешение коллизий - цепочки:
```java
// До Java 8 - связный список
bucket[index] → Node1 → Node2 → Node3

// После Java 8 - при длине > 8 преобразуется в дерево
bucket[index] → TreeNode ↔ TreeNode ↔ TreeNode
```

## 4. Влияние качества hashCode() на производительность

### Плохой hashCode():
```java
class PoorHashKey {
    private String value;
    
    @Override
    public int hashCode() {
        return 42;  // Всегда один и тот же!
    }
    
    @Override
    public boolean equals(Object o) {
        // правильная реализация
    }
}

// Результат: все элементы в одном бакете
// Производительность: O(n) вместо O(1)
```

### Хороший hashCode():
```java
class GoodHashKey {
    private String value;
    private int id;
    
    @Override
    public int hashCode() {
        return Objects.hash(value, id);  // Равномерное распределение
    }
}
```

## 5. Рехэширование и рост таблицы

### Процесс рехэширования:
```java
void resize() {
    int newCapacity = oldCapacity << 1;  // Удвоение размера
    
    // Перераспределение всех элементов
    for (Node<K,V> e : oldTable) {
        while (e != null) {
            Node<K,V> next = e.next;
            int newIndex = (newCapacity - 1) & e.hash;
            e.next = newTable[newIndex];
            newTable[newIndex] = e;
            e = next;
        }
    }
}
```

## 6. Особенности для mutable ключей

### Проблема изменяемых ключей:
```java
Map<MutableKey, String> map = new HashMap<>();
MutableKey key = new MutableKey("initial");
map.put(key, "value");

// Изменяем ключ после помещения
key.setValue("changed");

// Теперь ключ потерян!
String value = map.get(key);  // Возвращает null
```

### Решение:
```java
// 1. Использовать immutable ключи
final class ImmutableKey {
    private final String value;
    
    public ImmutableKey(String value) {
        this.value = value;
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(value);
    }
}

// 2. Либо не изменять ключи после помещения в map
```

## 7. HashSet и его внутренняя реализация

### HashSet на основе HashMap:
```java
class HashSet<E> {
    private transient HashMap<E,Object> map;
    private static final Object PRESENT = new Object();
    
    public boolean add(E e) {
        return map.put(e, PRESENT) == null;
    }
}
```

## 8. Best Practices

### Правильная реализация equals() и hashCode():
```java
class ProperEntity {
    private final String name;
    private final int id;
    private final LocalDate birthDate;
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ProperEntity that = (ProperEntity) o;
        return id == that.id && 
               Objects.equals(name, that.name) && 
               Objects.equals(birthDate, that.birthDate);
    }
    
    @Override
    public int hashCode() {
        return Objects.hash(name, id, birthDate);
    }
}
```

### Рекомендации по производительности:
1. **Используйте immutable ключи** когда возможно
2. **Обеспечьте хорошее распределение** в hashCode()
3. **Избегайте мутации ключей** после помещения в коллекцию
4. **Настройте initialCapacity и loadFactor** при известном размере
5. **Используйте примитивные коллекции** (FastUtil, Eclipse Collections) для примитивов

### Настройка HashMap:
```java
// Для известного количества элементов ~1000
Map<String, String> map = new HashMap<>(1024, 0.75f);

// Расчет initialCapacity: expectedSize / loadFactor + 1
int expectedSize = 1000;
float loadFactor = 0.75f;
int initialCapacity = (int) (expectedSize / loadFactor) + 1;
```

Понимание этих механизмов критически важно для написания эффективных Java-приложений, особенно при работе с большими объемами данных.