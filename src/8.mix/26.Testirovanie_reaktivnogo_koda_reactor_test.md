Отличный вопрос! Тестирование реактивного кода — это критически важный навык для Senior Java-разработчика, работающего с Project Reactor. Давайте подробно разберем, как эффективно тестировать такой код, используя инструменты из `reactor-test`.

## Основы тестирования с Reactor Test

### Зависимость Maven/Gradle

```xml
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

## StepVerifier - основной инструмент

`StepVerifier` — это мощный инструмент для пошаговой проверки реактивных потоков.

### Базовые сценарии тестирования

```java
@Test
void basicFluxTest() {
    Flux<String> flux = Flux.just("A", "B", "C");
    
    StepVerifier.create(flux)
        .expectNext("A")
        .expectNext("B")
        .expectNext("C")
        .verifyComplete();
}

@Test
void monoTest() {
    Mono<String> mono = Mono.just("Hello");
    
    StepVerifier.create(mono)
        .expectNext("Hello")
        .verifyComplete();
}
```

### Тестирование ошибок

```java
@Test
void errorTest() {
    Flux<String> flux = Flux.error(new RuntimeException("Error occurred"));
    
    StepVerifier.create(flux)
        .expectError(RuntimeException.class)
        .verify();
}

@Test
void errorWithMessageTest() {
    Flux<String> flux = Flux.error(new IllegalArgumentException("Invalid input"));
    
    StepVerifier.create(flux)
        .expectErrorMatches(throwable -> 
            throwable instanceof IllegalArgumentException &&
            throwable.getMessage().equals("Invalid input"))
        .verify();
}
```

## Продвинутые техники тестирования

### Тестирование с временными ограничениями

```java
@Test
void timeBasedTest() {
    Flux<Long> flux = Flux.interval(Duration.ofSeconds(1))
                         .take(3);
    
    StepVerifier.create(flux)
        .expectNext(0L)
        .expectNext(1L)
        .expectNext(2L)
        .verifyComplete();
}
```

### Виртуальное время (Virtual Time)

Для тестирования операторов, зависящих от времени, без реального ожидания:

```java
@Test
void virtualTimeTest() {
    StepVerifier.withVirtualTime(() -> 
            Flux.interval(Duration.ofHours(1))
                .take(2)
                .map(i -> "Event " + i))
        .expectSubscription()
        .thenAwait(Duration.ofHours(2)) // "перематываем" время
        .expectNext("Event 0", "Event 1")
        .verifyComplete();
}
```

## Тестирование контекста

```java
@Test
void contextTest() {
    Mono<String> mono = Mono.deferContextual(ctx -> 
        Mono.just("User: " + ctx.get("user"))
    );
    
    StepVerifier.create(mono)
        .expectAccessibleContext()
        .contains("user", "john.doe")
        .then()
        .expectNext("User: john.doe")
        .verifyComplete();
}
```

## TestPublisher для сложных сценариев

`TestPublisher` позволяет создавать кастомные последовательности событий:

```java
@Test
void testPublisherExample() {
    TestPublisher<String> testPublisher = TestPublisher.create();
    
    Flux<String> flux = testPublisher.flux();
    
    StepVerifier.create(flux)
        .then(() -> testPublisher.next("A", "B"))
        .expectNext("A", "B")
        .then(() -> testPublisher.error(new RuntimeException("Error")))
        .expectError(RuntimeException.class)
        .verify();
}
```

## Практические примеры тестирования

### Тестирование сервиса с репозиторием

```java
@ExtendWith(MockitoExtension.class)
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void findActiveUsersTest() {
        // Given
        when(userRepository.findAll())
            .thenReturn(Flux.just(
                new User("1", "active", "john@example.com"),
                new User("2", "inactive", "jane@example.com"),
                new User("3", "active", "bob@example.com")
            ));
        
        // When & Then
        StepVerifier.create(userService.findActiveUsers())
            .expectNextMatches(user -> 
                "active".equals(user.getStatus()) && 
                "john@example.com".equals(user.getEmail()))
            .expectNextMatches(user -> 
                "active".equals(user.getStatus()) && 
                "bob@example.com".equals(user.getEmail()))
            .verifyComplete();
    }
    
    @Test
    void findUserByIdNotFoundTest() {
        when(userRepository.findById("999"))
            .thenReturn(Mono.empty());
        
        StepVerifier.create(userService.findUserById("999"))
            .expectError(UserNotFoundException.class)
            .verify();
    }
}
```

### Тестирование обработки ошибок и retry

```java
@Test
void retryTest() {
    AtomicInteger attemptCount = new AtomicInteger();
    
    Mono<String> unreliableMono = Mono.fromCallable(() -> {
        if (attemptCount.incrementAndGet() < 3) {
            throw new RuntimeException("Temporary error");
        }
        return "Success";
    });
    
    Mono<String> retryMono = unreliableMono
        .retryWhen(Retry.fixedDelay(2, Duration.ofMillis(100)));
    
    StepVerifier.create(retryMono)
        .expectNext("Success")
        .verifyComplete();
    
    assertEquals(3, attemptCount.get());
}
```

## Best Practices от Senior Developer

### 1. Изолированность тестов

```java
@Test
void isolatedTest() {
    // Каждый тест должен быть независимым
    Flux<Integer> flux = Flux.range(1, 3)
                            .map(i -> i * 2)
                            .filter(i -> i > 2);
    
    StepVerifier.create(flux)
        .expectNext(4, 6)
        .verifyComplete();
}
```

### 2. Тестирование граничных условий

```java
@Test
void emptyFluxTest() {
    StepVerifier.create(Flux.empty())
        .verifyComplete();
}

@Test
void singleElementTest() {
    StepVerifier.create(Mono.just("single"))
        .expectNext("single")
        .verifyComplete();
}

@Test
void nullHandlingTest() {
    StepVerifier.create(Mono.justOrEmpty(null))
        .verifyComplete();
}
```

### 3. Проверка побочных эффектов

```java
@Test
void sideEffectTest() {
    List<String> collected = new ArrayList<>();
    
    Flux<String> flux = Flux.just("A", "B", "C")
                           .doOnNext(collected::add);
    
    StepVerifier.create(flux)
        .expectNext("A", "B", "C")
        .verifyComplete();
    
    assertEquals(List.of("A", "B", "C"), collected);
}
```

### 4. Тестирование backpressure

```java
@Test
void backpressureTest() {
    Flux<Integer> flux = Flux.range(1, 10);
    
    StepVerifier.create(flux, 2) // запрашиваем только 2 элемента
        .expectNext(1, 2)
        .thenRequest(3) // запрашиваем еще 3
        .expectNext(3, 4, 5)
        .thenCancel() // отменяем подписку
        .verify();
}
```

## Распространенные ошибки и как их избежать

### ❌ Забывать вызывать verify()
```java
// Неправильно
StepVerifier.create(flux)
    .expectNext("A")
    .expectNext("B"); // забыли verify()

// Правильно
StepVerifier.create(flux)
    .expectNext("A")
    .expectNext("B")
    .verifyComplete();
```

### ❌ Смешивать синхронные и асинхронные операции
```java
// Опасно - может привести к race condition
List<String> results = new ArrayList<>();
flux.subscribe(results::add);
// сразу проверяем results - может быть пустым

// Правильно - использовать StepVerifier
StepVerifier.create(flux.collectList())
    .expectNext(List.of("A", "B", "C"))
    .verifyComplete();
```

## Интеграция с другими инструментами

### Spring WebFlux тестирование

```java
@WebFluxTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @MockBean
    private UserService userService;
    
    @Test
    void getUserTest() {
        when(userService.findUserById("1"))
            .thenReturn(Mono.just(new User("1", "active", "john@test.com")));
        
        webTestClient.get().uri("/users/1")
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.email").isEqualTo("john@test.com");
    }
}
```

Тестирование реактивного кода требует особого подхода, но с `reactor-test` это становится предсказуемым и надежным процессом. Ключевые моменты: используйте `StepVerifier` для большинства сценариев, `TestPublisher` для сложных случаев и виртуальное время для тестирования временных операторов.