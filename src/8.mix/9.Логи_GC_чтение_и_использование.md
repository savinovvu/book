Для senior Java-разработчика анализ логов сборки мусора (GC) — критически важный навык для диагностики производительности и стабильности приложений. Рассмотрим ключевые аспекты работы с логированием GC в JVM.

### 1. **Включение логирования GC**
#### **Для Java 9+ (Unified Logging)**
```bash
-Xlog:gc*:file=gc.log:time:filecount=5,filesize=10m
```
- `gc*` — логирование всех событий GC.
- `file` — вывод в файл с ротацией (5 файлов по 10 МБ).
- `time` — метки времени.

#### **Для Java 8 и старше**
```bash
-XX:+PrintGCDetails -XX:+PrintGCDateStamps -Xloggc:gc.log
```

### 2. **Ключевые метрики в логах GC**
- **Время паузы (Pause Time)**:  
  Пример: `[GC pause (G1 Evacuation Pause) 0.021 secs]` — пауза 21 мс.
- **Изменение памяти**:  
  `25M->15M(128M)` — до GC: 25 МБ, после: 15 МБ, всего куча: 128 МБ.
- **Пропускная способность (Throughput)**:  
  Процент времени, когда приложение работает (не в GC). Цель: >95%.
- **Частота сборок**:  
  Частые молодые (Minor) или полные (Full) GC указывают на проблемы.

### 3. **Анализ логов разных сборщиков**
#### **G1 GC**
```
[Eden: 100M->0B(100M) Survivors: 0B->10M Heap: 150M->80M(200M)]
```
- **Evacuation Pause** — перемещение объектов между регионами.
- **Mixed GC** — сборка молодых и части старых регионов.

#### **CMS**
```
[CMS-concurrent-mark: 0.012/0.015 secs]
```
- Конкурентные фазы (не блокирующие приложение).

#### **ZGC/Shenandoah**
```
[GC pause (G1 Humongous Allocation) 1.5ms]
```
- Краткие паузы (<1 мс в идеале), даже для больших куч.

### 4. **Инструменты для анализа**
- **GCEasy**: Онлайн-анализ логов с графиками и рекомендациями.
- **GCViewer**: Офлайн-визуализация ключевых метрик.
- **JStat**: Мониторинг в реальном времени:
  ```bash
  jstat -gc <pid> 1s
  ```

### 5. **Типичные проблемы и решения**
- **Частые Full GC**:
    - **Причина**: Нехватка памяти, фрагментация (CMS), «просачивание» в Old Gen.
    - **Решение**: Увеличить кучу, оптимизировать размеры областей, проверить утечки.
- **Долгие паузы**:
    - **Причина**: Большие наборы данных, неподходящий сборщик.
    - **Решение**: Перейти на низколатентные сборщики (ZGC/Shenandoah), настроить целевое время паузы (`-XX:MaxGCPauseMillis`).
- **Высокий расход памяти**:
    - **Причина**: Утечки, чрезмерное использование промежуточных объектов.
    - **Решение**: Профилирование (JProfiler, YourKit), оптимизация кода.

### 6. **Профилирование памяти**
- **Heap Dump**:
  ```bash
  jmap -dump:live,format=b,file=heap.hprof <pid>
  ```
- **Анализ**: Использовать Eclipse MAT или JVisualVM для поиска «тяжелых» объектов и цепочек ссылок.

### 7. **Оптимизация стратегии GC**
- **Высокая пропускная способность**: Parallel GC.
- **Низкие задержки**: G1, ZGC, Shenandoah.
- **Большие кучи (>32 ГБ)**: ZGC/Shenandoah.

### 8. **Мониторинг в продакшене**
- **JMX-бины GC**: Через JConsole или Prometheus + Grafana.
- **Алармы**: На частые Full GC или рост пауз.

### Пример вывода G1 GC
```
[0.123s][info][gc] GC(0) Pause Young (Normal) (G1 Evacuation Pause) 25M->10M(128M) 5.234ms
```
- **25M->10M**: Освобождено 15 МБ.
- **128M**: Общий размер кучи.
- **5.234ms**: Время паузы.

### Заключение
Для senior-разработчика важно:
- Настраивать логирование под конкретный сборщик.
- Автоматизировать анализ через инструменты (например, парсинг логов для алертинга).
- Соотносить метрики GC с бизнес-метриками (например, время ответа API).
- Регулярно проводить нагрузочное тестирование с профилированием GC.

Глубокое понимание логов GC позволяет предотвращать критические инциденты и оптимизировать стоимость инфраструктуры.