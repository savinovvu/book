Отличный вопрос! Это одна из тех тем, где понимание внутренней кухни Spring отделяет Middle-разработчика от Senior. Давайте разберем генерацию прокси для аннотаций `@Cacheable`, `@Async` и `@Transactional` на глубоком уровне.

### Ключевая идея: Spring AOP и прокси

Все эти аннотации работают на основе механизма **AOP (Aspect-Oriented Programming)**. Поскольку нельзя просто "воткнуть" свою логику (кэширование, асинхронность, управление транзакциями) в код обычного Java-бина, Spring оборачивает целевой бин в **прокси-объект**.

Когда вы вызываете метод у бина, который, как вам кажется, находится в контексте, вы на самом деле вызываете метод не у настоящего бина, а у его прокси. Прокси решает, нужно ли применять дополнительную логику (Advice), и только затем делегирует вызов целевому бину.

---

### 1. Типы прокси в Spring

Spring использует два основных механизма создания прокси:

1.  **JDK Dynamic Proxies (по умолчанию для бинов с интерфейсами):** Создает прокси на основе интерфейсов. Прокси реализует те же интерфейсы, что и целевой объект.
    *   **Требование:** Целевой класс должен реализовывать хотя бы один интерфейс.
    *   **Пакет:** `java.lang.reflect.Proxy`

2.  **CGLIB (по умолчанию для бинов без интерфейсов или с `proxyTargetClass = true`):** Создает прокси путем наследования от целевого класса. Таким образом, прокси является потомком вашего бина.
    *   **Требование:** Целевой класс и его методы не должны быть `final`.
    *   **Особенность:** Переопределяет методы родительского класса.

**Какой тип будет выбран?**
*   Если бин реализует интерфейс(ы) — Spring по умолчанию создаст JDK Dynamic Proxy.
*   Если бин не реализует интерфейсы — Spring будет вынужден использовать CGLIB.
*   Вы можете явно указать `@EnableAsync(proxyTargetClass = true)`, `@EnableCaching(proxyTargetClass = true)` или `@EnableTransactionManagement(proxyTargetClass = true)`, чтобы форсировать использование CGLIB, даже если есть интерфейсы.

---

### 2. Общий процесс генерации прокси и применения логики

Вне зависимости от аннотации, процесс выглядит так:

1.  **Создание бина:** Spring создает экземпляр вашего класса (`UserService`, `DataProcessor` и т.д.).
2.  **Пост-обработка (Bean Post-Processing):** Специальные компоненты Spring (`BeanPostProcessor`) проверяют созданные бины.
    *   Для `@Async` — `AsyncAnnotationBeanPostProcessor`
    *   Для `@Transactional` — `InfrastructureAdvisorAutoProxyCreator` (через `AnnotationTransactionAttributeSource`)
    *   Для `@Cacheable` — `AnnotationCacheOperationSource` (через `ProxyCachingConfiguration`)
3.  **Поиск аннотаций:** Если пост-обработчик находит соответствующие аннотации на классе или методах, он понимает, что для этого бина нужен прокси.
4.  **Создание прокси:** Spring создает объект-прокси (JDK или CGLIB), который оборачивает исходный бин.
5.  **Вызов метода через прокси:**
    *   Клиентский код вызывает метод у прокси.
    *   Прокси определяет, подходит ли вызванный метод под условие (например, помечен ли он `@Cacheable`).
    *   Если подходит — выполняется **Advice** (дополнительная логика: начало транзакции, проверка кэша и т.д.).
    *   После выполнения Advice происходит вызов метода на **целевом объекте** (original bean).
    *   После вызова может быть выполнен еще один Advice (например, коммит транзакции или сохранение результата в кэш).

---

### 3. Детали по каждой аннотации

#### @Async

**Прокси и логика:**
*   **Прокси:** Создает асинхронный прокси, который перехватывает вызов метода.
*   **Логика внутри прокси:**
    1.  Прокси берет `TaskExecutor` (по умолчанию — `SimpleAsyncTaskExecutor`).
    2.  Вызов метода оборачивается в `Runnable` или `Callable`.
    3.  Этот задача передается в `Executor`, который запускает ее в отдельном потоке.
    4.  Прокси немедленно возвращает управление вызывающему коду. Если возвращаемый тип — `Future`, возвращается обертка (`AsyncResult`), с помощью которой можно получить результат.

**Важное ограничение:**
*   Вызов `@Async` метода изнутри того же класса (через `this.asyncMethod()`) **не будет работать**, так как он минует прокси. Это классическая проблема "self-invocation".

#### @Transactional

**Прокси и логика:**
*   **Прокси:** Создает прокси, управляющий транзакциями.
*   **Логика внутри прокси:**
    1.  **Before:** Перед вызовом метода прокси проверяет наличие существующей транзакции (смотрит на `propagation`). Если нужно, создает новую транзакцию, подключается к `DataSource` и т.д.
    2.  **Target Invocation:** Вызывает метод на целевом бине.
    3.  **After (Success):** Если метод завершился без исключения, прокси фиксирует (commit) транзакцию.
    4.  **After (Exception):** Если было выброшено исключение, прокси проверяет, указана ли данная исключение (или ее родитель) в `rollbackFor`. Если да — откатывает (rollback) транзакцию.

**Важные нюансы:**
*   Также страдает от "self-invocation". `this.internalMethod()`, даже если он помечен `@Transactional`, не будет запущен в транзакции.
*   У `@Transactional` есть порядок применения (`order`), что важно, когда он комбинируется с другими AOP-советами (например, `@Cacheable`).

#### @Cacheable

**Прокси и логика:**
*   **Прокси:** Создает прокси, управляющий кэшированием. Обычно это отдельный прокси, который может быть встроен в цепочку с другими.
*   **Логика внутри прокси:**
    1.  **Before:** Прокси генерирует ключ кэша (на основе параметров метода, `keyGenerator` и т.д.).
    2.  Проверяет в `CacheManager` наличие закэшированного значения в указанном `cache` (или `caches`).
    3.  **Если значение найдено:** Возвращает его немедленно, **не вызывая целевой метод**.
    4.  **Если значение не найдено:** Вызывает целевой метод, получает результат.
    5.  **After:** Сохраняет результат в кэш.

**Важные нюансы:**
*   Как и другие, не работает при self-invocation.
*   Часто используется вместе с `@CacheEvict` и `@CachePut`.

---

### 4. Проблема Self-Invocation и ее решение

**Проблема:**
```java
@Service
public class MyService {

    public void doWork() {
        this.asyncProcess(); // Вызов внутри того же класса -> прокси игнорируется!
        this.calculateSomething(); // @Cacheable не сработает!
        this.updateData(); // @Transactional не сработает!
    }

    @Async
    public void asyncProcess() { ... }

    @Cacheable("data")
    public String calculateSomething() { ... }

    @Transactional
    public void updateData() { ... }
}
```
В этом примере вызовы идут напрямую на `this`, минуя прокси.

**Решения:**

1.  **Вынести методы в другой бин (рекомендуется):** Это наиболее чистое решение с точки зрения архитектуры.
    ```java
    @Service
    public class MyService {
        @Autowired
        private AsyncHelper asyncHelper;

        @Autowired
        private CacheHelper cacheHelper;

        @Autowired
        private TransactionalHelper transactionalHelper;

        public void doWork() {
            asyncHelper.asyncProcess(); // Вызов через прокси другого бина
            cacheHelper.calculateSomething();
            transactionalHelper.updateData();
        }
    }

    @Service
    public class AsyncHelper {
        @Async
        public void asyncProcess() { ... }
    }
    // ... аналогично для других помощников
    ```

2.  **Использование `AopContext.currentProxy()` (осторожно!):**
    ```java
    @Service
    @EnableAspectJAutoProxy(exposeProxy = true) // Не забудьте включить!
    public class MyService {

        public void doWork() {
            MyService proxy = (MyService) AopContext.currentProxy();
            proxy.asyncProcess(); // Теперь вызов идет через прокси
            proxy.calculateSomething();
            proxy.updateData();
        }
        // ... методы с аннотациями
    }
    ```
    Этот способ нарушает инкапсуляцию и делает код завязанным на Spring AOP, но он работает.

---

### 5. Композиция аннотаций и порядок прокси

Если метод помечен несколькими аннотациями, какова будет последовательность действий?

```java
@Transactional
@Cacheable("books")
public Book findBook(Long id) {
    // ...
}
```

В этом случае создается **цепочка прокси (Interceptors)**. Порядок имеет значение!

1.  Обычно первым срабатывает **Кэширование** (`@Cacheable`). Прокси проверяет кэш.
    *   Если данные в кэше есть — метод не вызывается, и, что важно, **транзакция не открывается**.
    *   Если данных нет — управление передается дальше.
2.  Срабатывает **Транзакционный** прокси. Он открывает транзакцию.
3.  Вызывается **целевой метод** `findBook`.
4.  Транзакционный прокси коммитит транзакцию.
5.  Кэширующий прокси сохраняет результат в кэш.

**Вывод:** Порядок следования Advice критичен. Вы можете управлять им с помощью аннотации `@Order` на соответствующих аспектах или конфигурациях.

### Итог для Senior-разработчика

*   **Понимание механизма** генерации прокси — это ключ к диагностике множества "мистических" багов в Spring-приложениях (особенно связанных с `@Transactional` и `@Async`).
*   **Self-invocation** — самая частая проблема, и Senior должен не только знать о ней, но и уметь объяснить команде и предложить правильное архитектурное решение.
*   **Выбор между JDK и CGLIB** может влиять на производительность и требования к коду (например, отсутствие `final` методов).
*   **Понимание порядка применения Advice** необходимо для написания корректного кода, когда аннотации комбинируются.

Это знание позволяет не просто использовать аннотации, а полностью контролировать их поведение в сложных enterprise-приложениях.