Привет! Разберём вызов Java-кода из Kotlin — важную тему для senior backend разработчиков, работающих с Kotlin.

## Основные аспекты взаимодействия Kotlin с Java

### 1. Базовое взаимодействие

**Прямой вызов Java-классов:**
```kotlin
// Java класс
public class UserService {
    public User findUserById(Long id) {
        return new User(id, "John");
    }
}

// Kotlin вызов
val userService = UserService()
val user = userService.findUserById(1L)
```

### 2. Null-безопасность

**Обработка nullable типов:**
```kotlin
// Java метод может вернуть null
public String getUserName(Long id) {
    return id == 1L ? "John" : null;
}

// Kotlin - используем safe call
val name: String? = getUserName(2L)
val length = name?.length ?: 0

// Или явно указываем платформенный тип
val name: String! = getUserName(1L) // String! - платформенный тип
```

### 3. Аннотации для улучшения взаимодействия

**@Nullable и @NotNull:**
```java
// Java класс с аннотациями
public class DataService {
    @NotNull
    public String getRequiredData() {
        return "data";
    }
    
    @Nullable
    public String getOptionalData() {
        return Math.random() > 0.5 ? "optional" : null;
    }
}
```

```kotlin
// Kotlin - автоматически учитывает аннотации
val required: String = dataService.requiredData // Non-null
val optional: String? = dataService.optionalData // Nullable
```

### 4. Коллекции

**Взаимодействие с Java коллекциями:**
```kotlin
// Java метод возвращает List<String>
public List<String> getItems() {
    return Arrays.asList("a", "b", "c");
}

// Kotlin
val items = javaService.items
// items имеет тип List<String!> - платформенная коллекция

// Безопасное использование
val safeItems = items.filterNotNull()
// Или
items.forEach { item ->
    item?.let { safeItem ->
        println(safeItem.uppercase())
    }
}
```

### 5. Функциональные интерфейсы (SAM)

**Работа с Java функциональными интерфейсами:**
```java
// Java интерфейс
public interface Calculator {
    int calculate(int a, int b);
}

public class MathService {
    public static int compute(Calculator calculator, int a, int b) {
        return calculator.calculate(a, b);
    }
}
```

```kotlin
// Kotlin вызов
val result = MathService.compute({ a, b -> a + b }, 5, 3)

// Или с явным указанием типа
val calculator = Calculator { a, b -> a * b }
val result2 = MathService.compute(calculator, 4, 2)
```

### 6. Checked Exceptions

**Обработка проверяемых исключений:**
```java
// Java метод с checked exception
public void processFile(String path) throws IOException {
    // код работы с файлом
}
```

```kotlin
// Kotlin - не требует объявления throws
fun handleFile() {
    try {
        javaService.processFile("path.txt")
    } catch (e: IOException) {
        // Обработка исключения
        println("File error: ${e.message}")
    }
}
```

### 7. Геттеры/сеттеры как свойства

**Автоматическое преобразование:**
```java
// Java класс
public class User {
    private String name;
    private int age;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return age; }
    public void setAge(int age) { this.age = age; }
    
    public boolean isActive() { return true; }
}
```

```kotlin
// Kotlin доступ
val user = User()
user.name = "John"        // вместо setName()
println(user.age)         // вместо getAge()
println(user.isActive)    // вместо isActive()
```

### 8. Статические методы и поля

**Работа со статическими членами:**
```java
// Java утилитный класс
public class StringUtils {
    public static final String DEFAULT_VALUE = "default";
    
    public static boolean isEmpty(String str) {
        return str == null || str.isEmpty();
    }
}
```

```kotlin
// Kotlin вызов
val defaultValue = StringUtils.DEFAULT_VALUE
val isEmpty = StringUtils.isEmpty("test")

// Или с import
import StringUtils.isEmpty

fun checkString(str: String) {
    if (isEmpty(str)) {
        println("String is empty")
    }
}
```

## Продвинутые сценарии

### 9. Builder Pattern

**Работа с Java билдерами:**
```java
// Java билдер
public class QueryBuilder {
    private String select;
    private String from;
    
    public QueryBuilder select(String select) {
        this.select = select;
        return this;
    }
    
    public QueryBuilder from(String from) {
        this.from = from;
        return this;
    }
    
    public String build() {
        return "SELECT " + select + " FROM " + from;
    }
}
```

```kotlin
// Kotlin использование
val query = QueryBuilder()
    .select("name, age")
    .from("users")
    .build()

// Или с применением scope функций
val query2 = QueryBuilder().apply {
    select("count(*)")
    from("orders")
}.build()
```

### 10. JPA и Hibernate

**Работа с Entity классами:**
```kotlin
// Java Entity
@Entity
public class User {
    @Id
    private Long id;
    private String name;
    
    // геттеры/сеттеры
}

// Kotlin репозиторий
@Repository
class UserRepository(
    private val entityManager: EntityManager
) {
    fun findActiveUsers(): List<User> {
        return entityManager.createQuery(
            "SELECT u FROM User u WHERE u.active = true", 
            User::class.java
        ).resultList
    }
    
    fun saveUser(user: User): User {
        return if (user.id == null) {
            entityManager.persist(user)
            user
        } else {
            entityManager.merge(user)
        }
    }
}
```

### 11. Асинхронные вызовы

**Работа с CompletableFuture:**
```kotlin
// Java сервис возвращает CompletableFuture
public CompletableFuture<String> asyncOperation(String input) {
    return CompletableFuture.supplyAsync(() -> {
        // длительная операция
        return input.toUpperCase();
    });
}
```

```kotlin
// Kotlin вызов с coroutines
suspend fun processData(input: String): String {
    return javaService.asyncOperation(input).await()
}

// Или с колбэками
fun processWithCallback(input: String, callback: (String) -> Unit) {
    javaService.asyncOperation(input).thenAccept { result ->
        callback(result)
    }
}
```

## Лучшие практики

### 12. Аннотации для Kotlin

**@JvmName, @JvmStatic, @JvmOverloads:**
```kotlin
class KotlinService {
    companion object {
        @JvmStatic
        fun staticMethod() = println("Static method")
        
        @JvmName("processDataInternal")
        fun processData(data: List<String>) { ... }
    }
    
    @JvmOverloads
    fun compute(a: Int, b: Int = 10, c: Int = 20) = a + b + c
}
```

### 13. Миграция стратегия

**Постепенная миграция:**
```kotlin
// Существующий Java код
public class LegacyService {
    public void process(List<String> items) { ... }
}

// Kotlin расширение
fun LegacyService.processSafe(items: List<String>) {
    val safeItems = items.filterNotNull()
    this.process(safeItems)
}

// Постепенная замена
class ModernService : LegacyService() {
    fun processKotlin(items: List<String>) {
        // Новая логика на Kotlin
    }
}
```

## Потенциальные проблемы и решения

### 14. Common Issues

**Проблема с перегрузкой методов:**
```kotlin
// Java класс с перегруженными методами
public void process(List<String> items) { ... }
public void process(Set<String> items) { ... }

// Kotlin - используем аннотацию @JvmName
@JvmName("processStringList")
fun process(items: List<String>) = javaService.process(items)

@JvmName("processStringSet")  
fun process(items: Set<String>) = javaService.process(items)
```

**Работа с массивами:**
```kotlin
// Java метод с varargs
public void acceptItems(String... items) { ... }

// Kotlin вызов
javaService.acceptItems("a", "b", "c")
// Или с spread оператором
val items = arrayOf("a", "b", "c")
javaService.acceptItems(*items)
```

Эти знания помогут эффективно интегрировать Kotlin в существующие Java-проекты и обеспечить плавную миграцию кода.