Коллеги, вот разбор темы "Варианты read/write и масштабирования для БД" с точки зрения Senior Java-разработчика. Файл `19.Varianty_read_write_masshtabirovaniya_dlya_DB.md` скорее всего содержит ключевые паттерны и стратегии, которые мы используем в высоконагруженных системах.

## 1. Стратегии Чтения (Read Patterns)

### Read-Through Cache
```java
@Service
public class UserService {
    private final CacheRepository cache;
    private final UserRepository db;
    
    public User getUser(Long id) {
        return cache.get("user:" + id)
            .orElseGet(() -> {
                User user = db.findById(id);
                cache.set("user:" + id, user);
                return user;
            });
    }
}
```

### CQRS (Command Query Responsibility Segregation)
```java
// Query Side - оптимизирован для чтения
@Repository
public interface UserReadRepository extends JpaRepository<UserView, Long> {
    @Query("SELECT new UserDTO(u.id, u.username, p.email) " +
           "FROM User u JOIN Profile p ON u.id = p.userId " +
           "WHERE u.active = true")
    List<UserDTO> findActiveUsersWithEmails();
}

// Command Side - оптимизирован для записи
@Service
@Transactional
public class UserCommandService {
    public void createUser(CreateUserCommand command) {
        User user = new User(command.username());
        userRepository.save(user);
        eventPublisher.publish(new UserCreatedEvent(user.getId()));
    }
}
```

## 2. Стратегии Записи (Write Patterns)

### Write-Through Cache
```java
@Service
public class OrderService {
    public void createOrder(Order order) {
        // Запись в кэш и БД атомарно
        cache.put("order:" + order.getId(), order);
        orderRepository.save(order);
    }
}
```

### Write-Behind (Async Writes)
```java
@Component
public class AnalyticsService {
    private final Queue<AnalyticsEvent> queue = new ConcurrentLinkedQueue<>();
    private final BatchWriter batchWriter;
    
    @Async
    public void trackEvent(AnalyticsEvent event) {
        queue.offer(event);
        if (queue.size() >= BATCH_SIZE) {
            batchWriter.flush(new ArrayList<>(queue));
            queue.clear();
        }
    }
}
```

## 3. Горизонтальное Масштабирование

### Шардирование (Sharding)
```java
@Component
public class ShardingManager {
    private final List<DataSource> shards;
    
    public DataSource getShard(Long userId) {
        int shardIndex = (int) (userId % SHARD_COUNT);
        return shards.get(shardIndex);
    }
}

// Spring Data с шардированием
@Repository
public interface UserRepository {
    @Query("#{#shardingRepository.getShard(#userId)}")
    User findByUserId(@Param("userId") Long userId);
}
```

### Репликация (Read Replicas)
```java
@Configuration
public class ReplicationConfig {
    @Bean
    @Primary
    public DataSource dataSource() {
        ReplicationDataSource dataSource = new ReplicationDataSource();
        dataSource.setMaster(masterDataSource());
        dataSource.setSlaves(List.of(replica1(), replica2()));
        return dataSource;
    }
    
    @Bean
    @Qualifier("readOnlyDataSource")
    public DataSource readOnlyDataSource() {
        // Для операций только на чтение
        return loadBalancedReplicaDataSource();
    }
}
```

## 4. Паттерны для Высоких Нагрузок

### Circuit Breaker для БД
```java
@Service
@CircuitBreaker(name = "userService", fallbackMethod = "getUserFallback")
public class UserService {
    public User getUser(Long id) {
        return userRepository.findById(id);
    }
    
    public User getUserFallback(Long id, Exception e) {
        return cache.get("user:" + id)
            .orElse(User.defaultUser());
    }
}
```

### Batch Processing
```java
@Repository
public class BatchUserRepository {
    private final JdbcTemplate jdbcTemplate;
    
    @Transactional
    public void bulkInsert(List<User> users) {
        jdbcTemplate.batchUpdate(
            "INSERT INTO users (id, name, email) VALUES (?, ?, ?)",
            users,
            100, // batch size
            (ps, user) -> {
                ps.setLong(1, user.getId());
                ps.setString(2, user.getName());
                ps.setString(3, user.getEmail());
            }
        );
    }
}
```

## 5. Event Sourcing + CQRS
```java
// Event Store
@Entity
public class EventStore {
    @Id
    private Long id;
    private String aggregateId;
    private String eventType;
    private String eventData;
    private LocalDateTime timestamp;
}

// Projection для чтения
@Component
public class UserProjection {
    private final Map<String, UserView> users = new ConcurrentHashMap<>();
    
    @EventListener
    public void handle(UserCreatedEvent event) {
        users.put(event.getUserId(), 
            new UserView(event.getUserId(), event.getUsername()));
    }
    
    @EventListener
    public void handle(UserEmailUpdatedEvent event) {
        UserView user = users.get(event.getUserId());
        user.setEmail(event.getNewEmail());
    }
}
```

## 6. Мониторинг и Оптимизация

### Connection Pool настройка
```yaml
# application.yml
spring:
  datasource:
    hikari:
      maximum-pool-size: 20
      minimum-idle: 5
      connection-timeout: 30000
      idle-timeout: 600000
      max-lifetime: 1800000
```

### Метрики и Мониторинг
```java
@Component
public class DatabaseMetrics {
    private final MeterRegistry meterRegistry;
    
    @EventListener
    public void handle(DataSourcePoolMetricsEvent event) {
        meterRegistry.gauge("db.connections.active", 
            event.getActiveConnections());
        meterRegistry.gauge("db.connections.idle", 
            event.getIdleConnections());
    }
}
```

## Ключевые Рекомендации:

1. **Для чтения**: Кэширование + Реплики + CQRS
2. **Для записи**: Батчинг + Шардирование + Async
3. **Для согласованности**: Eventual Consistency + Компенсирующие транзакции
4. **Для отказоустойчивости**: Circuit Breaker + Retry Patterns

Выбор стратегии зависит от конкретных требований: соотношение read/write, требования к консистентности, допустимая задержка. В реальных проектах часто комбинируем несколько подходов.