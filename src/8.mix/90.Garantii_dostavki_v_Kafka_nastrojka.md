Привет! Как старший разработчик, с удовольствием расскажу о гарантиях доставки в Kafka и их настройке. Это критически важная тема для построения надежных систем.

## 1. Основные гарантии доставки

В Kafka есть три основных уровня гарантий:

### At-most-once (максимум один раз)
- Сообщения могут быть потеряны, но никогда не доставлены повторно
- Используется когда скорость важнее надежности

### At-least-once (минимум один раз)
- Сообщения никогда не теряются, но могут быть доставлены повторно
- Наиболее распространенный сценарий

### Exactly-once (ровно один раз)
- Каждое сообщение доставляется ровно один раз
- Самый сложный для реализации вариант

## 2. Настройка Producer

### Для At-least-once:
```java
Properties props = new Properties();
props.put("acks", "all"); // Ждем подтверждения от всех реплик
props.put("retries", Integer.MAX_VALUE);
props.put("max.in.flight.requests.per.connection", 1); // Сохраняем порядок
props.put("enable.idempotence", true); // Идемпотентность
props.put("delivery.timeout.ms", 30000); // Таймаут доставки
props.put("request.timeout.ms", 30000);
```

### Для Exactly-once:
```java
props.put("enable.idempotence", true);
props.put("acks", "all");
props.put("retries", Integer.MAX_VALUE);
props.put("max.in.flight.requests.per.connection", 5);
props.put("transactional.id", "my-transactional-id"); // Для транзакций
```

## 3. Настройка Consumer

### At-least-once:
```java
Properties props = new Properties();
props.put("enable.auto.commit", "false"); // Ручное подтверждение

// В коде обработки:
while (true) {
    ConsumerRecords<String, String> records = consumer.poll(Duration.ofMillis(100));
    for (ConsumerRecord<String, String> record : records) {
        // Обрабатываем сообщение
        processMessage(record);
    }
    consumer.commitSync(); // Подтверждаем после обработки
}
```

### Exactly-once с транзакциями:
```java
props.put("isolation.level", "read_committed"); // Только committed сообщения

// Producer с транзакциями
producer.initTransactions();
try {
    producer.beginTransaction();
    
    // Отправка сообщений
    producer.send(record1);
    producer.send(record2);
    
    // Коммит транзакции
    producer.commitTransaction();
} catch (Exception e) {
    producer.abortTransaction();
    throw e;
}
```

## 4. Критические параметры для надежности

### Producer:
- **acks=all** - ждем подтверждения от всех ISR реплик
- **min.insync.replicas=2** - минимальное количество синхронизированных реплик
- **replication.factor=3** - фактор репликации

### Broker:
```properties
# в server.properties
default.replication.factor=3
min.insync.replicas=2
unclean.leader.election.enable=false
```

### Consumer:
- **enable.auto.commit=false** - отключаем авто-коммит
- **auto.offset.reset=latest/earliest** - поведение при отсутствии офсета

## 5. Практические рекомендации

### Для большинства случаев:
```java
// Producer
props.put("acks", "all");
props.put("retries", 10);
props.put("enable.idempotence", true);
props.put("max.in.flight.requests.per.connection", 5);

// Consumer
props.put("enable.auto.commit", false);
props.put("auto.offset.reset", "latest");
```

### Мониторинг и метрики:
```java
// Добавляем метрики для мониторинга
props.put("metric.reporters", "com.example.KafkaMetricsReporter");
props.put("metrics.num.samples", 2);
props.put("metrics.sample.window.ms", 30000);
```

## 6. Обработка ошибок

### Producer:
```java
public void sendWithRetry(String topic, String key, String value) {
    ProducerRecord<String, String> record = new ProducerRecord<>(topic, key, value);
    
    try {
        RecordMetadata metadata = producer.send(record).get();
        logger.info("Message sent to partition {} with offset {}", 
                   metadata.partition(), metadata.offset());
    } catch (InterruptedException | ExecutionException e) {
        logger.error("Error sending message", e);
        // Логика повторной отправки или сохранения в DLQ
    }
}
```

## 7. Best Practices

1. **Всегда настраивайте идемпотентность** если возможны повторные отправки
2. **Используйте транзакции** для критически важных операций
3. **Мониторьте lag потребителей** и количество реплик
4. **Тестируйте сценарии сбоев** - отказ брокеров, сетевые проблемы
5. **Используйте Dead Letter Queues** для проблемных сообщений

Помните, что выбор гарантий доставки - это всегда компромисс между надежностью и производительностью. Начинайте с at-least-once и переходите к exactly-once только когда это действительно необходимо.