Коллеги, сегодня разберем ключевые аспекты работы MongoDB с движком хранения WireTiger и механизмами блокировок. Как Senior Java Developer, вы должны понимать, как эти особенности влияют на проектирование приложений.

## 1. Движок хранения WireTiger

### Основные преимущества:
- **Document-level concurrency** - блокировка на уровне документа, а не всей коллекции
- **Snapshot isolation** - согласованность данных на уровне снимка
- **Compression** - сжатие данных и индексов
- **Checkpoints** - периодическая запись данных на диск

### Настройки, важные для Java-разработчика:
```yaml
# application.yml
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/test
      
# WiredTiger config в MongoDB
storage:
  wiredTiger:
    engineConfig:
      cacheSizeGB: 2
      journalCompressor: snappy
    collectionConfig:
      blockCompressor: snappy
```

## 2. Модель блокировок в MongoDB

### Уровни блокировок:
- **Global** - редко используется
- **Database** - для операций DDL
- **Collection** - для создания индексов
- **Document** - основной уровень для CRUD операций

### Пример проблемной ситуации:
```java
// ПРОБЛЕМА: Длительная операция блокирует документы
@Transactional
public void transferMoney(String fromAccount, String toAccount, BigDecimal amount) {
    // Эти две операции выполняются не атомарно с точки зрения пользователя
    accountRepository.decrementBalance(fromAccount, amount);
    // Между операциями - окно уязвимости
    accountRepository.incrementBalance(toAccount, amount);
}
```

## 3. Оптимизации для Java-приложений

### Стратегии работы с транзакциями:
```java
@Service
public class AccountService {
    
    // Хорошо: Использование встроенных атомарных операторов
    public void transferMoneyAtomic(String fromAccount, String toAccount, BigDecimal amount) {
        mongoTemplate.update(Account.class)
            .matching(where("id").is(fromAccount).and("balance").gte(amount))
            .apply(new Update().inc("balance", -amount.doubleValue()))
            .findAndModify();
            
        mongoTemplate.update(Account.class)
            .matching(where("id").is(toAccount))
            .apply(new Update().inc("balance", amount.doubleValue()))
            .findAndModify();
    }
    
    // Лучше: Использование транзакций (MongoDB 4.0+)
    @Transactional
    public void transferMoneyTransactional(String fromAccount, String toAccount, BigDecimal amount) {
        // MongoDB будет использовать document-level locking
        Account from = accountRepository.findById(fromAccount).orElseThrow();
        Account to = accountRepository.findById(toAccount).orElseThrow();
        
        if (from.getBalance().compareTo(amount) < 0) {
            throw new InsufficientFundsException();
        }
        
        from.setBalance(from.getBalance().subtract(amount));
        to.setBalance(to.getBalance().add(amount));
        
        accountRepository.saveAll(List.of(from, to));
    }
}
```

## 4. Мониторинг и диагностика

### Полезные запросы для отладки:
```javascript
// Текущие операции
db.currentOp()

// Статистика блокировок
db.serverStatus().locks

// Активные транзакции в WiredTiger
db.runCommand({serverStatus: 1}).wiredTiger.transaction
```

### Настройки мониторинга в Java:
```java
@Configuration
public class MongoConfig {
    
    @Bean
    public MongoClient mongoClient() {
        return MongoClients.create(MongoClientSettings.builder()
            .applyToConnectionPoolSettings(builder -> 
                builder.maxSize(50)
                       .minSize(10)
                       .maxWaitTime(2000))
            .applyToSocketSettings(builder ->
                builder.connectTimeout(2000, TimeUnit.MILLISECONDS)
                       .readTimeout(5000, TimeUnit.MILLISECONDS))
            .build());
    }
}
```

## 5. Рекомендации для разработки

### Паттерны для высоконагруженных приложений:

```java
@Component
public class OrderService {
    
    // Плохо: Последовательные обновления
    public void processOrderSequential(Order order) {
        inventoryRepository.decrementStock(order.getItems()); // Блокировка документов
        orderRepository.save(order); // Еще блокировка
        auditRepository.logOrder(order); // И еще блокировка
    }
    
    // Хорошо: Пакетная обработка
    public void processOrderBatch(Order order) {
        // Все операции в одной транзакции - меньше времени блокировок
        mongoTemplate.inTransaction(() -> {
            inventoryRepository.decrementStockBatch(order.getItems());
            orderRepository.save(order);
            auditRepository.logOrder(order);
        });
    }
    
    // Лучше: Оптимистичные блокировки
    public boolean updateWithOptimisticLock(Product product, int quantity) {
        return mongoTemplate.update(Product.class)
            .matching(where("id").is(product.getId())
                     .and("version").is(product.getVersion()))
            .apply(new Update()
                .inc("stock", -quantity)
                .inc("version", 1))
            .allMatched(); // Возвращает false при конфликте
    }
}
```

## 6. Производительность в кластерных конфигурациях

### Для репликасетов:
```java
@Configuration
public class MongoReadPreferenceConfig {
    
    @Bean
    public MongoTemplate mongoTemplate() {
        MongoTemplate template = new MongoTemplate(mongoClient(), "database");
        template.setReadPreference(ReadPreference.secondaryPreferred());
        return template;
    }
}
```

## Ключевые выводы:

1. **Используйте атомарные операции** когда возможно вместо транзакций
2. **Проектируйте схему данных** чтобы минимизировать конкурентные обновления
3. **Мониторьте slow queries** - они могут удерживать блокировки долгое время
4. **Настраивайте timeout'ы** в драйвере для избежания deadlock'ов
5. **Тестируйте под нагрузкой** сценарии конкурентного доступа

Понимание этих механизмов поможет вам создавать более эффективные и надежные приложения на MongoDB.