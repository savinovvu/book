Коллеги, сегодня мы глубоко погрузимся в тему индексов в MongoDB — критически важный аспект для любого Senior Java-разработчика, работающего с высоконагруженными приложениями. Разберём не только базовые концепции, но и тонкости, которые влияют на производительность в продакшене.

## 1. **Что такое индексы в MongoDB?**
Индексы — это специальные структуры данных, которые хранят части данных коллекции в упорядоченной форме. Они работают по принципу **B-деревьев**, что позволяет:
- Ускорить поиск документов
- Оптимизировать сортировку
- Эффективно использовать диапазонные запросы

Без индекса MongoDB выполняет **collection scan** — полное сканирование всех документов, что неприемлемо для больших коллекций.

## 2. **Типы индексов и их применение**

### Основные типы:
- **Single Field** — индекс по одному полю
- **Compound** — составной индекс по нескольким полям
- **Multikey** — для массивов (автоматически создаётся)
- **Text** — полнотекстовый поиск
- **Geospatial** — для геоданных
- **Hashed** — для шардирования
- **Wildcard** — для динамических полей
- **Unique** — гарантия уникальности

## 3. **Составные индексы: Правила ESR**
Для составных индексов критически важен порядок полей. Запомните акроним **ESR**:

1. **E**quality (равенство) — поля с точными匹配
2. **S**ort (сортировка) — поля для ORDER BY
3. **R**ange (диапазон) — поля с диапазонными запросами

**Пример правильного индекса:**
```java
// Запрос: find({department: "IT", salary: {$gte: 5000}}).sort({joinDate: -1})

// Создаём индекс согласно ESR:
db.employees.createIndex({
    "department": 1,    // E: равенство
    "joinDate": -1,     // S: сортировка  
    "salary": 1         // R: диапазон
});
```

## 4. **Индексы в Java-приложениях**

### Создание через MongoTemplate:
```java
@Configuration
public class MongoConfig {
    
    @Autowired
    private MongoTemplate mongoTemplate;
    
    @PostConstruct
    public void createIndexes() {
        // Составной индекс
        mongoTemplate.getCollection("orders")
            .createIndex(Indexes.compoundIndex(
                Indexes.ascending("customerId"),
                Indexes.descending("createdAt"),
                Indexes.ascending("status")
            ));
            
        // TTL индекс для автоматического удаления
        mongoTemplate.getCollection("sessions")
            .createIndex(Indexes.ascending("expireAt"), 
                new IndexOptions().expireAfter(0L, TimeUnit.SECONDS));
    }
}
```

### Spring Data аннотации:
```java
@Document(collection = "products")
@CompoundIndex(name = "category_price", 
    def = "{'categoryId': 1, 'price': -1}",
    background = true)
public class Product {
    @Indexed(unique = true)
    private String sku;
    
    @Indexed
    private String categoryId;
    
    private BigDecimal price;
}
```

## 5. **Критические аспекты производительности**

### Covering Queries (покрывающие запросы):
```java
// Индекс покрывает все поля запроса
db.products.createIndex({"categoryId": 1, "name": 1, "price": 1});

// Запрос использует только индекс, не обращаясь к документам
db.products.find(
    {"categoryId": "electronics", "name": /^smartphone/}, 
    {"_id": 0, "categoryId": 1, "name": 1, "price": 1}
);
```

### Partial Indexes (частичные индексы):
```java
// Индексируем только активных пользователей
db.users.createIndex(
    {"email": 1}, 
    {"partialFilterExpression": {"status": "ACTIVE"}}
);
```

## 6. **Мониторинг и анализ**

### Explain в Java:
```java
public void analyzeQuery(String category) {
    MongoCollection<Document> collection = mongoDatabase.getCollection("products");
    
    FindIterable<Document> result = collection
        .find(Filters.eq("category", category))
        .sort(Sorts.descending("price"))
        .explain(ExplainVerbosity.EXECUTION_STATS);
    
    Document explanation = result.first();
    System.out.println("Query plan: " + explanation.toJson());
}
```

### Ключевые метрики:
- **executionTimeMillis** — общее время выполнения
- **totalKeysExamined** — количество проверенных ключей
- **totalDocsExamined** — количество проверенных документов
- **stage** — тип операции (IXSCAN, COLLSCAN)

## 7. **Антипаттерны и лучшие практики**

### ❌ Что НЕ делать:
```java
// 1. Слишком много индексов на одну коллекцию
// 2. Индексы на часто обновляемые поля
// 3. Составные индексы с высокой кардинальностью в начале
// 4. Индексы, которые никогда не используются
```

### ✅ Лучшие практики:
```java
// 1. Мониторьте медленные запросы
db.setProfilingLevel(1, { slowms: 100 })

// 2. Анализируйте использование индексов
db.orders.getIndexes().forEach(index => {
    const stats = db.orders.aggregate([
        {$indexStats: {}}
    ]).toArray();
    printjson(stats);
});

// 3. Удаляйте неиспользуемые индексы
db.orders.dropIndex("unused_index_name")
```

## 8. **Работа в кластере**

### Индексы при шардировании:
```java
// Индекс должен включать shard key
db.orders.createIndex({
    "shardKey": 1,      // Ключ шардирования
    "createdAt": -1,    // Сортировка
    "customerId": 1     // Дополнительное поле
});

// Глобальные vs локальные индексы
// Уникальные индексы должны включать shard key
```

## 9. **Профилирование в Spring Boot**

### Конфигурация application.yml:
```yaml
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/test
logging:
  level:
    org.springframework.data.mongodb.core.MongoTemplate: DEBUG
```

### Кастомный мониторинг:
```java
@Component
public class QueryMetricsAspect {
    
    @Around("execution(* org.springframework.data.mongodb.repository.MongoRepository.*(..))")
    public Object logQueryPerformance(ProceedingJoinPoint joinPoint) throws Throwable {
        long startTime = System.currentTimeMillis();
        Object result = joinPoint.proceed();
        long duration = System.currentTimeMillis() - startTime;
        
        if (duration > 100) { // threshold 100ms
            log.warn("Slow MongoDB query: {} took {}ms", 
                joinPoint.getSignature().getName(), duration);
        }
        
        return result;
    }
}
```

## 10. **Практические рекомендации**

1. **Проектируйте индексы под запросы**, а не под документы
2. **Используйте background построение** для продакшена
3. **Мониторьте размер индексов** — они должны помещаться в RAM
4. **Периодически перестраивайте индексы** для дефрагментации
5. **Тестируйте планы запросов** на реалистичных данных

## Заключение

Правильная работа с индексами — это не просто создание их на каждом поле. Это глубокое понимание:
- **Паттернов доступа** к данным в вашем приложении
- **Требований** к чтению vs записи
- **Архитектуры** кластера MongoDB
- **Бизнес-логики** запросов

Индексы — мощный инструмент, но их неправильное использование может ухудшить производительность. Всегда измеряйте, анализируйте и тестируйте перед внедрением в продакшен.

Есть вопросы по конкретным кейсам? Готов обсудить ваши сценарии!