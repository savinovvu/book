Отличный и очень важный вопрос! При переходе на реактивный стек (WebFlux) многие привычные аннотации ведут себя совершенно иначе или имеют серьезные ограничения.

## `@Transactional` в WebFlux

### Основная проблема
**Традиционный `@Transactional` НЕ РАБОТАЕТ с реактивными типами (Mono/Flux) из коробки.**

Почему:
- Стандартная транзакционность в Spring работает через `TransactionSynchronizationManager`, который использует `ThreadLocal`
- В реактивном программировании один запрос может обрабатываться разными потоками (thread hopping)
- `ThreadLocal` не передается между потоками в реактивной цепочке

### Решения для транзакций в WebFlux:

#### 1. R2DBC с декларативными транзакциями
```java
// НЕ РАБОТАЕТ ТАК:
@Transactional // ❌ Не будет работать с Mono
public Mono<User> saveUser(User user) {
    return userRepository.save(user);
}

// Вместо этого используйте:
@Service
public class UserService {
    
    private final DatabaseClient databaseClient;
    
    // Транзакция управляется вручную через DatabaseClient
    public Mono<Void> saveWithTransaction(User user) {
        return databaseClient.inTransaction(db -> 
            db.sql("INSERT INTO users (...) VALUES (...)")
              .bind(...)
              .fetch()
              .rowsUpdated()
              .then()
        );
    }
}
```

#### 2. Spring Data R2DBC Transactions
```java
@Transactional // ✅ Работает, но требует специальной настройки
public Mono<User> saveUser(User user) {
    return userRepository.save(user);
}

// Конфигурация:
@Configuration
@EnableTransactionManagement
public class R2dbcConfig {
    
    @Bean
    public ReactiveTransactionManager transactionManager(
        ConnectionFactory connectionFactory) {
        return new R2dbcTransactionManager(connectionFactory);
    }
}
```

**Ограничения:**
- Транзакции работают только в пределах одного Publisher (Mono/Flux)
- Нет поддержки распределенных транзакций (XA)
- Осторожно с операциями, которые могут переключать потоки

---

## `@Cacheable` в WebFlux

### Работает, но с серьезными нюансами:

#### 1. Кэширование Mono/Flux
```java
@Service
public class UserService {
    
    @Cacheable("users")
    public Mono<User> findById(Long id) {
        // ❌ ОПАСНО: кэшируется сам Publisher, а не его результат
        return userRepository.findById(id);
    }
    
    @Cacheable("users")
    public Mono<User> findByIdSafe(Long id) {
        // ✅ Лучше: использовать .cache() для кэширования результата
        return userRepository.findById(id).cache();
    }
}
```

#### 2. Реактивные CacheManager
```java
@Configuration
@EnableCaching
public class CacheConfig {
    
    @Bean
    public ReactiveCacheManager cacheManager() {
        // Использование реактивного кэш-менеджера
        return new ReactiveRedisCacheManager(redisTemplate);
    }
}
```

#### 3. Проблемы и ограничения:

**Кэширование Publisher'ов:**
```java
@Cacheable("users")
public Mono<User> getUser(Long id) {
    // Проблема: при каждом вызове создается новый Publisher
    // Кэшируется не результат, а "обещание" результата
    return userRepository.findById(id);
}

// Решение:
@Cacheable("users")
public Mono<User> getUserCached(Long id) {
    return userRepository.findById(id)
        .cache(Duration.ofMinutes(30)); // Явное кэширование
}
```

**Проблемы с ключами:**
```java
@Cacheable(value = "users", key = "#id")
public Mono<User> findById(Long id) {
    // Работает нормально
}

@Cacheable(value = "users", key = "#user.id")
public Mono<User> updateUser(Mono<User> user) {
    // ❌ Проблема: key извлекается из Mono, а не из его значения
    // SpEL видит Mono, а не User
}
```

**Условное кэширование:**
```java
@Cacheable(value = "users", 
           condition = "#result != null", 
           unless = "#result == null")
public Mono<User> findById(Long id) {
    // ❌ НЕ РАБОТАЕТ: #result - это Mono, а не User
    // SpEL не может "заглянуть" внутрь реактивного типа
}

// Решение через метод-обертку:
public Mono<User> findByIdCached(Long id) {
    return findById(id)
        .transform(mono -> {
            if (/* условие */) {
                return mono.cache();
            }
            return mono;
        });
}
```

---

## Best Practices для WebFlux

### 1. Для транзакций:
```java
@Service
public class TransactionalService {
    
    // Используйте реактивные транзакции явно
    public Mono<Void> complexOperation() {
        return transactionalOperator.execute(status -> 
            userRepository.save(user1)
                .then(profileRepository.save(profile))
                .then()
        );
    }
    
    // Или через @Transactional с ReactiveTransactionManager
    @Transactional
    public Mono<User> saveWithTransaction(User user) {
        return userRepository.save(user);
    }
}
```

### 2. Для кэширования:
```java
@Service
public class CachingService {
    
    // Явное кэширование с помощью .cache()
    public Mono<User> getUser(Long id) {
        return userRepository.findById(id)
            .name("getUser") // для мониторинга
            .metrics()
            .cache(Duration.ofMinutes(30));
    }
    
    // Или используйте реактивные реализации Cache
    public Mono<User> getUserCached(Long id) {
        return reactiveCacheManager.getCache("users")
            .get(id, User.class)
            .switchIfEmpty(
                userRepository.findById(id)
                    .flatMap(user -> 
                        reactiveCacheManager.getCache("users")
                            .put(id, user)
                            .thenReturn(user)
                    )
            );
    }
}
```

### 3. Мониторинг и отладка:
```java
public Mono<User> findById(Long id) {
    return Mono.deferContextual(context -> {
            logger.info("Cache context: {}", context);
            return userRepository.findById(id);
        })
        .cache(Duration.ofMinutes(30))
        .tag("operation", "findUser")
        .name("userRepository.findById");
}
```

## Вывод

**Главные ограничения в WebFlux:**

1. **`@Transactional`**:
    - Не работает с ThreadLocal-based транзакциями
    - Требует ReactiveTransactionManager (R2DBC)
    - Ограниченная поддержка в Spring Data

2. **`@Cacheable`**:
    - Кэширует Publisher'ы, а не результаты
    - SpEL не может работать с содержимым Mono/Flux
    - Условное кэширование практически невозможно
    - Требует реактивных CacheManager'ов

**Рекомендация:** В реактивном стеке часто лучше использовать явные подходы (`.cache()`, `transactionalOperator`) вместо магических аннотаций, чтобы сохранить контроль и предсказуемость.