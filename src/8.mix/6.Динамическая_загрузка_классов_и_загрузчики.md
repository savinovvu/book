# Динамическая загрузка классов и загрузчики в Java JVM

## 1. Иерархия загрузчиков классов

### Базовые загрузчики классов:

```java
public class ClassLoaderHierarchy {
    public static void main(String[] args) {
        // Bootstrap ClassLoader (нативный, не Java)
        System.out.println("Bootstrap ClassLoader: " + String.class.getClassLoader());
        
        // Extension ClassLoader
        System.out.println("Extension ClassLoader: " + 
            com.sun.nio.file.ExtendedWatchEventModifier.class.getClassLoader());
        
        // Application/System ClassLoader
        System.out.println("System ClassLoader: " + 
            ClassLoaderHierarchy.class.getClassLoader());
        
        // Иерархия
        ClassLoader loader = ClassLoaderHierarchy.class.getClassLoader();
        while (loader != null) {
            System.out.println("Loader: " + loader);
            loader = loader.getParent();
        }
    }
}
```

## 2. Делегирующая модель загрузки

```java
public class DelegationModel {
    public static void main(String[] args) {
        // При загрузке класса:
        // 1. Проверка кэша (уже загруженные классы)
        // 2. Делегирование родителю
        // 3. Поиск в своем classpath
    }
}
```

## 3. Создание кастомного загрузчика классов

```java
public class CustomClassLoader extends ClassLoader {
    private final String basePath;
    
    public CustomClassLoader(String basePath, ClassLoader parent) {
        super(parent);
        this.basePath = basePath;
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            // Преобразуем имя класса в путь к файлу
            String path = name.replace('.', '/') + ".class";
            String fullPath = basePath + "/" + path;
            
            // Читаем байт-код
            byte[] classBytes = loadClassData(fullPath);
            
            // Определяем класс
            return defineClass(name, classBytes, 0, classBytes.length);
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
    
    private byte[] loadClassData(String path) throws IOException {
        try (InputStream inputStream = new FileInputStream(path);
             ByteArrayOutputStream outputStream = new ByteArrayOutputStream()) {
            
            int data;
            while ((data = inputStream.read()) != -1) {
                outputStream.write(data);
            }
            return outputStream.toByteArray();
        }
    }
}
```

## 4. Динамическая загрузка классов

```java
public class DynamicClassLoading {
    
    public static void main(String[] args) throws Exception {
        // Способ 1: Class.forName() с инициализацией
        Class<?> class1 = Class.forName("com.example.MyClass");
        
        // Способ 2: Class.forName() без инициализации
        Class<?> class2 = Class.forName("com.example.MyClass", false, 
            Thread.currentThread().getContextClassLoader());
        
        // Способ 3: ClassLoader.loadClass()
        ClassLoader loader = Thread.currentThread().getContextClassLoader();
        Class<?> class3 = loader.loadClass("com.example.MyClass");
        
        // Создание экземпляра
        Object instance = class1.newInstance();
    }
}
```

## 5. Изоляция классов с кастомными загрузчиками

```java
public class ClassIsolationExample {
    
    public static void main(String[] args) throws Exception {
        String classPath = "/path/to/classes";
        
        // Создаем два разных загрузчика для изоляции
        CustomClassLoader loader1 = new CustomClassLoader(classPath, null);
        CustomClassLoader loader2 = new CustomClassLoader(classPath, null);
        
        // Загружаем один и тот же класс разными загрузчиками
        Class<?> class1 = loader1.loadClass("com.example.Singleton");
        Class<?> class2 = loader2.loadClass("com.example.Singleton");
        
        // Это разные классы для JVM!
        System.out.println("Same class: " + (class1 == class2)); // false
        System.out.println("Same classloader: " + 
            (class1.getClassLoader() == class2.getClassLoader())); // false
    }
}
```

## 6. Горячее переопределение классов (Hot Swapping)

```java
public class HotSwappingClassLoader extends ClassLoader {
    private final Map<String, Long> lastModified = new HashMap<>();
    private final String basePath;
    
    public HotSwappingClassLoader(String basePath) {
        this.basePath = basePath;
    }
    
    @Override
    public Class<?> loadClass(String name) throws ClassNotFoundException {
        // Для системных классов делегируем родителю
        if (name.startsWith("java.") || name.startsWith("javax.")) {
            return super.loadClass(name);
        }
        
        return findClass(name);
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            String path = name.replace('.', '/') + ".class";
            File classFile = new File(basePath, path);
            
            // Проверяем, изменился ли файл
            if (isClassModified(name, classFile)) {
                System.out.println("Reloading class: " + name);
                byte[] classBytes = loadClassData(classFile);
                lastModified.put(name, classFile.lastModified());
                return defineClass(name, classBytes, 0, classBytes.length);
            }
            
            // Если класс уже загружен и не изменился
            Class<?> existingClass = findLoadedClass(name);
            if (existingClass != null) {
                return existingClass;
            }
            
            // Первоначальная загрузка
            byte[] classBytes = loadClassData(classFile);
            lastModified.put(name, classFile.lastModified());
            return defineClass(name, classBytes, 0, classBytes.length);
            
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
    
    private boolean isClassModified(String className, File classFile) {
        Long lastMod = lastModified.get(className);
        return lastMod == null || lastMod != classFile.lastModified();
    }
    
    private byte[] loadClassData(File classFile) throws IOException {
        try (FileInputStream fis = new FileInputStream(classFile);
             ByteArrayOutputStream bos = new ByteArrayOutputStream()) {
            
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = fis.read(buffer)) != -1) {
                bos.write(buffer, 0, bytesRead);
            }
            return bos.toByteArray();
        }
    }
}
```

## 7. Управление зависимостями с загрузчиками

```java
public class ModularClassLoader extends ClassLoader {
    private final Map<String, ClassLoader> moduleLoaders = new HashMap<>();
    private final Map<String, String> classToModule = new HashMap<>();
    
    public void addModule(String moduleName, String classPath, 
                         List<String> exportedPackages) {
        URLClassLoader moduleLoader = new URLClassLoader(
            new URL[]{new File(classPath).toURI().toURL()},
            getParent() // или null для изоляции
        );
        
        moduleLoaders.put(moduleName, moduleLoader);
        
        // Регистрируем классы модуля
        for (String pkg : exportedPackages) {
            classToModule.put(pkg, moduleName);
        }
    }
    
    @Override
    protected Class<?> loadClass(String name, boolean resolve) 
        throws ClassNotFoundException {
        
        // Находим модуль для класса
        String moduleName = findModuleForClass(name);
        
        if (moduleName != null) {
            ClassLoader moduleLoader = moduleLoaders.get(moduleName);
            return moduleLoader.loadClass(name);
        }
        
        // Делегируем системным классам
        return super.loadClass(name, resolve);
    }
    
    private String findModuleForClass(String className) {
        for (Map.Entry<String, String> entry : classToModule.entrySet()) {
            if (className.startsWith(entry.getKey())) {
                return entry.getValue();
            }
        }
        return null;
    }
}
```

## 8. Best Practices и антипаттерны

### Правильно:
```java
public class CorrectClassLoading {
    
    // Используем Context ClassLoader для сервисных классов
    public static <T> List<T> loadServices(Class<T> serviceClass) {
        List<T> services = new ArrayList<>();
        ServiceLoader<T> loader = ServiceLoader.load(serviceClass,
            Thread.currentThread().getContextClassLoader());
        
        for (T service : loader) {
            services.add(service);
        }
        return services;
    }
    
    // Правильное закрытие загрузчиков (в Java 9+)
    public static void closeClassLoader(ClassLoader loader) {
        if (loader instanceof Closeable) {
            try {
                ((Closeable) loader).close();
            } catch (IOException e) {
                // Логируем ошибку
            }
        }
    }
}
```

### Неправильно:
```java
public class IncorrectClassLoading {
    
    // ❌ Не игнорируйте родительский делегацию без причины
    class BadClassLoader extends ClassLoader {
        @Override
        public Class<?> loadClass(String name) throws ClassNotFoundException {
            // Всегда пытается загрузить сам - нарушает делегацию
            return findClass(name);
        }
    }
    
    // ❌ Утечка памяти через статические ссылки
    class MemoryLeakingLoader extends URLClassLoader {
        private static final List<Object> STATIC_REFERENCES = new ArrayList<>();
        
        @Override
        protected Class<?> findClass(String name) throws ClassNotFoundException {
            Class<?> clazz = super.findClass(name);
            STATIC_REFERENCES.add(clazz); // Утечка!
            return clazz;
        }
    }
}
```

## 9. Отладка и мониторинг

```java
public class ClassLoadingMonitor {
    
    public static void monitorClassLoading() {
        // JMX мониторинг загрузки классов
        try {
            MBeanServer mbs = ManagementFactory.getPlatformMBeanServer();
            ObjectName name = new ObjectName("java.lang:type=ClassLoading");
            
            ClassLoadingMXBean classLoadingMXBean = 
                ManagementFactory.newPlatformMXBeanProxy(
                    mbs, "java.lang:type=ClassLoading", ClassLoadingMXBean.class);
            
            System.out.println("Loaded classes: " + 
                classLoadingMXBean.getLoadedClassCount());
            System.out.println("Total loaded: " + 
                classLoadingMXBean.getTotalLoadedClassCount());
            System.out.println("Unloaded: " + 
                classLoadingMXBean.getUnloadedClassCount());
            
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    
    // Логирование загрузки классов
    static class LoggingClassLoader extends ClassLoader {
        @Override
        protected Class<?> loadClass(String name, boolean resolve) 
            throws ClassNotFoundException {
            
            System.out.println("Loading class: " + name + 
                " with loader: " + this);
            return super.loadClass(name, resolve);
        }
    }
}
```

## 10. Безопасность загрузчиков классов

```java
public class SecureClassLoaderExample extends SecureClassLoader {
    private final CodeSource codeSource;
    
    public SecureClassLoaderExample(URL codebase, ClassLoader parent) {
        super(parent);
        this.codeSource = new CodeSource(codebase, (Certificate[]) null);
    }
    
    @Override
    protected Class<?> findClass(String name) throws ClassNotFoundException {
        try {
            byte[] classBytes = loadClassBytes(name);
            
            // Проверяем цифровую подпись
            if (!verifySignature(classBytes)) {
                throw new SecurityException("Class signature verification failed: " + name);
            }
            
            // Определяем класс с ProtectionDomain
            ProtectionDomain protectionDomain = new ProtectionDomain(
                codeSource, null, this, null);
                
            return defineClass(name, classBytes, 0, classBytes.length, protectionDomain);
            
        } catch (IOException e) {
            throw new ClassNotFoundException("Class not found: " + name, e);
        }
    }
    
    private boolean verifySignature(byte[] classBytes) {
        // Реализация проверки цифровой подписи
        return true; // Заглушка
    }
    
    private byte[] loadClassBytes(String name) throws IOException {
        // Загрузка байт-кода
        return new byte[0]; // Заглушка
    }
}
```

## Ключевые моменты для Senior разработчика:

1. **Понимание делегации** - фундамент работы загрузчиков
2. **Изоляция классов** - основа модульных систем
3. **Управление памятью** - предотвращение утечек через загрузчики
4. **Безопасность** - контроль над загружаемым кодом
5. **Мониторинг** - отслеживание загрузки в production
6. **Горячая замена** - механизмы перезагрузки без restart JVM

Эти знания критически важны для разработки сложных систем, application servers, модульных архитектур и систем с динамической загрузкой кода.