# Паттерны объектно-ориентированного программирования

## Введение

Паттерны проектирования — это типовые решения часто встречающихся проблем в проектировании программного обеспечения. Они представляют собой лучшие практики, которые помогают создавать гибкий, поддерживаемый и масштабируемый код.

## Классификация паттернов

### 1. Порождающие паттерны (Creational Patterns)

#### 1.1 Singleton (Одиночка)
```java
public class Singleton {
    private static Singleton instance;
    
    private Singleton() {
        // приватный конструктор
    }
    
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // Потокобезопасная версия
    public static synchronized Singleton getThreadSafeInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
    
    // Double-Checked Locking
    public static Singleton getDoubleCheckedInstance() {
        if (instance == null) {
            synchronized (Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

#### 1.2 Factory Method (Фабричный метод)
```java
// Продукт
interface Product {
    void operation();
}

// Конкретные продукты
class ConcreteProductA implements Product {
    public void operation() {
        System.out.println("Product A operation");
    }
}

class ConcreteProductB implements Product {
    public void operation() {
        System.out.println("Product B operation");
    }
}

// Создатель
abstract class Creator {
    public abstract Product factoryMethod();
    
    public void someOperation() {
        Product product = factoryMethod();
        product.operation();
    }
}

// Конкретные создатели
class ConcreteCreatorA extends Creator {
    public Product factoryMethod() {
        return new ConcreteProductA();
    }
}

class ConcreteCreatorB extends Creator {
    public Product factoryMethod() {
        return new ConcreteProductB();
    }
}
```

#### 1.3 Abstract Factory (Абстрактная фабрика)
```java
// Абстрактные продукты
interface Button {
    void render();
}

interface Checkbox {
    void render();
}

// Конкретные продукты
class WindowsButton implements Button {
    public void render() {
        System.out.println("Render Windows button");
    }
}

class MacOSButton implements Button {
    public void render() {
        System.out.println("Render macOS button");
    }
}

// Абстрактная фабрика
interface GUIFactory {
    Button createButton();
    Checkbox createCheckbox();
}

// Конкретные фабрики
class WindowsFactory implements GUIFactory {
    public Button createButton() {
        return new WindowsButton();
    }
    
    public Checkbox createCheckbox() {
        return new WindowsCheckbox();
    }
}

class MacOSFactory implements GUIFactory {
    public Button createButton() {
        return new MacOSButton();
    }
    
    public Checkbox createCheckbox() {
        return new MacOSCheckbox();
    }
}
```

#### 1.4 Builder (Строитель)
```java
class Product {
    private String part1;
    private String part2;
    private String part3;
    
    // Приватный конструктор
    private Product(Builder builder) {
        this.part1 = builder.part1;
        this.part2 = builder.part2;
        this.part3 = builder.part3;
    }
    
    public static class Builder {
        private String part1;
        private String part2;
        private String part3;
        
        public Builder setPart1(String part1) {
            this.part1 = part1;
            return this;
        }
        
        public Builder setPart2(String part2) {
            this.part2 = part2;
            return this;
        }
        
        public Builder setPart3(String part3) {
            this.part3 = part3;
            return this;
        }
        
        public Product build() {
            return new Product(this);
        }
    }
}

// Использование
Product product = new Product.Builder()
    .setPart1("value1")
    .setPart2("value2")
    .setPart3("value3")
    .build();
```

#### 1.5 Prototype (Прототип)
```java
interface Prototype extends Cloneable {
    Prototype clone();
}

class ConcretePrototype implements Prototype {
    private String field;
    
    public ConcretePrototype(String field) {
        this.field = field;
    }
    
    public Prototype clone() {
        return new ConcretePrototype(this.field);
    }
    
    public String getField() {
        return field;
    }
    
    public void setField(String field) {
        this.field = field;
    }
}
```

### 2. Структурные паттерны (Structural Patterns)

#### 2.1 Adapter (Адаптер)
```java
// Целевой интерфейс
interface Target {
    void request();
}

// Адаптируемый класс
class Adaptee {
    public void specificRequest() {
        System.out.println("Specific request");
    }
}

// Адаптер
class Adapter implements Target {
    private Adaptee adaptee;
    
    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }
    
    public void request() {
        adaptee.specificRequest();
    }
}
```

#### 2.2 Decorator (Декоратор)
```java
// Базовый компонент
interface Component {
    void operation();
}

// Конкретный компонент
class ConcreteComponent implements Component {
    public void operation() {
        System.out.println("ConcreteComponent operation");
    }
}

// Базовый декоратор
abstract class Decorator implements Component {
    protected Component component;
    
    public Decorator(Component component) {
        this.component = component;
    }
    
    public void operation() {
        component.operation();
    }
}

// Конкретный декоратор
class ConcreteDecorator extends Decorator {
    public ConcreteDecorator(Component component) {
        super(component);
    }
    
    public void operation() {
        super.operation();
        addedBehavior();
    }
    
    private void addedBehavior() {
        System.out.println("Added behavior");
    }
}
```

#### 2.3 Facade (Фасад)
```java
// Сложные подсистемы
class SubsystemA {
    public void operationA() {
        System.out.println("Subsystem A operation");
    }
}

class SubsystemB {
    public void operationB() {
        System.out.println("Subsystem B operation");
    }
}

class SubsystemC {
    public void operationC() {
        System.out.println("Subsystem C operation");
    }
}

// Фасад
class Facade {
    private SubsystemA subsystemA;
    private SubsystemB subsystemB;
    private SubsystemC subsystemC;
    
    public Facade() {
        this.subsystemA = new SubsystemA();
        this.subsystemB = new SubsystemB();
        this.subsystemC = new SubsystemC();
    }
    
    public void simpleOperation() {
        subsystemA.operationA();
        subsystemB.operationB();
        subsystemC.operationC();
    }
}
```

#### 2.4 Composite (Компоновщик)
```java
import java.util.ArrayList;
import java.util.List;

// Компонент
interface Component {
    void operation();
    void add(Component component);
    void remove(Component component);
    Component getChild(int index);
}

// Лист
class Leaf implements Component {
    private String name;
    
    public Leaf(String name) {
        this.name = name;
    }
    
    public void operation() {
        System.out.println("Leaf " + name + " operation");
    }
    
    public void add(Component component) {
        throw new UnsupportedOperationException();
    }
    
    public void remove(Component component) {
        throw new UnsupportedOperationException();
    }
    
    public Component getChild(int index) {
        throw new UnsupportedOperationException();
    }
}

// Композит
class Composite implements Component {
    private List<Component> children = new ArrayList<>();
    
    public void operation() {
        for (Component child : children) {
            child.operation();
        }
    }
    
    public void add(Component component) {
        children.add(component);
    }
    
    public void remove(Component component) {
        children.remove(component);
    }
    
    public Component getChild(int index) {
        return children.get(index);
    }
}
```

#### 2.5 Proxy (Заместитель)
```java
// Субъект
interface Subject {
    void request();
}

// Реальный субъект
class RealSubject implements Subject {
    public void request() {
        System.out.println("RealSubject request");
    }
}

// Заместитель
class Proxy implements Subject {
    private RealSubject realSubject;
    
    public void request() {
        if (realSubject == null) {
            realSubject = new RealSubject();
        }
        preRequest();
        realSubject.request();
        postRequest();
    }
    
    private void preRequest() {
        System.out.println("Pre-request processing");
    }
    
    private void postRequest() {
        System.out.println("Post-request processing");
    }
}
```

### 3. Поведенческие паттерны (Behavioral Patterns)

#### 3.1 Observer (Наблюдатель)
```java
import java.util.ArrayList;
import java.util.List;

// Субъект
interface Subject {
    void attach(Observer observer);
    void detach(Observer observer);
    void notifyObservers();
}

// Наблюдатель
interface Observer {
    void update(String state);
}

// Конкретный субъект
class ConcreteSubject implements Subject {
    private List<Observer> observers = new ArrayList<>();
    private String state;
    
    public void setState(String state) {
        this.state = state;
        notifyObservers();
    }
    
    public void attach(Observer observer) {
        observers.add(observer);
    }
    
    public void detach(Observer observer) {
        observers.remove(observer);
    }
    
    public void notifyObservers() {
        for (Observer observer : observers) {
            observer.update(state);
        }
    }
}

// Конкретный наблюдатель
class ConcreteObserver implements Observer {
    private String name;
    
    public ConcreteObserver(String name) {
        this.name = name;
    }
    
    public void update(String state) {
        System.out.println(name + " received update: " + state);
    }
}
```

#### 3.2 Strategy (Стратегия)
```java
// Стратегия
interface Strategy {
    int execute(int a, int b);
}

// Конкретные стратегии
class ConcreteStrategyAdd implements Strategy {
    public int execute(int a, int b) {
        return a + b;
    }
}

class ConcreteStrategySubtract implements Strategy {
    public int execute(int a, int b) {
        return a - b;
    }
}

class ConcreteStrategyMultiply implements Strategy {
    public int execute(int a, int b) {
        return a * b;
    }
}

// Контекст
class Context {
    private Strategy strategy;
    
    public void setStrategy(Strategy strategy) {
        this.strategy = strategy;
    }
    
    public int executeStrategy(int a, int b) {
        return strategy.execute(a, b);
    }
}
```

#### 3.3 Command (Команда)
```java
// Команда
interface Command {
    void execute();
    void undo();
}

// Получатель
class Receiver {
    public void action() {
        System.out.println("Receiver action");
    }
    
    public void undoAction() {
        System.out.println("Receiver undo action");
    }
}

// Конкретная команда
class ConcreteCommand implements Command {
    private Receiver receiver;
    
    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }
    
    public void execute() {
        receiver.action();
    }
    
    public void undo() {
        receiver.undoAction();
    }
}

// Инициатор
class Invoker {
    private Command command;
    
    public void setCommand(Command command) {
        this.command = command;
    }
    
    public void executeCommand() {
        command.execute();
    }
    
    public void undoCommand() {
        command.undo();
    }
}
```

#### 3.4 Template Method (Шаблонный метод)
```java
abstract class AbstractClass {
    // Шаблонный метод
    public final void templateMethod() {
        primitiveOperation1();
        primitiveOperation2();
        concreteOperation();
        hook();
    }
    
    // Абстрактные операции
    protected abstract void primitiveOperation1();
    protected abstract void primitiveOperation2();
    
    // Конкретная операция
    protected void concreteOperation() {
        System.out.println("Concrete operation");
    }
    
    // Хук (может быть переопределен)
    protected void hook() {}
}

class ConcreteClass extends AbstractClass {
    protected void primitiveOperation1() {
        System.out.println("Concrete operation 1");
    }
    
    protected void primitiveOperation2() {
        System.out.println("Concrete operation 2");
    }
    
    protected void hook() {
        System.out.println("Hook implementation");
    }
}
```

#### 3.5 Iterator (Итератор)
```java
interface Iterator<T> {
    boolean hasNext();
    T next();
}

interface Aggregate<T> {
    Iterator<T> createIterator();
}

class ConcreteIterator<T> implements Iterator<T> {
    private T[] elements;
    private int position = 0;
    
    public ConcreteIterator(T[] elements) {
        this.elements = elements;
    }
    
    public boolean hasNext() {
        return position < elements.length;
    }
    
    public T next() {
        return elements[position++];
    }
}

class ConcreteAggregate<T> implements Aggregate<T> {
    private T[] elements;
    
    public ConcreteAggregate(T[] elements) {
        this.elements = elements;
    }
    
    public Iterator<T> createIterator() {
        return new ConcreteIterator<>(elements);
    }
}
```

## Принципы проектирования

### SOLID принципы

1. **S** - Single Responsibility Principle (Принцип единственной ответственности)
2. **O** - Open/Closed Principle (Принцип открытости/закрытости)
3. **L** - Liskov Substitution Principle (Принцип подстановки Барбары Лисков)
4. **I** - Interface Segregation Principle (Принцип разделения интерфейсов)
5. **D** - Dependency Inversion Principle (Принцип инверсии зависимостей)

### Другие важные принципы

- **DRY** (Don't Repeat Yourself) - Не повторяйся
- **KISS** (Keep It Simple, Stupid) - Делай проще
- **YAGNI** (You Ain't Gonna Need It) - Вам это не понадобится

## Практические рекомендации для Senior Java Developer

### Когда использовать паттерны:

1. **Singleton** - для управления общими ресурсами (логгеры, конфигурации)
2. **Factory** - когда создание объекта сложное или требует дополнительной логики
3. **Builder** - для создания объектов со многими необязательными параметрами
4. **Observer** - для реализации событийной модели
5. **Strategy** - когда нужно выбирать алгоритм во время выполнения
6. **Decorator** - для динамического добавления функциональности

### Антипаттерны:

1. **God Object** - объект, который делает слишком много
2. **Spaghetti Code** - код без структуры
3. **Golden Hammer** - использование одного решения для всех проблем
4. **Premature Optimization** - преждевременная оптимизация

## Заключение

Паттерны проектирования — это мощный инструмент в арсенале Senior Java Developer. Однако важно помнить, что они должны применяться осмысленно, а не ради самих паттернов. Правильное использование паттернов помогает создавать чистый, поддерживаемый и масштабируемый код.