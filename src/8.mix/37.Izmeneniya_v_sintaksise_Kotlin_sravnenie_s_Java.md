Вот разбор ключевых изменений в синтаксисе Kotlin по сравнению с Java с точки зрения senior backend-разработчика:

---

### **1. Null Safety & Типы**
**Java:**
```java
String str = null; // Все ссылочные типы nullable по умолчанию
```
**Kotlin:**
```kotlin
var str: String? = null // Явное указание nullable-типа через "?"
val length = str?.length // Safe-call оператор
val nonNullStr: String = requireNotNull(str) // Компилятор проверяет nullability
```
**Преимущества:**
- Компилятор отслеживает возможные NPE, что сокращает количество runtime-ошибок.
- Элвис-оператор `?:` для значений по умолчанию: `val len = str?.length ?: 0`

---

### **2. Функции как граждане первого класса**
**Java** (до 8):
```java
interface Function {
    int apply(int a, int b);
}
Function add = (a, b) -> a + b;
```
**Kotlin:**
```kotlin
val sum: (Int, Int) -> Int = { a, b -> a + b }
// Или с type inference:
val sum = { a: Int, b: Int -> a + b }
```
**Особенности:**
- Лямбды, higher-order functions, extension-функции:
  ```kotlin
  fun String.addExclamation() = this + "!"
  "Hello".addExclamation() // "Hello!"
  ```

---

### **3. Data-классы**
**Java:**
```java
public class User {
    private String name;
    // Геттеры, сеттеры, equals, hashCode, toString...
}
```
**Kotlin:**
```kotlin
data class User(val name: String, val age: Int)
```
**Автоматически генерируются:**
- `equals()`/`hashCode()`
- `toString()` (`User(name=John, age=30)`)
- `copy()`, `componentN()`-функции (для деструктуризации)

---

### **4. Иммутабельность & Коллекции**
**Kotlin:**
```kotlin
val list = listOf("a", "b") // Read-only коллекция
val mutableList = mutableListOf("a") // Изменяемая версия
```
**Отличия:**
- Четкое разделение mutable/immutable коллекций
- `listOf()`, `setOf()`, `mapOf()` vs `mutableListOf()`

---

### **5. Корутины вместо потоков**
**Java** (Threads):
```java
new Thread(() -> System.out.println("Running")).start();
```
**Kotlin:**
```kotlin
GlobalScope.launch {
    delay(1000) // Неблокирующая задержка
    println("World")
}
```
**Плюсы:**
- Легковесные (тысячи корутин на один поток)
- Структурированный параллелизм с `CoroutineScope`
- `async`/`await` для конкурентности:
  ```kotlin
  val result = async { fetchData() }.await()
  ```

---

### **6. Pattern Matching & When**
**Java:**
```java
switch (status) {
    case 200: break;
    case 404: break;
    default: break;
}
```
**Kotlin:**
```kotlin
when (response.status) {
    200 -> println("OK")
    404 -> println("Not Found")
    in 500..599 -> println("Server error") // Диапазоны
    is HttpError -> println("Error type") // Проверка типа
}
```
**Дополнительно:**
- `when` может возвращать значение:
  ```kotlin
  val message = when (status) { ... }
  ```

---

### **7. Отсутствие checked exceptions**
**Java:**
```java
public void readFile() throws IOException { ... }
```
**Kotlin:**
```kotlin
fun readFile() { // Не нужно объявлять исключения
    // ...
}
```
**Философия:**
- Checked exceptions часто игнорируются или оборачиваются в RuntimeException
- Акцент на обработке ошибок через Result-типы и монады

---

### **8. Extension-функции**
**Kotlin:**
```kotlin
fun String.isPalindrome(): Boolean {
    return this == this.reversed()
}
"radar".isPalindrome() // true
```
**Аналог в Java** (статический метод):
```java
StringUtils.isPalindrome("radar");
```

---

### **9. Делегирование**
**Kotlin:**
```kotlin
class Repository(val api: Api) : Api by api // Делегирование интерфейса
class ViewModel : BaseViewModel by lazy { ... } // Lazy-делегат
```

---

### **10. Строки & Шаблоны**
**Kotlin:**
```kotlin
val name = "John"
println("Hello, $name!") // Интерполяция
val sql = """
    SELECT * FROM users
    WHERE name = ?
""".trimIndent() // Многострочные строки
```

---

### **Бэкенд-специфика**
1. **Spring Boot + Kotlin:**
    - Корутины для асинхронных контроллеров
    - Null-safe обработка DTO

2. **Ktor:**
    - Полностью написан на Kotlin
    - DSL для маршрутизации:
   ```kotlin
   routing {
       get("/user/{id}") {
           call.respondText { "User" }
       }
   }
   ```

3. **Экосистема:**
    - **Exposed** — typesafe SQL
    - **Kotlinx.serialization** — сериализация без рефлексии

---

### **Миграция с Java**
1. **Интероп:**
    - Kotlin и Java могут сосуществовать в одном проекте
    - Аннотации `@JvmStatic`, `@JvmOverloads` для совместимости

2. **Постепенное внедрение:**
    - Начинать с утилитарных классов/extension-функций
    - Data-классы для DTO
    - Корутины для асинхронных сервисов

---

**Итог:** Kotlin предлагает лаконичный, безопасный и выразительный синтаксис с уникальными возможностями для бэкенд-разработки, сохраняя полную совместимость с Java-экосистемой.