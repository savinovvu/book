# Distributed Tracing в Микросервисной Архитектуре

## 1. Введение в Distributed Tracing

### Что такое Distributed Tracing?
**Distributed Tracing** (распределенная трассировка) — это метод мониторинга и диагностики, который позволяет отслеживать запросы по мере их прохождения через распределенную систему, такую как микросервисная архитектура.

### Почему это важно?
В монолитной системе один запрос обрабатывается в одном процессе. В микросервисной архитектуре один запрос может пройти через:
- 5-10+ различных сервисов
- Несколько баз данных
- Кэширующие слои
- Очереди сообщений
- Внешние API

Без трассировки невозможно понять:
- Где произошла ошибка
- В каком сервисе возникла задержка
- Каков полный путь запроса

## 2. Проблемы Распределенных Систем Без Трассировки

### "Слепые зоны" в микросервисах:
1. **Невидимые зависимости** между сервисами
2. **Невозможность определить корневую причину** ошибок
3. **Трудности в измерении производительности** отдельных компонентов
4. **Сложность отладки** межсервисного взаимодействия

### Пример проблемы:
```
Пользовательский запрос → API Gateway → Auth Service → Order Service → 
→ Payment Service → Inventory Service → Notification Service
```

При ошибке: "Как определить, в каком сервисе проблема?"

## 3. Основные Концепции Distributed Tracing

### Trace (Трассировка)
- **Полный путь** запроса через систему
- Уникальный `traceId` идентифицирует всю трассировку
- Содержит временную шкалу всего запроса

### Span (Спан)
- **Отдельная операция** в рамках трассировки
- Примеры: HTTP запрос, запрос к БД, вызов другого сервиса
- Содержит:
    - `spanId`: уникальный идентификатор спана
    - `parentSpanId`: ссылка на родительский спан
    - Название операции
    - Временные метки (начало, конец)
    - Теги и логи

### Context (Контекст)
- Переносит идентификаторы трассировки между сервисами
- Обычно через HTTP headers или сообщения брокера

## 4. Инструменты и Стандарты

### OpenTelemetry (OTel)
**Стандарт де-факто** для сбора телеметрии:
- Агностичен к конкретным бэкендам
- Поддерживает трассировку, метрики, логи
- Активно развиваемое сообщество

#### Ключевые компоненты OTel:
```java
// API для ручного инструментирования
Tracer tracer = openTelemetry.getTracer("service-name");

// Автоматическое инструментирование
// (HTTP клиенты/серверы, базы данных, очереди и т.д.)
```

### Бэкенды для визуализации:

#### Jaeger
- Разработан Uber
- Поддержка больших объемов данных
- Мощный UI для анализа

#### Zipkin
- Один из первых инструментов
- Простая установка
- Широкая экосистема

#### Elastic APM / New Relic / Datadog
- Коммерческие решения
- Полный стек мониторинга

## 5. Практическая Реализация на Java + Spring Boot

### Настройка зависимостей Maven/Gradle

```xml
<!-- OpenTelemetry -->
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-api</artifactId>
    <version>1.28.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-sdk</artifactId>
    <version>1.28.0</version>
</dependency>
<dependency>
    <groupId>io.opentelemetry</groupId>
    <artifactId>opentelemetry-exporter-jaeger</artifactId>
    <version>1.28.0</version>
</dependency>

<!-- Spring Cloud Sleuth (упрощает интеграцию) -->
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-starter-sleuth</artifactId>
    <version>3.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.cloud</groupId>
    <artifactId>spring-cloud-sleuth-otel-autoconfigure</artifactId>
    <version>3.1.0</version>
</dependency>
```

### Конфигурация OpenTelemetry

```java
@Configuration
public class TracingConfig {
    
    @Bean
    public OpenTelemetry openTelemetry() {
        return OpenTelemetrySdk.builder()
            .setTracerProvider(
                SdkTracerProvider.builder()
                    .addSpanProcessor(
                        BatchSpanProcessor.builder(
                            JaegerGrpcSpanExporter.builder()
                                .setEndpoint("http://jaeger:14250")
                                .build()
                        ).build()
                    )
                    .build()
            )
            .setPropagators(
                ContextPropagators.create(
                    W3CTraceContextPropagator.getInstance()
                )
            )
            .build();
    }
}
```

### Пример сервиса с трассировкой

```java
@RestController
@Slf4j
public class OrderController {
    
    private final Tracer tracer;
    private final RestTemplate restTemplate;
    
    public OrderController(OpenTelemetry openTelemetry, RestTemplate restTemplate) {
        this.tracer = openTelemetry.getTracer(OrderController.class.getName());
        this.restTemplate = restTemplate;
    }
    
    @PostMapping("/orders")
    public ResponseEntity<Order> createOrder(@RequestBody OrderRequest request) {
        // Создание корневого спана
        Span span = tracer.spanBuilder("createOrder")
            .setAttribute("user.id", request.getUserId())
            .setAttribute("order.amount", request.getAmount())
            .startSpan();
        
        try (Scope scope = span.makeCurrent()) {
            log.info("Creating order for user: {}", request.getUserId());
            
            // Валидация заказа
            validateOrder(request);
            
            // Проверка инвентаря
            checkInventory(request);
            
            // Создание платежа
            processPayment(request);
            
            Order order = orderService.createOrder(request);
            
            span.setStatus(StatusCode.OK);
            return ResponseEntity.ok(order);
            
        } catch (Exception e) {
            span.recordException(e);
            span.setStatus(StatusCode.ERROR);
            throw e;
        } finally {
            span.end();
        }
    }
    
    private void checkInventory(OrderRequest request) {
        // Создание дочернего спана
        Span inventorySpan = tracer.spanBuilder("checkInventory")
            .setParent(Context.current().with(Span.current()))
            .startSpan();
            
        try (Scope scope = inventorySpan.makeCurrent()) {
            // HTTP вызов к Inventory Service с передачей контекста
            HttpHeaders headers = new HttpHeaders();
            
            // Автоматическая инъекция headers трассировки
            restTemplate.exchange(
                "http://inventory-service/check", 
                HttpMethod.POST,
                new HttpEntity<>(request, headers),
                Void.class
            );
        } finally {
            inventorySpan.end();
        }
    }
}
```

### Конфигурация Spring Cloud Sleuth

```yaml
# application.yml
spring:
  application:
    name: order-service
  sleuth:
    otel:
      config:
        trace-id-ratio-based: 1.0 # 100% семплирование для разработки
    sampler:
      probability: 1.0
  zipkin:
    base-url: http://zipkin:9411

logging:
  pattern:
    level: "%5p [${spring.application.name:},%X{traceId:-},%X{spanId:-}]"
```

## 6. Интеграция с Логгированием

### Корреляция логов и трассировок

```java
@Slf4j
@Aspect
@Component
public class TracingAspect {
    
    @Around("@annotation(org.springframework.web.bind.annotation.GetMapping) || " +
            "@annotation(org.springframework.web.bind.annotation.PostMapping)")
    public Object traceControllerMethods(ProceedingJoinPoint joinPoint) throws Throwable {
        String methodName = joinPoint.getSignature().getName();
        
        // ID трассировки автоматически добавляются в MDC
        log.info("Starting controller method: {}", methodName);
        
        try {
            Object result = joinPoint.proceed();
            log.info("Completed controller method: {}", methodName);
            return result;
        } catch (Exception e) {
            log.error("Error in controller method: {}", methodName, e);
            throw e;
        }
    }
}
```

### Настройка Logback для включения Trace ID

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="JSON" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp/>
                <logLevel/>
                <loggerName/>
                <message/>
                <mdc>
                    <includeMdcKeyName>traceId</includeMdcKeyName>
                    <includeMdcKeyName>spanId</includeMdcKeyName>
                </mdc>
                <stackTrace/>
            </providers>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="JSON" />
    </root>
</configuration>
```

## 7. Семплирование (Sampling)

### Зачем нужно семплирование?
- Снижение нагрузки на систему
- Уменьшение стоимости хранения
- Баланс между observability и производительностью

### Стратегии семплирования:

```java
@Configuration
public class SamplingConfig {
    
    @Bean
    public Sampler alwaysOnSampler() {
        // Все трассы (для разработки)
        return Sampler.alwaysOn();
    }
    
    @Bean 
    public Sampler probabilitySampler() {
        // Процент трасс (для продакшена)
        return Sampler.traceIdRatioBased(0.1); // 10%
    }
    
    @Bean
    public Sampler adaptiveSampler() {
        // Адаптивное семплирование на основе нагрузки
        return RateLimitingSampler.builder(100).build(); // 100 трасс/сек
    }
}
```

### Конфигурация для разных окружений:

```yaml
# application-dev.yml
spring:
  sleuth:
    sampler:
      probability: 1.0

# application-prod.yml  
spring:
  sleuth:
    sampler:
      probability: 0.01
```

## 8. Best Practices для Senior Java Developers

### 1. Консистентное именование спанов
```java
// ПЛОХО
Span span = tracer.spanBuilder("doSomething").startSpan();

// ХОРОШО
Span span = tracer.spanBuilder("order.validation").startSpan();
Span span = tracer.spanBuilder("payment.process").startSpan();
```

### 2. Осмысленные теги и атрибуты
```java
span.setAttribute("http.method", "POST");
span.setAttribute("http.route", "/api/orders/{id}");
span.setAttribute("db.operation", "SELECT");
span.setAttribute("user.id", userId);
span.setAttribute("order.value", orderAmount);
```

### 3. Правильная обработка ошибок
```java
try {
    // бизнес-логика
} catch (BusinessException e) {
    span.recordException(e);
    span.setStatus(StatusCode.ERROR, e.getMessage());
    // Не забываем прокидывать исключение дальше
    throw e;
} finally {
    span.end(); // Всегда закрываем спан
}
```

### 4. Интеграция с асинхронными операциями
```java
@Async
public CompletableFuture<Order> processOrderAsync(Order order) {
    // Сохраняем контекст для асинхронной операции
    Context context = Context.current();
    
    return CompletableFuture.supplyAsync(() -> {
        try (Scope scope = context.makeCurrent()) {
            Span span = tracer.spanBuilder("async.order.process")
                .setParent(context)
                .startSpan();
                
            try {
                // обработка заказа
                return orderService.process(order);
            } finally {
                span.end();
            }
        }
    });
}
```

### 5. Трассировка сообщений Kafka/RabbitMQ
```java
@KafkaListener(topics = "orders")
public void listen(String message, @Header Map<String, String> headers) {
    // Извлечение контекста из headers сообщения
    Context context = extractContextFromHeaders(headers);
    
    try (Scope scope = context.makeCurrent()) {
        Span span = tracer.spanBuilder("kafka.orders.consume")
            .setParent(context)
            .startSpan();
            
        // обработка сообщения
        processOrderMessage(message);
        
        span.end();
    }
}
```

### 6. Мониторинг производительности трассировки
```java
@Component
public class TracingMetrics {
    
    private final Meter meter;
    private final Counter spanCounter;
    
    public TracingMetrics(MeterRegistry meterRegistry) {
        this.meter = meterRegistry;
        this.spanCounter = meter.counter("spans.created");
    }
    
    public void recordSpanCreation(String spanName) {
        spanCounter.increment(1, 
            Tags.of("span.name", spanName, "service", "order-service"));
    }
}
```

## 9. Продвинутые Сценарии

### Baggage (Дополнительные данные)
```java
// Добавление baggage (данные, передаваемые между сервисами)
Baggage baggage = Baggage.builder()
    .put("user.preferences", "premium")
    .put("request.source", "mobile-app")
    .build();

Context contextWithBaggage = baggage.storeInContext(Context.current());

// Извлечение в другом сервисе
String userPreferences = Baggage.fromContext(context).getEntryValue("user.preferences");
```

### Инструментирование базы данных
```java
@Bean
public DataSource dataSource() {
    return new DataSourceProxy(originalDataSource);
}

// Автоматическое создание спанов для SQL запросов
// через p6spy или аналогичные инструменты
```

## 10. Заключение

### Ключевые преимущества Distributed Tracing:
1. **Полная видимость** потоков запросов в микросервисах
2. **Быстрая диагностика** проблем производительности
3. **Улучшенное понимание** системных зависимостей
4. **Проактивный мониторинг** и алертинг

### Рекомендации для продакшена:
- Начинать с 1-5% семплирования, увеличивать при необходимости
- Использовать структурированное логгирование с Trace ID
- Интегрировать трассировку в CI/CD пайплайны
- Настроить алерты на основе метрик трассировки (p99 latency, error rate)

Distributed Tracing — это не просто инструмент отладки, а **стратегическая инвестиция** в наблюдаемость и надежность вашей микросервисной архитектуры.