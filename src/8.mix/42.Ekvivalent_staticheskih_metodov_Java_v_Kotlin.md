Объясню эквиваленты статических методов Java в Kotlin с точки зрения senior backend разработчика.

## Основные подходы в Kotlin

### 1. Companion Object (основной способ)
```kotlin
class UserService {
    companion object {
        private const val MAX_USERS = 1000
        
        fun createDefault(): UserService {
            return UserService()
        }
        
        @JvmStatic // Для совместимости с Java
        fun getMaxUsers(): Int = MAX_USERS
    }
}

// Использование
val service = UserService.createDefault()
val maxUsers = UserService.getMaxUsers()
```

### 2. Top-level функции (функции верхнего уровня)
```kotlin
// File: UserUtils.kt
package com.example.utils

const val DEFAULT_TIMEOUT = 5000

fun validateEmail(email: String): Boolean {
    return email.contains("@")
}

fun createUserHash(name: String): String {
    return "${name}_${System.currentTimeMillis()}"
}

// Использование
import com.example.utils.validateEmail
import com.example.utils.DEFAULT_TIMEOUT

val isValid = validateEmail("test@example.com")
```

### 3. Object Declaration (синглтон)
```kotlin
object DatabaseConfig {
    const val URL = "jdbc:postgresql://localhost:5432/mydb"
    const val USERNAME = "admin"
    
    fun getConnectionProperties(): Properties {
        return Properties().apply {
            setProperty("ssl", "true")
            setProperty("connectTimeout", "30000")
        }
    }
}

// Использование
val url = DatabaseConfig.URL
val props = DatabaseConfig.getConnectionProperties()
```

## Практические примеры для backend

### Конфигурация приложения
```kotlin
object AppConfig {
    const val API_VERSION = "v1"
    const val MAX_PAGE_SIZE = 100
    const val DEFAULT_PAGE_SIZE = 20
    
    fun getDatabaseUrl(): String {
        return System.getenv("DB_URL") ?: "jdbc:h2:mem:test"
    }
    
    fun isProduction(): Boolean {
        return System.getenv("ENV") == "production"
    }
}
```

### Утилиты для работы с JWT
```kotlin
class JwtUtils {
    companion object {
        private const val SECRET = "your-secret-key"
        private val algorithm = Algorithm.HMAC256(SECRET)
        
        fun generateToken(userId: String, roles: List<String>): String {
            return JWT.create()
                .withSubject(userId)
                .withClaim("roles", roles)
                .withExpiresAt(Date(System.currentTimeMillis() + 3600000))
                .sign(algorithm)
        }
        
        fun verifyToken(token: String): DecodedJWT {
            return JWT.require(algorithm).build().verify(token)
        }
    }
}
```

### Фабричные методы для моделей
```kotlin
data class User(
    val id: String,
    val email: String,
    val createdAt: Instant
) {
    companion object {
        fun create(email: String): User {
            return User(
                id = UUID.randomUUID().toString(),
                email = email,
                createdAt = Instant.now()
            )
        }
        
        fun fromDto(dto: UserDto): User {
            return User(
                id = dto.id ?: UUID.randomUUID().toString(),
                email = dto.email,
                createdAt = dto.createdAt ?: Instant.now()
            )
        }
    }
}
```

## Best Practices для backend разработки

### 1. Использование @JvmStatic для Java-совместимости
```kotlin
class StringUtils {
    companion object {
        @JvmStatic
        fun isBlank(value: String?): Boolean {
            return value.isNullOrBlank()
        }
        
        @JvmStatic
        fun generateId(): String = UUID.randomUUID().toString()
    }
}

// Можно вызывать из Java как:
// StringUtils.isBlank(text);
// StringUtils.generateId();
```

### 2. Группировка утилит в package-level functions
```kotlin
// File: src/main/kotlin/com/example/utils/DateTimeUtils.kt
package com.example.utils

import java.time.*
import java.time.format.DateTimeFormatter

fun Instant.toIsoString(): String {
    return DateTimeFormatter.ISO_INSTANT.format(this)
}

fun String.toInstant(): Instant {
    return Instant.parse(this)
}

fun getCurrentTimeUTC(): Instant {
    return Instant.now()
}
```

### 3. Extension functions + companion object
```kotlin
class Money private constructor(
    val amount: Long,
    val currency: String
) {
    companion object {
        fun of(amount: Long, currency: String): Money {
            require(amount >= 0) { "Amount cannot be negative" }
            require(currency.length == 3) { "Currency must be 3 letters" }
            return Money(amount, currency.uppercase())
        }
    }
}

// Extension function для companion object
fun Money.Companion.zero(currency: String): Money {
    return Money(0, currency)
}

// Использование
val money = Money.of(1000, "USD")
val zero = Money.zero("EUR")
```

## Когда что использовать

### Companion Object используйте когда:
- Функции тесно связаны с классом
- Нужны factory methods
- Требуется доступ к private конструкторам
- Важна совместимость с Java через @JvmStatic

### Top-level функции используйте когда:
- Функции утилитарные и не привязаны к конкретному классу
- Хотите избежать создания лишних классов
- Работаете с extension functions

### Object Declaration используйте когда:
- Нужен синглтон (конфигурация, кэш, подключения)
- Состояние должно быть общим для всего приложения

## Пример из реального backend проекта
```kotlin
object SecurityConstants {
    const val TOKEN_PREFIX = "Bearer "
    const val HEADER_STRING = "Authorization"
    const val EXPIRATION_TIME = 864000000L // 10 days
    
    fun getSigningKey(): String {
        return System.getenv("JWT_SECRET") ?: "fallback-secret"
    }
}

class PasswordEncoder {
    companion object {
        private const val BCRYPT_STRENGTH = 12
        
        @JvmStatic
        fun encode(rawPassword: String): String {
            return BCrypt.hashpw(rawPassword, BCrypt.gensalt(BCRYPT_STRENGTH))
        }
        
        @JvmStatic
        fun matches(rawPassword: String, encodedPassword: String): Boolean {
            return BCrypt.checkpw(rawPassword, encodedPassword)
        }
    }
}

// Top-level функции для валидации
fun isValidPassword(password: String): Boolean {
    return password.length >= 8 && 
           password.any { it.isDigit() } && 
           password.any { it.isLetter() }
}

fun generateApiKey(): String {
    return "api_" + UUID.randomUUID().toString().replace("-", "")
}
```

Эти подходы позволяют писать чистый, идиоматичный Kotlin код while maintaining full interoperability with Java ecosystems, что особенно важно в enterprise backend development.