SOLID — это аббревиатура пяти ключевых принципов объектно-ориентированного программирования и проектирования, которые помогают создавать гибкий, масштабируемый и поддерживаемый код. Вот разбор каждого принципа с примерами на Java для уровня **Senior Java Developer**.

---

### **1. SRP (Принцип единственной ответственности)**
**Каждый класс должен иметь одну и только одну причину для изменения.**  
Класс должен решать лишь одну задачу. Если у класса несколько ответственностей, изменения в одной из них могут негативно повлиять на другие.

**Пример нарушения:**
```java
class Employee {
    public void calculateSalary() { /* логика расчета зарплаты */ }
    public void generateReport() { /* генерация отчета */ }
    public void saveToDatabase() { /* сохранение в БД */ }
}
```
**Проблема:** Класс управляет зарплатой, отчетами и базой данных. Изменение в любом из этих аспектов потребует модификации `Employee`.

**Исправление:**
```java
class Employee {
    // данные сотрудника
}

class SalaryCalculator {
    public void calculateSalary(Employee e) { /* ... */ }
}

class ReportGenerator {
    public void generateReport(Employee e) { /* ... */ }
}

class EmployeeRepository {
    public void save(Employee e) { /* ... */ }
}
```

---

### **2. OCP (Принцип открытости/закрытости)**
**Классы должны быть открыты для расширения, но закрыты для модификации.**  
Поведение класса можно расширять через наследование, композицию или интерфейсы, не меняя существующий код.

**Пример нарушения:**
```java
class AreaCalculator {
    public double calculateArea(Object shape) {
        if (shape instanceof Circle) {
            return ((Circle) shape).radius * ((Circle) shape).radius * Math.PI;
        } else if (shape instanceof Square) {
            return ((Square) shape).side * ((Square) shape).side;
        }
        throw new IllegalArgumentException("Unknown shape");
    }
}
```
**Проблема:** Добавление новой фигуры требует изменения метода `calculateArea`.

**Исправление через интерфейс:**
```java
interface Shape {
    double area();
}

class Circle implements Shape {
    private double radius;
    @Override public double area() { return radius * radius * Math.PI; }
}

class Square implements Shape {
    private double side;
    @Override public double area() { return side * side; }
}

class AreaCalculator {
    public double calculateArea(Shape shape) {
        return shape.area();
    }
}
```

---

### **3. LSP (Принцип подстановки Барбары Лисков)**
**Объекты должны быть заменяемыми экземплярами их подтипов без изменения корректности программы.**  
Наследники не должны нарушать поведение базового класса.

**Пример нарушения:**
```java
class Rectangle {
    protected int width, height;
    public void setWidth(int w) { width = w; }
    public void setHeight(int h) { height = h; }
    public int getArea() { return width * height; }
}

class Square extends Rectangle {
    @Override
    public void setWidth(int w) {
        super.setWidth(w);
        super.setHeight(w); // Нарушает инвариант прямоугольника!
    }
}
```
**Проблема:** Квадрат меняет и ширину, и высоту одновременно, что противочит ожиданиям от прямоугольника.

**Решение:**
- Не наследовать `Square` от `Rectangle`, если их поведение различается.
- Использовать общий интерфейс `Shape` с методом `area()`.

---

### **4. ISP (Принцип разделения интерфейса)**
**Много специализированных интерфейсов лучше одного универсального.**  
Клиенты не должны зависеть от методов, которые они не используют.

**Пример нарушения:**
```java
interface Worker {
    void code();
    void manage();
    void test();
}

class Developer implements Worker {
    @Override public void code() { /* ... */ }
    @Override public void manage() { /* не используется */ }
    @Override public void test() { /* не используется */ }
}
```
**Проблема:** `Developer` вынужден реализовывать ненужные методы.

**Исправление:**
```java
interface Coder { void code(); }
interface Manager { void manage(); }
interface Tester { void test(); }

class Developer implements Coder {
    @Override public void code() { /* ... */ }
}

class TeamLead implements Coder, Manager {
    @Override public void code() { /* ... */ }
    @Override public void manage() { /* ... */ }
}
```

---

### **5. DIP (Принцип инверсии зависимостей)**
**Зависимости должны строиться на абстракциях, а не на деталях.**  
Модули верхнего уровня не должны зависеть от модулей нижнего уровня. Оба должны зависеть от абстракций.

**Пример нарушения:**
```java
class EmailService {
    public void sendEmail(String message) { /* ... */ }
}

class Notification {
    private EmailService emailService = new EmailService(); // Жесткая зависимость
    public void alert() { emailService.sendEmail("Alert"); }
}
```
**Проблема:** `Notification` тесно связан с `EmailService`. Замена канала уведомлений потребует изменений в коде.

**Исправление через внедрение зависимости:**
```java
interface NotificationService {
    void send(String message);
}

class EmailService implements NotificationService {
    @Override public void send(String message) { /* ... */ }
}

class SMSService implements NotificationService {
    @Override public void send(String message) { /* ... */ }
}

class Notification {
    private NotificationService service;
    public Notification(NotificationService service) { // Инъекция зависимости
        this.service = service;
    }
    public void alert() { service.send("Alert"); }
}
```

---

### **Итог для Senior-разработчика:**
- **SOLID** — это основа проектирования устойчивых систем.
- Используйте **SRP** для минимизации последствий изменений.
- **OCP** позволяет расширять функциональность без риска сломать существующее.
- **LSP** гарантирует корректность полиморфизма.
- **ISP** устраняет избыточные зависимости.
- **DIP** обеспечивает гибкость через инверсию управления (IoC) и DI-контейнеры (Spring, Guice).

Примеры выше демонстрируют, как превратить нарушающий SOLID код в чистый и сопровождаемый. На практике эти принципы часто сочетаются с паттернами (Фабрика, Стратегия, Декоратор) и практиками TDD/DDD.