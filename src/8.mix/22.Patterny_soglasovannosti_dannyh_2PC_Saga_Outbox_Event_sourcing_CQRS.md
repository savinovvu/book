Привет! С удовольствием расскажу о паттернах согласованности данных, которые ты перечислил. Это критически важные концепции для построения надежных распределенных систем на Java. Давай разберем каждый из них.

## 1. 2PC (Two-Phase Commit) - Двухфазный коммит

**Суть:** Координированное завершение распределенной транзакции через две фазы.

```java
// Упрощенная концептуальная реализация
public class TwoPhaseCommitCoordinator {
    public boolean executeTransaction(List<Participant> participants) {
        // Фаза 1: Подготовка
        List<Boolean> prepareResults = participants.stream()
            .map(Participant::prepare)
            .collect(Collectors.toList());
            
        if (prepareResults.contains(false)) {
            // Фаза 2: Откат
            participants.forEach(Participant::rollback);
            return false;
        }
        
        // Фаза 2: Коммит
        participants.forEach(Participant::commit);
        return true;
    }
}
```

**Проблемы:**
- Блокировки ресурсов на длительное время
- Координатор - единая точка отказа
- Низкая производительность в распределенных сценариях

## 2. Saga Pattern

**Суть:** Долгоживущая транзакция, разбитая на последовательность локальных транзакций с компенсирующими действиями.

```java
// Пример Saga с оркестрацией
@Service
public class OrderSaga {
    
    @Autowired
    private OrderService orderService;
    
    @Autowired
    private PaymentService paymentService;
    
    @Autowired
    private InventoryService inventoryService;
    
    @Transactional
    public void createOrder(Order order) {
        try {
            // Шаг 1: Создать заказ
            orderService.create(order);
            
            // Шаг 2: Списать деньги
            paymentService.processPayment(order);
            
            // Шаг 3: Забронировать товар
            inventoryService.reserveItems(order);
            
        } catch (Exception e) {
            // Компенсирующие действия
            compensate(order);
            throw e;
        }
    }
    
    private void compensate(Order order) {
        // Выполняем в обратном порядке
        inventoryService.cancelReservation(order);
        paymentService.refundPayment(order);
        orderService.cancel(order);
    }
}
```

## 3. Outbox Pattern

**Суть:** Надежная доставка событий через запись в локальную БД перед отправкой в брокер.

```java
@Entity
@Table(name = "outbox_events")
public class OutboxEvent {
    @Id
    private String id;
    private String aggregateType;
    private String aggregateId;
    private String eventType;
    @Lob
    private String payload;
    private LocalDateTime createdAt;
    private boolean processed;
}

@Service
@Transactional
public class OrderService {
    
    @Autowired
    private OutboxRepository outboxRepository;
    
    @Autowired
    private OrderRepository orderRepository;
    
    public void createOrder(Order order) {
        // 1. Сохраняем заказ
        orderRepository.save(order);
        
        // 2. Сохраняем событие в outbox в той же транзакции
        OutboxEvent event = OutboxEvent.builder()
            .id(UUID.randomUUID().toString())
            .aggregateType("Order")
            .aggregateId(order.getId())
            .eventType("ORDER_CREATED")
            .payload(objectMapper.writeValueAsString(order))
            .createdAt(LocalDateTime.now())
            .build();
            
        outboxRepository.save(event);
        // Транзакция коммитится атомарно
    }
}

// Отдельный процесс для отправки событий
@Component
public class OutboxProcessor {
    
    @Scheduled(fixedDelay = 1000)
    @Transactional
    public void processOutbox() {
        List<OutboxEvent> events = outboxRepository.findUnprocessed();
        
        for (OutboxEvent event : events) {
            try {
                eventPublisher.publish(event);
                event.markAsProcessed();
                outboxRepository.save(event);
            } catch (Exception e) {
                // Retry logic
            }
        }
    }
}
```

## 4. Event Sourcing

**Суть:** Хранение не текущего состояния, а последовательности событий, которые к нему привели.

```java
// Агрегат с event sourcing
public class Order {
    private String id;
    private OrderStatus status;
    private List<OrderEvent> changes = new ArrayList<>();
    
    public static Order create(String orderId, Customer customer) {
        Order order = new Order();
        order.apply(new OrderCreatedEvent(orderId, customer, LocalDateTime.now()));
        return order;
    }
    
    public void complete() {
        if (this.status != OrderStatus.CREATED) {
            throw new IllegalStateException("Order not in created state");
        }
        apply(new OrderCompletedEvent(this.id, LocalDateTime.now()));
    }
    
    private void apply(OrderEvent event) {
        this.changes.add(event);
        this.handle(event);
    }
    
    private void handle(OrderEvent event) {
        if (event instanceof OrderCreatedEvent) {
            this.id = ((OrderCreatedEvent) event).getOrderId();
            this.status = OrderStatus.CREATED;
        } else if (event instanceof OrderCompletedEvent) {
            this.status = OrderStatus.COMPLETED;
        }
    }
    
    // Восстановление состояния из событий
    public static Order reconstruct(List<OrderEvent> events) {
        Order order = new Order();
        events.forEach(order::handle);
        return order;
    }
}
```

## 5. CQRS (Command Query Responsibility Segregation)

**Суть:** Разделение моделей для чтения и записи.

```java
// Command side (Write)
@RestController
public class OrderCommandController {
    
    @PostMapping("/orders")
    public ResponseEntity<String> createOrder(@RequestBody CreateOrderCommand command) {
        String orderId = orderCommandService.createOrder(command);
        return ResponseEntity.accepted().body(orderId);
    }
}

@Service
@Transactional
public class OrderCommandService {
    
    public String createOrder(CreateOrderCommand command) {
        // Валидация команды
        validateCommand(command);
        
        // Создание агрегата
        Order order = Order.create(UUID.randomUUID().toString(), command.getCustomer());
        
        // Сохранение событий
        eventStore.save(order.getId(), order.getChanges());
        
        // Публикация событий
        eventPublisher.publish(order.getChanges());
        
        return order.getId();
    }
}

// Query side (Read)
@RestController
public class OrderQueryController {
    
    @GetMapping("/orders/{id}")
    public OrderView getOrder(@PathVariable String id) {
        return orderQueryService.getOrder(id);
    }
}

@Service
public class OrderQueryService {
    
    @Autowired
    private OrderViewRepository orderViewRepository;
    
    public OrderView getOrder(String id) {
        return orderViewRepository.findById(id)
            .orElseThrow(() -> new OrderNotFoundException(id));
    }
}

// Projection для обновления read model
@Component
public class OrderProjection {
    
    @EventListener
    public void handleOrderCreated(OrderCreatedEvent event) {
        OrderView view = OrderView.builder()
            .id(event.getOrderId())
            .customer(event.getCustomer())
            .status("CREATED")
            .createdAt(event.getTimestamp())
            .build();
            
        orderViewRepository.save(view);
    }
}
```

## Комбинированные подходы

На практике эти паттерны часто используются вместе:

```java
// Event Sourcing + CQRS + Outbox
@Service
public class OrderApplicationService {
    
    @Transactional
    public String handleCreateOrder(CreateOrderCommand command) {
        // 1. Восстанавливаем состояние (Event Sourcing)
        List<OrderEvent> history = eventStore.getEvents(command.getOrderId());
        Order order = Order.reconstruct(history);
        
        // 2. Выполняем команду
        order.create(command);
        
        // 3. Сохраняем новые события
        eventStore.save(order.getId(), order.getChanges());
        
        // 4. Сохраняем в outbox для публикации
        outboxRepository.saveAll(createOutboxEvents(order.getChanges()));
        
        return order.getId();
    }
}
```

## Ключевые преимущества и когда что использовать:

- **2PC**: Простые сценарии, когда можно пожертвовать производительностью
- **Saga**: Долгие бизнес-процессы с необходимостью компенсаций
- **Outbox**: Надежная доставка событий между сервисами
- **Event Sourcing**: Полный аудит, временные запросы, сложная бизнес-логика
- **CQRS**: Высокая нагрузка на чтение, разные модели для разных use cases

Для senior Java разработчика понимание этих паттернов критически важно для проектирования масштабируемых и надежных систем. Что тебя интересует больше всего? Могу углубиться в любой из этих паттернов с более детальными примерами реализации.