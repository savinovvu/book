Привет! С удовольствием расскажу про inline-функции и классы в Kotlin с точки зрения senior backend разработчика. Это важные концепции для оптимизации производительности.

## Inline-функции

### Основная концепция

**Inline-функции** - это функции, код которых "встраивается" непосредственно в место вызова во время компиляции, вместо обычного вызова функции.

```kotlin
inline fun <T> measureTime(block: () -> T): T {
    val start = System.currentTimeMillis()
    val result = block()
    val end = System.currentTimeMillis()
    println("Execution time: ${end - start} ms")
    return result
}

// Использование
fun processData() {
    val data = measureTime {
        // тяжелые вычисления
        heavyComputation()
    }
}
```

После компиляции код будет выглядеть примерно так:
```kotlin
fun processData() {
    val start = System.currentTimeMillis()
    val result = heavyComputation()
    val end = System.currentTimeMillis()
    println("Execution time: ${end - start} ms")
    val data = result
}
```

### Когда использовать inline-функции

1. **Функции высшего порядка с лямбда-параметрами**
```kotlin
// Без inline - создается объект анонимного класса
fun <T> nonInline(block: () -> T): T {
    return block()
}

// С inline - избегаем создания объекта
inline fun <T> inlineExample(block: () -> T): T {
    return block()
}
```

2. **Reified generics (конкретизированные типы)**
```kotlin
inline fun <reified T> parseJson(json: String): T {
    return Json.decodeFromString<T>(json)
}

// Использование
val user = parseJson<User>("""{"name": "John", "age": 30}""")
```

### Ограничения и предостережения

```kotlin
// НЕ используйте inline для больших функций!
inline fun largeFunction() {
    // Много кода...
    // Это увеличит размер бинарного файла
}

// crossinline - когда лямбда не может быть встроена, но нужно сохранить inline для функции
inline fun executeWithLogging(crossinline block: () -> Unit) {
    println("Starting execution")
    block()
    println("Execution completed")
}
```

## Inline-классы (value-классы)

### Основная концепция

**Inline-классы** (с Kotlin 1.5+ называются value-классы) предоставляют типобезопасность без накладных расходов runtime.

```kotlin
@JvmInline
value class UserId(val value: String)

@JvmInline
value class Email(val value: String)

fun sendEmail(to: Email, subject: String) {
    // Компилятор гарантирует, что передается именно Email, а не просто String
}

// Использование
val userId = UserId("123")
val email = Email("user@example.com")

sendEmail(email, "Hello") // OK
// sendEmail(userId, "Hello") // Ошибка компиляции - несовместимые типы
```

### Преимущества для backend разработки

1. **Type safety в API**
```kotlin
@JvmInline
value class ProductId(val value: String)

@JvmInline
value class CategoryId(val value: String)

// Четкое разделение типов в API
interface ProductService {
    suspend fun getProduct(id: ProductId): Product?
    suspend fun getProductsByCategory(categoryId: CategoryId): List<Product>
}
```

2. **Валидация на уровне типа**
```kotlin
@JvmInline
value class Password private constructor(val value: String) {
    companion object {
        fun create(raw: String): Password {
            require(raw.length >= 8) { "Password must be at least 8 characters" }
            return Password(raw)
        }
    }
}
```

## Практические примеры из backend разработки

### 1. Работа с базой данных
```kotlin
@JvmInline
value class DbId(val value: Long)

inline fun <reified T : Any> Database.findById(id: DbId): T? {
    return findById(T::class, id.value)
}

// Использование
val userId = DbId(123L)
val user = database.findById<User>(userId)
```

### 2. API responses
```kotlin
@JvmInline
value class ApiKey(val value: String)

inline fun <reified T> httpClient.getWithAuth(
    url: String, 
    apiKey: ApiKey
): T {
    return get(url) {
        header("Authorization", "Bearer ${apiKey.value}")
    }.body()
}
```

### 3. Валидация и бизнес-логика
```kotlin
@JvmInline
value class Price(val value: Double) {
    init {
        require(value >= 0) { "Price cannot be negative" }
    }
    
    operator fun plus(other: Price): Price = Price(value + other.value)
}

@JvmInline
value class Quantity(val value: Int) {
    init {
        require(value > 0) { "Quantity must be positive" }
    }
}
```

## Производительность

### Бенчмарки

```kotlin
// Тест производительности
fun benchmark() {
    val iterations = 1_000_000
    
    // Без inline
    val time1 = measureTimeMillis {
        repeat(iterations) {
            nonInlineFunction { /* что-то делаем */ }
        }
    }
    
    // С inline
    val time2 = measureTimeMillis {
        repeat(iterations) {
            inlineFunction { /* что-то делаем */ }
        }
    }
    
    println("Non-inline: $time1 ms")
    println("Inline: $time2 ms")
}
```

## Best Practices

### ✅ Рекомендуется:
- Использовать inline для небольших функций высшего порядка
- Применять value-классы для типобезопасности идентификаторов
- Использовать reified generics для работы с reflection
- Документировать назначение value-классов

### ❌ Не рекомендуется:
- Использовать inline для больших функций
- Создавать value-классы без реальной необходимости
- Злоупотреблять reified типами в performance-critical коде

```kotlin
// Хороший пример
inline fun <reified T> String.fromJson(): T = Json.decodeFromString(this)

// Плохой пример - слишком большая функция для inline
inline fun processUserData(user: User) {
    // Много сложной логики...
    // Увеличит размер бинарника
}
```

Inline-функции и классы - мощные инструменты для оптимизации производительности и улучшения типобезопасности в Kotlin backend приложениях. Правильное их использование может значительно улучшить как производительность, так и читаемость кода.