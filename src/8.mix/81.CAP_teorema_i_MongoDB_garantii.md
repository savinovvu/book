Коллега, приветствую! Давайте разберем теорему CAP и ее отношение к MongoDB с позиции Senior Java-разработчика.

## Теорема CAP: Суть для разработчика

**CAP** - фундаментальный принцип распределенных систем:

- **C (Consistency)** - Согласованность: все узлы видят одни и те же данные в один момент времени
- **A (Availability)** - Доступность: система всегда отвечает на запросы
- **P (Partition Tolerance)** - Устойчивость к разделению: система работает при сетевых сбоях между узлами

**Ключевой вывод**: можно гарантировать только 2 из 3 свойств одновременно.

## MongoDB в контексте CAP

### Базовое позиционирование
MongoDB позиционируется как **CP-система** (Consistency + Partition Tolerance):

```
При сетевом разделении (P) → жертвует доступностью (A) в пользу согласованности (C)
```

### Как это реализуется в репликасетах

```java
// Пример конфигурации репликасета в Java Driver
MongoClientSettings settings = MongoClientSettings.builder()
    .applyToClusterSettings(builder -> 
        builder.hosts(Arrays.asList(
            new ServerAddress("host1:27017"),
            new ServerAddress("host2:27017"),
            new ServerAddress("host3:27017")
        ))
    )
    .writeConcern(WriteConcern.MAJORITY)
    .readConcern(ReadConcern.MAJORITY)
    .readPreference(ReadPreference.primaryPreferred())
    .build();
```

### Механизмы обеспечения CP

**1. Выбор лидера (Leader Election)**
- При разрыве связи репликасет выбирает нового primary
- Только primary принимает запись
- До завершения выбора - запись недоступна

**2. Кворум записи**
```java
// Гарантия записи в большинство узлов
WriteConcern writeConcern = new WriteConcern("majority", 5000);
collection.withWriteConcern(writeConcern)
         .insertOne(document);
```

**3. Чтение согласованных данных**
```java
// Чтение только подтвержденных данных
ReadConcern readConcern = ReadConcern.MAJORITY;
FindIterable<Document> result = collection
    .withReadConcern(readConcern)
    .find(Filters.eq("status", "active"));
```

## Гарантии MongoDB на практике

### Гарантии согласованности
```java
// Сильная согласованность в пределах сессии
ClientSession clientSession = mongoClient.startSession();
try {
    clientSession.startTransaction();
    
    // Все операции в транзакции видят согласованное состояние
    collection.insertOne(clientSession, document1);
    Document result = collection.find(clientSession).first(); // Видит свою запись
    
    clientSession.commitTransaction();
} catch (Exception e) {
    clientSession.abortTransaction();
}
```

### Гарантии durability
```java
// Journaling гарантирует сохранность данных
WriteConcern journalWriteConcern = WriteConcern.JOURNALED;
collection.withWriteConcern(journalWriteConcern)
         .replaceOne(filter, replacement);
```

## Сценарии при сетевых разделах

### Сценарий 1: Primary изолирован
```
[Primary] ←X→ [Secondary1, Secondary2]
```
- Primary теряет статус (по истечении electionTimeout)
- Вторичные узлы выбирают нового primary
- Клиенты, подключенные к старому primary, получают исключения:
```java
try {
    collection.insertOne(document);
} catch (MongoSocketException e) {
    // Обработка разрыва соединения
    logger.error("Network partition detected", e);
    retryWithNewConnection();
}
```

### Сценарий 2: Secondary изолирован
```
[Primary, Secondary1] ←X→ [Secondary2]
```
- Изолированный secondary не может стать primary
- Чтение возможно из primary или connected secondary
- Система остается доступной для записи

## Настройка баланса CAP в MongoDB

### В сторону доступности (ослабление C)
```java
// Чтение с secondary (возможны устаревшие данные)
ReadPreference readPreference = ReadPreference.secondary();
collection.withReadPreference(readPreference)
         .find(filter);

// Запись без ожидания подтверждения
WriteConcern unacknowledged = WriteConcern.UNACKNOWLEDGED;
```

### В сторону согласованности (усиление C)
```java
// Линейная согласованность через majority reads/writes
WriteConcern majorityWrite = WriteConcern.MAJORITY;
ReadConcern linearizable = ReadConcern.LINEARIZABLE;

// Журналирование обязательно
WriteConcern safe = new WriteConcern(2, 3000, true);
```

## Практические рекомендации для Java-разработчика

### 1. Обработка сетевых разделов
```java
@Retryable(value = {MongoException.class}, maxAttempts = 3)
public void saveWithRetry(Document document) {
    try {
        collection.insertOne(document);
    } catch (MongoSocketException | MongoTimeoutException e) {
        // Логика повторных попыток
        handlePartition(e);
    }
}
```

### 2. Мониторинг состояния кластера
```java
public class MongoClusterMonitor {
    public boolean isHealthy() {
        try {
            Document status = mongoClient.getDatabase("admin")
                .runCommand(new Document("replSetGetStatus", 1));
            return checkReplicaSetStatus(status);
        } catch (Exception e) {
            return false;
        }
    }
}
```

### 3. Стратегия fallback
```java
@Component
public class MongoService {
    @Autowired private CacheService cacheService;
    
    public Document findWithFallback(String id) {
        try {
            return collection.find(Filters.eq("_id", id)).first();
        } catch (MongoException e) {
            // При недоступности MongoDB используем кэш
            return cacheService.get(id);
        }
    }
}
```

## Выводы для Senior Java Developer

1. **MongoDB - CP система** с настройкой баланса через Write/Read Concern
2. **Понимание механизмов репликации** критично для проектирования отказоустойчивых систем
3. **Всегда обрабатывайте исключения** сетевых разделов в коде
4. **Настройка таймаутов и retry policies** - must have для production
5. **Тестируйте сценарии сетевых разделов** на staging окружениях

Правильное использование гарантий MongoDB позволяет строить надежные и предсказуемые distributed системы на Java.