Привет! Как Senior Java Developer, я с удовольствием расскажу о нормализации баз данных — это фундаментальная концепция, которую мы постоянно используем при проектировании архитектуры приложений.

## Что такое нормализация?

**Нормализация** — это процесс организации данных в базе данных для:
- Уменьшения избыточности данных
- Устранения аномалий вставки, обновления и удаления
- Улучшения целостности данных

## Основные нормальные формы

### 1. Первая нормальная форма (1NF)
**Требования:**
- Все атрибуты атомарны (неделимы)
- Нет повторяющихся групп
- Уникальные строки

**Пример нарушения:**
```sql
CREATE TABLE Orders (
    order_id INT,
    customer_name VARCHAR(100),
    products VARCHAR(500) -- "Product1, Product2, Product3" - НЕ атомарно!
);
```

**Исправление:**
```sql
CREATE TABLE Orders (
    order_id INT,
    customer_name VARCHAR(100)
);

CREATE TABLE Order_Items (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100)
);
```

### 2. Вторая нормальная форма (2NF)
**Требования:**
- Соответствует 1NF
- Все неключевые атрибуты полностью зависят от первичного ключа

**Пример:**
```sql
-- Проблема: product_name зависит только от product_id, а не от всего ключа (order_id, product_id)
CREATE TABLE Order_Details (
    order_id INT,
    product_id INT,
    product_name VARCHAR(100), -- Частичная зависимость!
    quantity INT,
    PRIMARY KEY (order_id, product_id)
);
```

### 3. Третья нормальная форма (3NF)
**Требования:**
- Соответствует 2NF
- Нет транзитивных зависимостей (неключевые атрибуты не зависят от других неключевых атрибутов)

**Пример:**
```sql
-- Проблема: category зависит от product, который не является ключом
CREATE TABLE Products (
    product_id INT PRIMARY KEY,
    product_name VARCHAR(100),
    category_id INT,
    category_name VARCHAR(100) -- Транзитивная зависимость!
);
```

## Дополнительные нормальные формы

### 4. Нормальная форма Бойса-Кодда (BCNF)
- Усиленная версия 3NF
- Каждая детерминанта - потенциальный ключ

### 5. Четвертая нормальная форма (4NF)
- Устранение многозначных зависимостей

## Практический пример нормализации

**Денормализованная таблица:**
```sql
CREATE TABLE Company (
    employee_id INT,
    employee_name VARCHAR(100),
    department_id INT,
    department_name VARCHAR(100),
    manager_id INT,
    manager_name VARCHAR(100),
    project_names VARCHAR(500) -- "Project1,Project2"
);
```

**После нормализации:**
```sql
CREATE TABLE Employees (
    employee_id INT PRIMARY KEY,
    employee_name VARCHAR(100),
    department_id INT,
    manager_id INT
);

CREATE TABLE Departments (
    department_id INT PRIMARY KEY,
    department_name VARCHAR(100)
);

CREATE TABLE Projects (
    project_id INT PRIMARY KEY,
    project_name VARCHAR(100)
);

CREATE TABLE Employee_Projects (
    employee_id INT,
    project_id INT,
    PRIMARY KEY (employee_id, project_id)
);
```

## Как это связано с Java разработкой?

### 1. Entity Classes
```java
@Entity
@Table(name = "employees")
public class Employee {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @ManyToOne
    @JoinColumn(name = "department_id")
    private Department department;
    
    @OneToMany(mappedBy = "employee")
    private List<EmployeeProject> projects;
}

@Entity
@Table(name = "departments")
public class Department {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    
    private String name;
    
    @OneToMany(mappedBy = "department")
    private List<Employee> employees;
}
```

### 2. Repository Layer
```java
@Repository
public interface EmployeeRepository extends JpaRepository<Employee, Long> {
    
    @Query("SELECT e FROM Employee e JOIN FETCH e.department WHERE e.id = :id")
    Optional<Employee> findByIdWithDepartment(@Param("id") Long id);
    
    List<Employee> findByDepartmentName(String departmentName);
}
```

### 3. Service Layer
```java
@Service
@Transactional
public class EmployeeService {
    
    private final EmployeeRepository employeeRepository;
    private final DepartmentRepository departmentRepository;
    
    public Employee assignToDepartment(Long employeeId, Long departmentId) {
        Employee employee = employeeRepository.findById(employeeId)
            .orElseThrow(() -> new EntityNotFoundException("Employee not found"));
        
        Department department = departmentRepository.findById(departmentId)
            .orElseThrow(() -> new EntityNotFoundException("Department not found"));
        
        employee.setDepartment(department);
        return employeeRepository.save(employee);
    }
}
```

## Преимущества нормализации для Java разработчика

1. **Чистая объектная модель** - соответствие принципам ООП
2. **Упрощенный ORM mapping** - прямые связи между сущностями
3. **Предсказуемые транзакции** - ACID свойства
4. **Эффективные запросы** - возможность точечных обновлений
5. **Снижение блокировок** - меньшие scope транзакций

## Когда использовать денормализацию?

Несмотря на преимущества нормализации, иногда нужна денормализация:

1. **Reporting системы** - сложные аналитические запросы
2. **Read-heavy приложения** - уменьшение JOIN'ов
3. **Микросервисная архитектура** - дублирование данных между сервисами
4. **Materialized Views** - предварительно рассчитанные данные

## Best Practices от Senior Developer

1. **Начинайте с нормализованной схемы** - всегда легче денормализовать потом
2. **Используйте миграции** - Liquibase/Flyway для управления изменениями
3. **Профилируйте запросы** - понимайте, где нужны индексы
4. **Consider cache strategies** - Redis/Hazelcast для часто читаемых данных
5. **Тестируйте с реальными данными** - объем влияет на производительность

Нормализация — это баланс между теоретической чистотой и практической производительностью. Как Senior Java Developer, важно понимать эти компромиссы и принимать взвешенные архитектурные решения!