Чтобы диагностировать утечки памяти в Spring-приложении, необходимо использовать комбинацию инструментов и практик. Вот пошаговое руководство:

---

### **1. Мониторинг и сбор данных**
#### **Включите мониторинг JVM:**
- Используйте JVM-флаги для сбора данных о памяти:
  ```bash
  -XX:+HeapDumpOnOutOfMemoryError -XX:HeapDumpPath=/path/to/dumps
  ```
- Для динамического анализа подключите JMX-инструменты (JConsole, VisualVM, JMC).

#### **Spring Actuator:**
Добавьте в проект эндпоинты для мониторинга:
```yaml
management:
  endpoints:
    web:
      exposure:
        include: "metrics,info,health,heapdump"
```
Эндпоинт `/actuator/heapdump` позволяет скачать дамп памяти напрямую.

---

### **2. Анализ Heap Dump**
#### **Инструменты:**
- **Eclipse MAT (Memory Analyzer Tool)** – основной инструмент для анализа дампов.
- **JVisualVM** (входит в JDK).
- **YourKit/JProfiler** – коммерческие решения с расширенными возможностями.

#### **Что искать в Heap Dump:**
1. **Крупнейшие объекты** (поиск через `Histogram` или `Dominator Tree`).
2. **Дублирующиеся строки/коллекции** (через `Duplicate Classes`).
3. **Незакрытые ресурсы** (например, соединения с БД, потоки).
4. **Ссылки на бины Spring** (искать по именам классов, например `*ApplicationContext*`).

---

### **3. Анализ бинов Spring**
#### **Типичные проблемы:**
- **Бины в singleton-scope**, накапливающие состояние (например, кэши или мапы).
- **Циклические зависимости** между бинами, мешающие сборке мусора.
- **Неправильное использование scope** (например, `@SessionScope` без очистки).

#### **Диагностика:**
- Проверьте журналы Spring на предмет создания/уничтожения бинов.
- Используйте `@PreDestroy` для отслеживания удаления бинов.
- Анализируйте граф зависимостей через `ApplicationContext.getBeanDefinitionNames()`.

---

### **4. Утечки в кэшах**
#### **Распространенные сценарии:**
- Кэш без ограничений (например, `ConcurrentHashMap` без TTL или LRU-политики).
- Неправильная настройка TTL в `@Cacheable`.
- Кэширование mutable-объектов, которые растут со временем.

#### **Решение:**
- Настройте политики вытеснения (например, в Caffeine, Ehcache):
  ```java
  @Bean
  public CacheManager cacheManager() {
      CaffeineCacheManager cacheManager = new CaffeineCacheManager();
      cacheManager.setCaffeine(Caffeine.newBuilder().expireAfterWrite(10, TimeUnit.MINUTES));
      return cacheManager;
  }
  ```
- Регулярно проверяйте метрики кэша через `/actuator/metrics/cache.*`.

---

### **5. Профилирование приложения**
- **JProfiler/YourKit:** Запустите CPU и Memory Profiling для отслеживания создания объектов в реальном времени.
- **JFR (Java Flight Recorder):**
  ```bash
  -XX:StartFlightRecording=filename=dump.jfr,duration=60s
  ```
- **Async Profiler:** Ищите утечки через аллокации памяти.

---

### **6. Типичные источники утечек в Spring**
- **Статические поля** (удерживают ссылки на бины или коллекции).
- **ThreadLocal** (например, в контексте безопасности Spring Security).
- **Слушатели событий** (не отписываются от `ApplicationEventMulticaster`).
- **Сессии HTTP** (объекты в `HttpSession` без очистки).
- **Connection Pools** (незакрытые `DataSource` или Hibernate-сессии).

---

### **7. Практические шаги**
1. **Сравните Heap Dump до и после нагрузки** (например, через `jmap`).
2. **Нагрузите приложение** (через Apache JMeter/Gatling) и следите за `Metaspace`, `Heap`, `Non-Heap`.
3. **Проверьте код**:
    - Закрывайте ресурсы в `finally`-блоках или используйте try-with-resources.
    - Избегайте статических коллекций.
    - Используйте `WeakHashMap` для кэшей, если уместно.

---

### **Пример диагностики через Eclipse MAT**
1. Откройте Heap Dump.
2. Ищите **«Leak Suspects Report»**.
3. Анализируйте **«Biggest Objects»**.
4. Проверьте **Path to GC Roots** для подозрительных объектов.

---

### **Заключение**
Диагностика утечек в Spring требует системного подхода: мониторинг → сбор дампов → анализ → проверка кода. Особое внимание уделяйте бинам, кэшам и работе с контекстом. Инструменты вроде MAT и Spring Actuator значительно ускоряют процесс.