Чтобы создать бин в Spring не через конструктор, а через фабричный метод, можно использовать следующие подходы:

---

### 1. **Статический фабричный метод через `@Bean`**
Если фабричный метод **статический**, укажите его непосредственно в `@Bean`-методе конфигурационного класса.

```java
@Component
public class MyClass {
    // Класс, экземпляр которого создается через статический метод
    private MyClass() {}
    
    public static MyClass createInstance() {
        return new MyClass();
    }
}

@Configuration
public class AppConfig {
    @Bean
    public MyClass myClassBean() {
        // Вызов статического фабричного метода
        return MyClass.createInstance();
    }
}
```

---

### 2. **Нестатический фабричный метод через `@Bean`**
Если фабричный метод **нестатический**, сначала объявите бин фабрики, а затем используйте его метод.

```java
@Component
public class MyClassFactory {
    public MyClass createInstance() {
        return new MyClass();
    }
}

@Configuration
public class AppConfig {
    @Bean
    public MyClass myClassBean(MyClassFactory factory) {
        // Вызов нестатического фабричного метода
        return factory.createInstance();
    }
}
```

---

### 3. **Использование `FactoryBean` интерфейса**
Реализуйте интерфейс `FactoryBean<T>`, чтобы централизовать логику создания бина.

```java
public class MyClassFactoryBean implements FactoryBean<MyClass> {
    @Override
    public MyClass getObject() {
        return MyClass.createInstance(); // Статический метод
    }

    @Override
    public Class<?> getObjectType() {
        return MyClass.class;
    }

    @Override
    public boolean isSingleton() {
        return true; // или false, в зависимости от требований
    }
}

@Configuration
public class AppConfig {
    @Bean
    public FactoryBean<MyClass> myClass() {
        return new MyClassFactoryBean();
    }
}
```

**Важно**:
- Spring автоматически вызывает `getObject()` для получения экземпляра `MyClass`.
- Обращение к контексту через `context.getBean("myClass")` вернет экземпляр `MyClass`, а не `FactoryBean`. Чтобы получить саму фабрику, используйте `&myClass`.

---

### 4. **Использование `@Component` на фабричном методе**
Для компонентов, сканируемых через `@ComponentScan`, можно использовать `@Bean` внутри `@Configuration` или фабричные методы в самих компонентах.

```java
@Component
public class MyClassFactory {
    @Bean
    public MyClass myClass() {
        return MyClass.createInstance();
    }
}
```

---

### Итог:
- **Статический метод**: Вызовите его напрямую в `@Bean`-методе.
- **Нестатический метод**: Внедрите фабрику и вызовите ее метод.
- **`FactoryBean`**: Реализуйте интерфейс для сложных сценариев создания бинов.
- Spring автоматически управляет жизненным циклом бинов, созданных через фабричные методы, так же, как и для обычных бинов.