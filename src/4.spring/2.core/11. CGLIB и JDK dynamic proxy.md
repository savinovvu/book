Отличный вопрос, затрагивающий самую суть механизма проксирования в Spring AOP. Вот подробное объяснение.

Spring AOP создает два типа прокси для внедрения аспектов (advice) вокруг целевых объектов (target objects):

1.  **JDK Dynamic Proxy** (Динамический прокси на основе JDK)
2.  **CGLIB Proxy** (Прокси на основе библиотеки Code Generation Library)

### Ключевая разница

Основное и самое важное различие заключается в **механизме их работы**:

*   **JDK Dynamic Proxy** работает на основе **интерфейсов**. Он динамически создает класс, который *реализует* те же интерфейсы, что и целевой объект.
*   **CGLIB Proxy** работает на основе **наследования**. Он динамически создает *подкласс* целевого класса.

Давайте разберем подробнее в сравнительной таблице.

### Сравнительная таблица: JDK Dynamic Proxy vs CGLIB

| Критерий | JDK Dynamic Proxy | CGLIB Proxy |
| :--- | :--- | :--- |
| **Основа механизма** | **Интерфейсы** | **Наследование** |
| **Как создается прокси** | Создает новый класс, который реализует все интерфейсы целевого объекта. Обертывает вызовы к оригинальному объекту. | Создает подкласс целевого класса и переопределяет его не-final методы. |
| **Требования к целевому объекту** | Целевой объект **должен реализовывать хотя бы один интерфейс**. | Целевой объект **не должен быть final** (и методы не должны быть final). |
| **Производительность** | В более старых версиях Java (до 8) был медленнее при создании прокси и вызовах методов. В современных JVM разница незначительна, но CGLIB все еще может быть чуть быстрее в некоторых сценариях. | Исторически быстрее, особенно в Java 6-7. В современных JVM разница минимальна. |
| **Зависимости** | Входит в состав JDK (пакет `java.lang.reflect`). | Требует отдельной библиотеки CGLIB (но она уже транзитивно подключается с Spring Core). |
| **Исключения** | Если метод, объявленный в интерфейсе, выбрасывает проверяемое исключение (checked exception), то проксированный метод также должен его объявлять. | Может обходить это ограничение, так как работает напрямую с классом, а не с контрактом интерфейса. |
| **"Self-invocation" проблема** | Присутствует. Вызов одного метода проксированного объекта из другого метода того же объекта не будет проходить через прокси. | Присутствует в той же степени. |

---

### Как Spring выбирает тип прокси?

Логика выбора по умолчанию (начиная с Spring 4.x и актуальна для 5.x / 6.x):

1.  Если целевой объект **реализует хотя бы один интерфейс** -> Spring по умолчанию использует **JDK Dynamic Proxy**.
2.  Если целевой объект **не реализует ни одного интерфейса** -> Spring использует **CGLIB**.

Однако это поведение можно **принудительно изменить**.

### Управление выбором прокси в Spring

Вы можете заставить Spring всегда использовать CGLIB, даже если есть интерфейсы. Это делается с помощью настройки `proxyTargetClass`:

*   В **аннотационной конфигурации**: `@EnableAspectJAutoProxy(proxyTargetClass = true)`
*   В **XML конфигурации**: `<aop:aspectj-autoproxy proxy-target-class="true"/>`

**Когда это может быть полезно?**
*   Когда вы хотите consistently использовать один тип прокси во всем приложении.
*   Когда вам нужно проксировать метод, который не объявлен в интерфейсе (например, в классе-наследнике).
*   В некоторых сложных сценариях, когда поведение JDK-прокси приводит к проблемам (например, с кастингом).

### Практический пример

Представим следующий класс:

```java
// Интерфейс
public interface UserService {
    void saveUser();
}

// Класс, реализующий интерфейс
public class UserServiceImpl implements UserService {
    public void saveUser() {
        System.out.println("Saving user...");
    }
    
    // Этот метод НЕ в интерфейсе
    public void internalMethod() {
        System.out.println("Internal call...");
        this.saveUser(); // Self-invocation! Этот вызов НЕ будет перехвачен прокси.
    }
}
```

*   **С настройками по умолчанию** (`proxyTargetClass = false`):
    *   Spring создаст **JDK Dynamic Proxy** для `UserServiceImpl`.
    *   Прокси будет иметь тип `UserService`, а не `UserServiceImpl`.
    *   Вызов `internalMethod()` извне будет перехвачен, но внутренний вызов `this.saveUser()` — нет.

*   **С `proxyTargetClass = true`**:
    *   Spring создаст **CGLIB Proxy**.
    *   Прокси будет иметь тип `UserServiceImpl$$EnhancerBySpringCGLIB` (подкласс `UserServiceImpl`).
    *   Поведение с self-invocation не изменится, но теперь вы можете безопасно приводить объект к классу `UserServiceImpl` (хотя это и не рекомендуется).

### Вывод для Senior-разработчика

Понимание этой разницы критически важно для:
*   **Диагностики проблем**: Классические ошибки `ClassCastException` при попытке привести JDK-прокси к конкретному классу, а не к интерфейсу.
*   **Понимания ограничений Self-invocation**: Почему вызовы методов внутри одного бина не "аспектируются". Это знание напрямую влияет на дизайн сервисов и необходимо для осознанного использования `@Transactional`, `@Cacheable` и других аннотаций, основанных на AOP.
*   **Принятия архитектурных решений**: Осознанный выбор между интерфейсами и классами, понимание последствий этого выбора для механизма AOP.

#### В Spring Boot 2.x по умолчанию установлен proxyTargetClass=true для конфигурации AOP. Это означает, что Spring будет пытаться использовать CGLIB везде, даже если есть интерфейсы.


# Как создаётся прокси внутри спринга


**Отличный вопрос!** Spring использует CGLIB на очень конкретном этапе жизненного цикла бина - во время **пост-обработки (Bean Post-Processing)**.

## Конкретный момент: Bean Post-Processing

Вот детальное описание процесса:

### 1. Нормальный жизненный цикл бина
```java
1. Создание экземпляра (constructor)
2. Populate properties (внедрение зависимостей)
3. Bean Post-Processors (пред-инициализация)
4. @PostConstruct
5. AfterPropertiesSet (InitializingBean)
6. Bean Post-Processors (пост-инициализация)  ← ЗДЕСЬ!
7. Бин готов к использованию
```

### 2. Ключевой участник: `AbstractAutoProxyCreator`

```java
@Component
public class MyService { // Без интерфейсов - будет CGLIB
    public void doWork() {
        System.out.println("Working...");
    }
}
```

Spring использует `AnnotationAwareAspectJAutoProxyCreator` (наследник `AbstractAutoProxyCreator`), который является **BeanPostProcessor**:

```java
public class AnnotationAwareAspectJAutoProxyCreator extends AbstractAutoProxyCreator {
    
    // Этот метод вызывается ПОСЛЕ инициализации бина
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        if (bean != null) {
            // Проверяем, нужно ли создавать прокси для этого бина
            Object cacheKey = getCacheKey(bean.getClass(), beanName);
            if (!this.earlyProxyReferences.contains(cacheKey)) {
                return wrapIfNecessary(bean, beanName, cacheKey);
            }
        }
        return bean;
    }
    
    protected Object wrapIfNecessary(Object bean, String beanName, Object cacheKey) {
        // 1. Проверяем, не проксирован ли уже бин
        // 2. Проверяем, есть ли аспекты/аннотации для этого бина
        // 3. Если нужно проксировать - создаем прокси
        if (isInfrastructureClass(bean.getClass()) || shouldSkip(bean.getClass(), beanName)) {
            return bean;
        }
        
        // Получаем список advisors (аспектов) для этого бина
        Object[] specificInterceptors = getAdvicesAndAdvisorsForBean(bean.getClass(), beanName, null);
        if (specificInterceptors != DO_NOT_PROXY) {
            // СОЗДАНИЕ ПРОКСИ!
            this.advisedBeans.put(cacheKey, Boolean.TRUE);
            Object proxy = createProxy(bean.getClass(), beanName, specificInterceptors, new SingletonTargetSource(bean));
            return proxy;
        }
        
        return bean;
    }
}
```

### 3. Точка создания CGLIB прокси

В методе `createProxy()` происходит выбор и создание прокси:

```java
protected Object createProxy(Class<?> beanClass, String beanName,
        Object[] specificInterceptors, TargetSource targetSource) {
    
    ProxyFactory proxyFactory = new ProxyFactory();
    
    // Определяем тип прокси (CGLIB vs JDK)
    if (!proxyFactory.isProxyTargetClass()) {
        // Проверяем настройки proxyTargetClass
        if (shouldProxyTargetClass(beanClass, beanName)) {
            proxyFactory.setProxyTargetClass(true);
        }
        else {
            // Оцениваем интерфейсы для JDK proxy
            evaluateProxyInterfaces(beanClass, proxyFactory);
        }
    }
    
    // Добавляем advisors
    Advisor[] advisors = buildAdvisors(beanName, specificInterceptors);
    proxyFactory.addAdvisors(advisors);
    proxyFactory.setTargetSource(targetSource);
    
    // Настраиваем фабрику прокси
    customizeProxyFactory(proxyFactory);
    
    // СОЗДАЕМ ПРОКСИ!
    return proxyFactory.getProxy(getProxyClassLoader());
}
```

### 4. Конкретное создание CGLIB

В `CglibAopProxy`:

```java
public Object getProxy(@Nullable ClassLoader classLoader) {
    try {
        Class<?> rootClass = this.advised.getTargetClass();
        
        // Создаем CGLIB Enhancer
        Enhancer enhancer = createEnhancer();
        if (classLoader != null) {
            enhancer.setClassLoader(classLoader);
        }
        
        enhancer.setSuperclass(rootClass);
        enhancer.setInterfaces(AopProxyUtils.completeProxiedInterfaces(this.advised));
        enhancer.setNamingPolicy(SpringNamingPolicy.INSTANCE);
        enhancer.setStrategy(new ClassLoaderAwareUndeclaredThrowableStrategy(classLoader));
        
        // Callbacks - это "мозг" прокси, перехватывающий вызовы методов
        Callback[] callbacks = getCallbacks(rootClass);
        enhancer.setCallbackFilter(new ProxyCallbackFilter(this.advised));
        enhancer.setCallbacks(callbacks);
        
        // ГЕНЕРАЦИЯ ПРОКСИ-КЛАССА!
        Object proxy = enhancer.create();
        
        return proxy;
    }
    catch (CodeGenerationException | IllegalArgumentException ex) {
        throw new AopConfigException("Could not generate CGLIB subclass...", ex);
    }
}
```

## Визуализация процесса

```
[Создание бина MyService] 
    → [Внедрение зависимостей] 
    → [@PostConstruct] 
    → [BeanPostProcessor.postProcessAfterInitialization] 
    → [Spring обнаруживает @Transactional/@Async/etc] 
    → [ProxyFactory создает CGLIB прокси] 
    → [Возвращает прокси вместо оригинального бина]
```

## Практическая демонстрация

```java
@Component
@Transactional // Эта аннотация заставит Spring создать прокси
public class UserService {
    
    @PostConstruct
    public void init() {
        // На этом этапе бин еще НЕ проксирован
        System.out.println("Init: " + this.getClass());
        // Выведет: Init: class com.example.UserService
    }
    
    @Autowired
    public void setDependency(OtherService service) {
        // Здесь тоже еще нет прокси
    }
}

// А когда вы инжектируете этот бин в другом месте:
@Component
public class ClientComponent {
    
    @Autowired
    private UserService userService; // Здесь уже будет CGLIB прокси: UserService$$EnhancerBySpringCGLIB$$
    
    @PostConstruct
    public void checkProxy() {
        System.out.println("Injected: " + userService.getClass());
        // Выведет: Injected: class com.example.UserService$$EnhancerBySpringCGLIB$$12345678
    }
}
```

## Ключевой вывод

**CGLIB используется в методе `postProcessAfterInitialization()` класса `AbstractAutoProxyCreator`, который вызывается ПОСЛЕ создания и инициализации оригинального бина, но ДО того, как бин будет доступен для инжекции в другие компоненты.**

Это позволяет Spring сначала полностью создать и настроить оригинальный бин, а затем "обернуть" его в прокси, который добавляет дополнительное поведение (транзакции, кэширование, security checks и т.д.).