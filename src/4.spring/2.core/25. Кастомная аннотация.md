Вот пример реализации кастомной аннотации `@Audited` с использованием `BeanPostProcessor` в Spring. Это продвинутая реализация, подходящая для Senior-разработчиков:

1. **Создаем аннотацию `@Audited`:**
```java
@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
public @interface Audited {
    String value() default "";
    AuditLevel level() default AuditLevel.INFO;
}

enum AuditLevel {
    INFO, WARN, ERROR
}
```

2. **Создаем Aspect для перехвата вызовов:**
```java
@Aspect
@Component
public class AuditedAspect {
    
    private static final Logger logger = LoggerFactory.getLogger(AuditedAspect.class);
    
    @Around("@within(audited) || @annotation(audited)")
    public Object auditMethod(ProceedingJoinPoint pjp, Audited audited) throws Throwable {
        String methodName = pjp.getSignature().getName();
        String className = pjp.getTarget().getClass().getSimpleName();
        AuditLevel level = audited != null ? audited.level() : getClassLevelAudit(pjp).level();
        
        long startTime = System.currentTimeMillis();
        try {
            Object result = pjp.proceed();
            logAudit(level, "SUCCESS: {}.{}() executed in {} ms", 
                    className, methodName, System.currentTimeMillis() - startTime);
            return result;
        } catch (Exception e) {
            logAudit(AuditLevel.ERROR, "FAILED: {}.{}() executed in {} ms with error: {}", 
                    className, methodName, System.currentTimeMillis() - startTime, e.getMessage());
            throw e;
        }
    }
    
    private void logAudit(AuditLevel level, String format, Object... args) {
        switch (level) {
            case WARN -> logger.warn(format, args);
            case ERROR -> logger.error(format, args);
            default -> logger.info(format, args);
        }
    }
    
    private Audited getClassLevelAudit(ProceedingJoinPoint pjp) {
        return pjp.getTarget().getClass().getAnnotation(Audited.class);
    }
}
```

3. **Реализуем кастомный BeanPostProcessor:**
```java
@Component
public class AuditedBeanPostProcessor implements BeanPostProcessor, PriorityOrdered {
    
    private final ConfigurableListableBeanFactory beanFactory;
    
    public AuditedBeanPostProcessor(ConfigurableListableBeanFactory beanFactory) {
        this.beanFactory = beanFactory;
    }
    
    @Override
    public Object postProcessAfterInitialization(Object bean, String beanName) {
        Class<?> beanClass = bean.getClass();
        
        if (requiresAuditing(beanClass)) {
            ProxyFactory proxyFactory = new ProxyFactory(bean);
            proxyFactory.addAdvisor(getAdvisor());
            return proxyFactory.getProxy();
        }
        
        return bean;
    }
    
    private boolean requiresAuditing(Class<?> beanClass) {
        return beanClass.isAnnotationPresent(Audited.class) ||
               Arrays.stream(beanClass.getMethods())
                     .anyMatch(method -> method.isAnnotationPresent(Audited.class));
    }
    
    private DefaultPointcutAdvisor getAdvisor() {
        AspectJExpressionPointcut pointcut = new AspectJExpressionPointcut();
        pointcut.setExpression("@within(com.example.Audited) || @annotation(com.example.Audited)");
        return new DefaultPointcutAdvisor(pointcut, auditAdvice());
    }
    
    private Advice auditAdvice() {
        return new MethodInterceptor() {
            @Override
            public Object invoke(MethodInvocation invocation) throws Throwable {
                // Делегируем выполнение в Aspect
                return ((ProceedingJoinPoint) invocation).proceed();
            }
        };
    }
    
    @Override
    public int getOrder() {
        return LOWEST_PRECEDENCE;
    }
}
```

4. **Конфигурация Spring (Java Config):**
```java
@Configuration
@EnableAspectJAutoProxy
@ComponentScan
public class AppConfig {
    
    @Bean
    public AuditedAspect auditedAspect() {
        return new AuditedAspect();
    }
    
    @Bean
    public BeanPostProcessor auditedBeanPostProcessor(ConfigurableListableBeanFactory beanFactory) {
        return new AuditedBeanPostProcessor(beanFactory);
    }
}
```

5. **Пример использования:**
```java
@Service
@Audited(level = AuditLevel.WARN)
public class UserService {
    
    @Audited("Создание пользователя")
    public User createUser(String name) {
        return new User(name);
    }
    
    public void deleteUser(Long id) {
        // Метод без аудита
    }
}
```

**Ключевые особенности реализации:**

1. **Гибкая конфигурация** аннотации с поддержкой уровней логирования
2. **Двойной механизм обнаружения** - через BeanPostProcessor и AspectJ
3. **Поддержка аннотаций** на уровне класса и метода
4. **Измерение времени выполнения** методов
5. **Обработка исключений** с автоматическим повышением уровня логирования до ERROR
6. **Приоритизация** через PriorityOrdered
7. **Использование Spring AOP** с ProxyFactory для создания прокси

**Альтернативная улучшенная версия** с использованием BeanFactoryPostProcessor для оптимизации:
```java
@Component
public class AuditedAnnotationScanner implements BeanFactoryPostProcessor {
    
    @Override
    public void postProcessBeanFactory(ConfigurableListableBeanFactory beanFactory) throws BeansException {
        String[] beanNames = beanFactory.getBeanDefinitionNames();
        for (String beanName : beanNames) {
            BeanDefinition beanDef = beanFactory.getBeanDefinition(beanName);
            String beanClassName = beanDef.getBeanClassName();
            
            if (beanClassName != null) {
                try {
                    Class<?> beanClass = Class.forName(beanClassName);
                    if (requiresAuditing(beanClass)) {
                        ((AbstractBeanDefinition) beanDef).setBeanClass(
                            beanFactory.getBeanClassLoader().loadClass(
                                enhanceClassName(beanClassName)
                            )
                        );
                    }
                } catch (ClassNotFoundException e) {
                    throw new RuntimeException(e);
                }
            }
        }
    }
    
    private String enhanceClassName(String className) {
        return className + "_$$_Audited";
    }
}
```

Эта реализация демонстрирует глубокое понимание Spring IoC, AOP и механизмов расширения фреймворка, что характерно для Senior-уровня.