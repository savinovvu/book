Когда в Spring-контексте присутствует несколько бинов одного типа, возникает **неоднозначность автосвязывания (Autowiring Ambiguity)**. Spring предлагает несколько стратегий для её разрешения, которые применяются в следующем порядке приоритета:

---

### 1. **Аннотация `@Primary`**
- **Приоритет:** Высший.
- **Описание:** Бин, помеченный аннотацией `@Primary`, становится основным кандидатом для внедрения.
- **Пример:**
  ```java
  @Configuration
  public class Config {
      @Bean
      @Primary // Этот бин будет выбран по умолчанию
      public DataSource primaryDataSource() {
          return new H2DataSource();
      }

      @Bean
      public DataSource secondaryDataSource() {
          return new MySQLDataSource();
      }
  }
  ```

---

### 2. **Аннотация `@Qualifier`**
- **Приоритет:** Выше, чем соглашение по имени.
- **Описание:** Позволяет явно указать имя бина для внедрения.
- **Пример:**
  ```java
  @Component
  public class Service {
      // Указание конкретного бина через @Qualifier
      @Autowired
      @Qualifier("secondaryDataSource")
      private DataSource dataSource;
  }
  ```
- **Особенности:**
    - `@Qualifier` можно использовать совместно с `@Primary` для переопределения выбора.
    - Значение `@Qualifier` должно совпадать с именем бина (явно заданным в `@Bean` или `@Component`).

---

### 3. **Совпадение по имени поля/параметра**
- **Приоритет:** Низший.
- **Описание:** Spring пытается сопоставить имя поля (или параметра конструктора) с именем бина.
- **Пример:**
  ```java
  @Component
  public class Service {
      // Если есть бин с именем "secondaryDataSource", он будет выбран
      @Autowired
      private DataSource secondaryDataSource;
  }
  ```
- **Важно:** Этот метод работает только если:
    - Имена бинов уникальны в контексте.
    - Не используется `@Primary` или `@Qualifier`.

---

### 4. **Дополнительные механизмы**
- **Кастомные `@Qualifier`-аннотации:**  
  Создание собственных аннотаций на основе `@Qualifier` для семантического уточнения:
  ```java
  @Target({ElementType.FIELD, ElementType.PARAMETER})
  @Retention(RetentionPolicy.RUNTIME)
  @Qualifier
  public @interface DatabaseType {
      String value();
  }

  @Bean
  @DatabaseType("mysql")
  public DataSource mysqlDataSource() {
      return new MySQLDataSource();
  }

  @Autowired
  @DatabaseType("mysql")
  private DataSource dataSource;
  ```

- **Использование `@Resource` (JSR-250):**  
  Аннотация `@Resource(name = "beanName")` эквивалентна связыванию по имени.

---

### **Порядок разрешения неоднозначности**
1. Если есть `@Qualifier` → используется указанный бин.
2. Если нет `@Qualifier` → проверяется наличие `@Primary`.
3. Если ни одного `@Primary` → ищется бин с именем, совпадающим с полем/параметром.
4. Если кандидатов всё ещё несколько → исключение `NoUniqueBeanDefinitionException`.

---

### **Пример исключения**
```java
// Возникнет, если есть несколько бинов типа DataSource без @Primary/@Qualifier
NoUniqueBeanDefinitionException: 
No qualifying bean of type 'DataSource' available: 
expected single matching bean but found 2: primaryDataSource, secondaryDataSource
```

**Резюме:**  
Для предотвращения неоднозначности рекомендуется:
- Использовать `@Primary` для определения бина по умолчанию.
- Точно указывать зависимости через `@Qualifier` в сложных конфигурациях.
- Следить за уникальностью имён бинов при использовании соглашения по имени.