Контроль порядка инициализации бинов в Spring требуется в сценариях, где важна последовательность создания зависимостей, например:
- При обработке цепочки фильтров (Spring Security).
- При работе с обработчиками событий или `ApplicationListener`.
- Для упорядочивания бинов, реализующих один интерфейс и внедряемых в коллекцию (`List<SomeInterface>`).

Spring предоставляет три основных способа управления порядком:

---

### 1. **Интерфейс `Ordered`**
Реализуйте интерфейс `Ordered`, чтобы задать порядок программно:
```java
@Component
public class BeanA implements Ordered {
    @Override
    public int getOrder() {
        return 1; // Чем меньше число, тем выше приоритет
    }
}

@Component
public class BeanB implements Ordered {
    @Override
    public int getOrder() {
        return 2;
    }
}
```
**Приоритет:** `BeanA` → `BeanB`.

---

### 2. **Аннотация `@Order`**
Используйте аннотацию `@Order` для декларативного подхода:
```java
@Component
@Order(1)
public class BeanA { }

@Component
@Order(2)
public class BeanB { }
```
**Важно:** `@Order` работает только для:
- Компонентов, обрабатываемых Spring (например, `@Component`, `@Service`).
- Параметров методов в конфигурациях (`@Bean` с `@Order` не влияет на порядок создания бинов!).

---

### 3. **Интерфейс `PriorityOrdered`**
Подтип `Ordered`, который имеет **высший приоритет** относительно обычных `Ordered` бинов:
```java
@Component
public class HighPriorityBean implements PriorityOrdered {
    @Override
    public int getOrder() {
        return 1;
    }
}

@Component
@Order(1)
public class NormalBean { } // HighPriorityBean будет обработан первым.
```
**Порядок обработки:**
1. Бины с `PriorityOrdered`.
2. Бины с `Ordered` или `@Order`.
3. Остальные бины.

---

### **Важные нюансы**
1. **Влияние на порядок внедрения в коллекции**  
   `@Order` и `Ordered` влияют на порядок элементов в `List<SomeInterface>`, куда Spring внедряет все реализации `SomeInterface`:
   ```java
   @Autowired
   private List<SomeInterface> beans; // Отсортировано согласно @Order/Ordered
   ```

2. **Порядок инициализации бинов vs. зависимости**  
   `@Order` не управляет последовательностью создания бинов в общем случае. Для явного указания зависимостей используйте:
    - Аннотацию `@DependsOn`:
      ```java
      @Component
      @DependsOn("beanA")
      public class BeanB { }
      ```
    - Настройку в `@Bean` методах.

3. **Ограничения `@Order`**  
   Аннотация `@Order` не работает на `@Bean` методах напрямую. Для упорядочивания бинов, созданных через `@Bean`, используйте:
   ```java
   @Configuration
   public class Config {
       @Bean
       @Order(1) // Не сработает для порядка создания!
       public SomeBean bean1() {
           return new SomeBean();
       }

       // Вместо этого используйте зависимость:
       @Bean
       @DependsOn("bean1")
       public SomeBean bean2() {
           return new SomeBean();
       }
   }
   ```

---

### **Пример: порядок в фильтрах Spring Security**
```java
@Configuration
public class SecurityConfig {
    @Bean
    @Order(1)
    public SecurityFilterChain apiFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher("/api/**");
        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain defaultFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher("/**");
        return http.build();
    }
}
```

---

### **Итог**
- Используйте `@Order`/`Ordered` для сортировки бинов в коллекциях и определения порядка обработки в рамках контейнера.
- `PriorityOrdered` дает высший приоритет.
- Для контроля последовательности создания бинов комбинируйте `@DependsOn`, ленивую инициализацию (`@Lazy`) и настройку зависимостей в конфигурациях.