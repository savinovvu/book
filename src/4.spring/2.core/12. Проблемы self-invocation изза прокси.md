Проблема **self-invocation** в Spring возникает, когда вы вызываете метод с аннотациями `@Transactional`, `@Cacheable` или другими Spring AOP-аннотациями **изнутри того же класса**. Это происходит из-за ограничений механизма проксирования в Spring. Разберем детали:

---

### 1. **Причина проблемы**
Spring использует **AOP-прокси** для реализации функциональности аннотаций (транзакции, кэширование и т.д.).
- Когда вы вызываете метод `someMethod()` из другого класса, Spring перехватывает вызов через прокси и добавляет дополнительную логику (например, управление транзакцией).
- Однако при вызове `someMethod()` **изнутри того же класса** (например, через `this.someMethod()`), вы обходите прокси и вызываете метод напрямую. Аннотации игнорируются.

**Пример:**
```java
@Service
public class UserService {

    public void createUser() {
        // Вызов из того же класса -> @Transactional не сработает!
        this.updateUser(); // Прокси не используется!
    }

    @Transactional
    public void updateUser() {
        // Логика обновления пользователя...
    }
}
```

---

### 2. **Как работает проксирование?**
- Spring создает прокси-объект для вашего бина (например, используя CGLIB или JDK Dynamic Proxy).
- При вызове метода **извне** вы работаете с прокси, который делегирует вызов целевому объекту, предварительно выполнив дополнительную логику (открытие транзакции и т.д.).
- При **self-invocation** вызов происходит напрямую, минуя прокси.

---

### 3. **Решения проблемы**

#### **Вариант 1: Внедрение зависимости в самого себя**
Используйте `@Autowired` для ссылки на прокси-объект вашего класса:
```java
@Service
public class UserService {
    @Autowired
    private UserService self; // Ссылка на прокси!

    public void createUser() {
        self.updateUser(); // Вызов через прокси -> @Transactional работает!
    }

    @Transactional
    public void updateUser() {
        // ...
    }
}
```

#### **Вариант 2: Использование `AopContext.currentProxy()`**
Включите доступ к текущему прокси через `@EnableAspectJAutoProxy(exposeProxy = true)` и вызовите метод через него:
```java
@Service
public class UserService {
    public void createUser() {
        ((UserService) AopContext.currentProxy()).updateUser();
    }

    @Transactional
    public void updateUser() {
        // ...
    }
}
```

#### **Вариант 3: Вынесение метода в отдельный сервис**
Разделите логику на два разных класса, чтобы исключить self-invocation:
```java
@Service
public class UserService {
    @Autowired
    private UserHelper userHelper;

    public void createUser() {
        userHelper.updateUser(); // Вызов из другого класса -> прокси работает.
    }
}

@Service
public class UserHelper {
    @Transactional
    public void updateUser() {
        // ...
    }
}
```

#### **Вариант 4: Использование AspectJ вместо Spring AOP**
AspectJ не relies on проксирование и работает даже при self-invocation. Но это требует дополнительной настройки (например, загрузка аспектов во время компиляции или загрузки классов).

---

### 4. **Почему это важно?**
- **`@Transactional`**: Без прокси транзакция не откроется, и метод выполнится вне транзакционного контекста.
- **`@Cacheable`**: Результат не будет закэширован, и метод всегда будет выполняться.
- **`@Async`**, **`@Retryable`** и другие аннотации также перестают работать.

---

### 5. **Когда проблема не возникает?**
- Если вы вызываете метод **из другого бина**.
- Если используете **AspectJ** с режимом compile-time/load-time weaving.

---

### Итог
Self-invocation — это классическая проблема Spring AOP. Всегда проектируйте классы так, чтобы методы с AOP-аннотациями вызывались извне, либо используйте обходные маневры, like self-injection.