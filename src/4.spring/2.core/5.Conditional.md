## Внутренняя реализация `@Conditional` в Spring

### Основные компоненты механизма

**1. `ConditionEvaluator`** - центральный класс, отвечающий за оценку условий:
```java
public class ConditionEvaluator {
    public boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {
        // Получает все @Conditional аннотации
        // Создает экземпляры Condition классов
        // Вызывает метод matches() для каждого условия
    }
}
```

**2. Процесс обработки на разных уровнях:**

**Для конфигурационных классов** (`@Configuration`):
```java
public class ConfigurationClassParser {
    protected void processConfigurationClass(ConfigurationClass configClass) {
        // ConditionEvaluator проверяет, нужно ли пропускать весь класс
        if (this.conditionEvaluator.shouldSkip(configClass.getMetadata(), 
                ConfigurationPhase.PARSE_CONFIGURATION)) {
            return; // Пропускаем весь класс
        }
    }
}
```

**Для методов `@Bean`:**
```java
public class ConfigurationClassBeanDefinitionReader {
    private void loadBeanDefinitionsForBeanMethod(BeanMethod beanMethod) {
        if (this.conditionEvaluator.shouldSkip(beanMethod.getMetadata(), 
                ConfigurationPhase.REGISTER_BEAN)) {
            return; // Пропускаем метод @Bean
        }
    }
}
```

### Детальный процесс оценки условий

**1. Извлечение аннотаций `@Conditional`:**
```java
public class ConditionEvaluator {
    private List<Condition> getConditions(AnnotatedTypeMetadata metadata) {
        // Ищет аннотации @Conditional (включая мета-аннотации)
        MultiValueMap<String, Object> attributes = metadata
            .getAllAnnotationAttributes(Conditional.class.getName());
        
        // Создает экземпляры Condition классов через рефлексию
        List<Condition> conditions = new ArrayList<>();
        for (Object value : attributes.get("value")) {
            Class<?>[] conditionClasses = (Class<?>[]) value;
            for (Class<?> conditionClass : conditionClasses) {
                Condition condition = (Condition) 
                    BeanUtils.instantiateClass(conditionClass);
                conditions.add(condition);
            }
        }
        return conditions;
    }
}
```

**2. Полный алгоритм `shouldSkip`:**
```java
public boolean shouldSkip(AnnotatedTypeMetadata metadata, ConfigurationPhase phase) {
    // Если нет аннотаций @Conditional - не пропускаем
    if (metadata == null || !metadata.isAnnotated(Conditional.class.getName())) {
        return false;
    }
    
    // Получаем все условия
    List<Condition> conditions = getConditions(metadata);
    
    // Оцениваем каждое условие
    for (Condition condition : conditions) {
        ConfigurationPhase requiredPhase = null;
        if (condition instanceof ConfigurationCondition) {
            requiredPhase = ((ConfigurationCondition) condition).getConfigurationPhase();
        }
        
        // Проверяем фазу выполнения
        if (requiredPhase == null || requiredPhase == phase) {
            if (!condition.matches(this.context, metadata)) {
                return true; // Условие не выполнено - пропускаем
            }
        }
    }
    return false; // Все условия выполнены - не пропускаем
}
```

### Интеграция с Bean Factory

**Обработка в `AnnotatedBeanDefinitionReader`:**
```java
public class AnnotatedBeanDefinitionReader {
    private <T> void doRegisterBean(Class<T> beanClass, String name, 
            Class<? extends Annotation>[] qualifiers, Supplier<T> supplier) {
        
        AnnotatedGenericBeanDefinition abd = new AnnotatedGenericBeanDefinition(beanClass);
        
        // Проверка условий перед регистрацией
        if (this.conditionEvaluator.shouldSkip(abd.getMetadata())) {
            return; // Пропускаем регистрацию бина
        }
        
        // Регистрируем бин, если условия выполнены
        BeanDefinitionHolder definitionHolder = new BeanDefinitionHolder(abd, beanName);
        BeanDefinitionReaderUtils.registerBeanDefinition(definitionHolder, this.registry);
    }
}
```

### Пример полного цикла обработки

**1. Исходный код:**
```java
@Configuration
@Conditional(MyCustomCondition.class)
public class AppConfig {
    
    @Bean
    @Conditional(AnotherCondition.class)
    public MyService myService() {
        return new MyService();
    }
}
```

**2. Процесс обработки:**
```java
// Шаг 1: Парсинг конфигурационного класса
ConfigurationClassParser parser = new ConfigurationClassParser();
parser.parse(Collections.singleton(AppConfig.class));

// Шаг 2: Для класса AppConfig вызывается:
ConditionEvaluator evaluator = new ConditionEvaluator(registry, environment, resourceLoader);
boolean skipClass = evaluator.shouldSkip(appConfigMetadata, ConfigurationPhase.PARSE_CONFIGURATION);

// Шаг 3: Если класс не пропущен, парсим методы @Bean
for (Method method : AppConfig.class.getMethods()) {
    if (method.isAnnotationPresent(Bean.class)) {
        boolean skipMethod = evaluator.shouldSkip(methodMetadata, ConfigurationPhase.REGISTER_BEAN);
        if (!skipMethod) {
            // Регистрируем BeanDefinition для метода
        }
    }
}
```

### Особенности реализации

**1. Кэширование результатов:**
```java
// ConditionEvaluator кэширует результаты оценки условий
// для оптимизации производительности

// В ConditionContext предоставляется:
- BeanFactory (для проверки существующих бинов)
- Environment (для доступа к properties)
- ResourceLoader (для работы с ресурсами)
- ClassLoader (для проверки наличия классов)
```

**2. Две фазы выполнения:**
```java
public enum ConfigurationPhase {
    PARSE_CONFIGURATION,    // Для @Configuration классов
    REGISTER_BEAN           // Для @Bean методов
}
```

**3. Поддержка мета-аннотаций:**
```java
// Spring ищет не только прямые @Conditional аннотации,
// но и мета-аннотации (например, @ConditionalOnClass)
```

### Производительность и оптимизации

- **Lazy-инициализация**: Условия оцениваются только при необходимости
- **Кэширование**: Результаты оценки условий кэшируются
- **Ранний выход**: При первом невыполненном условии оценка прекращается

Этот механизм обеспечивает гибкость и производительность, позволяя Spring эффективно управлять конфигурацией приложения на основе различных условий среды выполнения.