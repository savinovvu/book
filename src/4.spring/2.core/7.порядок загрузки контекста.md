Порядок загрузки контекста в Spring Framework — это критически важный аспект для понимания работы приложения. Вот детальное объяснение с точки зрения Senior-разработчика:

### 1. **Инициализация контекста**
- **Ключевые точки:**
    - Контекст загружается при старте приложения (например, через `AnnotationConfigApplicationContext`, `ClassPathXmlApplicationContext` или в веб-приложении — `XmlWebApplicationContext`).
    - Для Spring Boot используется `SpringApplication.run()`, который внутри создает `ApplicationContext`.

### 2. **Этапы загрузки контекста**
#### **Этап 1: Парсинг конфигурации**
- **Annotation-based конфигурация:** Сканируются пакеты на наличие `@Component`, `@Service`, `@Repository` и других стереотипных аннотаций.
- **XML-based конфигурация:** Парсится XML-файл, определяются бины и их зависимости.
- **Java-based конфигурация:** Читаются классы, помеченные `@Configuration`, анализируются методы с `@Bean`.

#### **Этап 2: Создание Bean Definitions**
- На основе конфигурации создаются `BeanDefinition` — метаинформация о бинах (класс, scope, ленивая ли инициализация, зависимости и т.д.).
- `BeanDefinitionRegistry` регистрирует эти определения.

#### **Этап 3: Обработка BeanFactoryPostProcessor**
- Spring применяет все `BeanFactoryPostProcessor` (например, `PropertySourcesPlaceholderConfigurer` для подстановки `${...}` значений из properties-файлов).
- Здесь можно модифицировать `BeanDefinition` до создания экземпляров бинов.

#### **Этап 4: Создание экземпляров бинов**
- Бины инстанциируются в порядке их зависимостей. Сначала создаются бины, которые требуются другим бинам как зависимости.
- **Важно:** Бины с singleton scope и без ленивой инициализации создаются на этом этапе.

#### **Этап 5: Заполнение свойств (Dependency Injection)**
- Через конструктор, сеттеры или поля (с помощью `@Autowired`) внедряются зависимости.
- Если зависимость еще не создана, Spring рекурсивно инициирует ее создание.

#### **Этап 6: Обработка BeanPostProcessor**
- Срабатывают `BeanPostProcessor` — например, `AutowiredAnnotationBeanPostProcessor` для `@Autowired`, `CommonAnnotationBeanPostProcessor` для `@PostConstruct`.
- **Два метода:**
    1. `postProcessBeforeInitialization` — перед инициализацией бина.
    2. `postProcessAfterInitialization` — после инициализации.

#### **Этап 7: Инициализация бинов**
- Вызываются методы, помеченные `@PostConstruct`.
- Реализации `InitializingBean.afterPropertiesSet()`.
- Кастомные методы init, указанные в `@Bean(initMethod = "...")`.

#### **Этап 8: Контекст готов**
- `ApplicationContext` полностью инициализирован. Бины готовы к использованию.
- Для веб-приложений публикуется событие `ContextRefreshedEvent`.

### 3. **Важные нюансы**
- **Порядок создания бинов:** Зависит от графа зависимостей. Циклические зависимости разрешаются через механизм прокси (при использовании `@Autowired` через поля).
- **Lazy-бины:** С `@Lazy` создаются только при первом обращении, что меняет порядок инициализации.
- **Profile-специфичные бины:** Загружаются только если активен соответствующий профиль.
- **Conditional бины:** Создаются только при выполнении условий (`@ConditionalOnClass`, `@ConditionalOnProperty` и т.д.).

### 4. **Пример для Spring Boot**
```java
@SpringBootApplication
public class App {
    public static void main(String[] args) {
        // 1. Запуск приложения: сканирование пакетов, создание контекста
        ConfigurableApplicationContext context = SpringApplication.run(App.class, args);
        
        // 2. Контекст готов, можно получить бины
        MyService service = context.getBean(MyService.class);
        service.doSomething();
    }
}
```

### 5. **Типичные проблемы и решения**
- **Циклические зависимости:** Используйте `@Lazy`, setter-инъекцию или рефакторинг.
- **Порядок инициализации:** Для явного указания порядка используйте `@DependsOn`, `@Order` или `@Priority`.
- **Кастомная логика инициализации:** Реализуйте `BeanPostProcessor` или `Lifecycle` интерфейсы.

### 6. **Отладка загрузки контекста**
- Включите логирование Spring (`logging.level.org.springframework=DEBUG`).
- Используйте `SpringApplicationBuilder.listeners(...)` для отслеживания событий жизненного цикла.

Понимание этих этапов позволяет предвидеть проблемы, оптимизировать запуск приложения и правильно использовать возможности Spring.