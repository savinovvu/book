Выбор механизма прокси в Spring напрямую влияет на возможность применения аспектов к **final классам и методам**. Рассмотрим детали:

### 1. **Типы прокси в Spring**
- **JDK Dynamic Proxies** (стандарт для Spring AOP по умолчанию, если целевой класс реализует интерфейсы):
    - Создают прокси на основе интерфейсов.
    - **Не могут** переопределить методы final классов, так как используют композицию через реализацию интерфейсов.
    - Final методы и классы **игнорируются** — аспекты к ним не применяются.

- **CGLIB/ByteBuddy прокси** (активируются через `proxyTargetClass = true`):
    - Создают прокси путем **наследования** от целевого класса.
    - **Не работают с final классами**, так как от них нельзя унаследовать подкласс.
    - **Не могут переопределить final методы** — эти методы остаются без аспектов (например, `@Transactional`, `@Cacheable`).

---

### 2. **Практические последствия**
- **Final классы**:
    - Если класс объявлен как `final`, CGLIB не сможет создать прокси. Это вызовет исключение на этапе запуска контекста Spring.
    - Пример: `BeanCreationException` с сообщением "Cannot subclass final class".

- **Final методы**:
    - Даже если класс проксируется через CGLIB, final методы остаются неизменными в прокси. Аннотации AOP (например, `@Transactional`) на таких методах **игнорируются**.
    - Пример: Вызов final метода с `@Transactional` не откроет транзакцию.

---

### 3. **Примеры**
#### Случай 1: Final класс
```java
final class UserService { // CGLIB не сможет создать прокси
    public void process() { ... }
}
```
**Ошибка**:  
`Cannot proxy final class UserService with CGLIB`.

#### Случай 2: Final метод
```java
@Component
class UserService {
    @Transactional
    public final void updateUser() { ... } // Аспект @Transactional не применится
}
```
**Результат**: При вызове `updateUser()` транзакция **не активируется**.

---

### 4. **Как избежать проблем?**
- **Избегайте final для классов и методов**, если нужны Spring AOP или декларативные транзакции.
- Используйте **интерфейсы и JDK прокси** для классов с final методами (если final методы не входят в интерфейс).
- Для CGLIB убедитесь, что:
    - Классы не final.
    - Методы, требующие аспектов, не final.
    - Включен режим `proxyTargetClass = true` (например, в `@EnableAspectJAutoProxy`).

---

### 5. **Важные нюансы**
- **Self-invocation** (внутренние вызовы методов):  
  Даже не-final методы не будут перехвачены прокси, если вызываются изнутри класса (например, через `this.method()`). Решение — использование `AspectJ` (mode = ASPECTJ) или инжекции прокси самого в себя.
- **Spring Boot 2.x+**:  
  По умолчанию использует CGLIB, поэтому final классы/методы сразу становятся проблемой.

---

### Итог
- **JDK Dynamic Proxies**: Не затрагивают final методы/классы, но не применяют аспекты к ним.
- **CGLIB**: Требуют отсутствия final у классов и методов, иначе аспекты не работают.

Всегда проверяйте, что классы и методы, к которым применяются Spring AOP, **не являются final**.