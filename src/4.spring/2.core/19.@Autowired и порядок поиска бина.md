**@Autowired в Spring** — это аннотация для автоматического связывания (dependency injection) зависимостей. Spring ищет подходящий бин и внедряет его в поле, конструктор или метод. Порядок поиска бина определяется следующими правилами:

---

### **1. Поиск по типу (Type)**
Spring сначала ищет бины по **типу** (класс/интерфейс) поля/параметра.  
Пример:
```java
@Autowired
private UserRepository userRepository;
```
Spring проверит контекст на наличие бина типа `UserRepository`.

---

### **2. Разрешение неоднозначности (Multiple Beans)**
Если найдено несколько бинов одного типа, Spring использует приоритеты в следующем порядке:

#### **Шаг 1: Аннотация `@Primary`**
Бин с аннотацией `@Primary` получает высший приоритет.
```java
@Primary
@Component
class JpaUserRepository implements UserRepository { ... }
```

#### **Шаг 2: Аннотация `@Qualifier`**
Если `@Primary` отсутствует, используется `@Qualifier` для явного указания имени бина.
```java
@Autowired
@Qualifier("jdbcUserRepository")
private UserRepository userRepository;
```

#### **Шаг 3: Имя поля/параметра**
Если `@Qualifier` не указан, Spring пытается сопоставить **имя поля** с именем бина (например, поле `jdbcUserRepository` будет связано с бином `jdbcUserRepository`).

---

### **3. Поиск по имени (Fallback to Name)**
Если тип не подходит, Spring ищет бин по **имени поля**.  
Пример:
```java
@Autowired
private UserRepository myCustomRepo; // Ищет бин с именем "myCustomRepo"
```

---

### **4. Если бин не найден**
- По умолчанию `@Autowired` требует зависимость. Если бин отсутствует, будет выброшено `NoSuchBeanDefinitionException`.
- Чтобы сделать зависимость опциональной, используйте `required = false`:
  ```java
  @Autowired(required = false)
  private Optional<UserRepository> userRepository;
  ```

---

### **Порядок поиска в виде алгоритма:**
1. **Поиск по типу**.
2. Если найдено несколько бинов:
    - Использовать `@Primary`.
    - Использовать `@Qualifier`.
    - Сопоставить имя поля с именем бина.
3. Если бин не найден — исключение (если `required = true`).

---

### **Дополнительные нюансы**
- **Конструкторы**: `@Autowired` на конструкторе позволяет внедрять зависимости через параметры. Если конструктор один — аннотацию можно опустить (начиная с Spring 4.3).
- **Коллекции**: Если тип зависимости — `List<SomeInterface>`, Spring внедрит **все** бины, реализующие `SomeInterface`.
- **Порядок бинов в коллекции**: Определяется аннотацией `@Order` или реализацией `Ordered`.

---

### **Пример с несколькими бинами**
```java
@Component
class ServiceImpl1 implements ServiceInterface { ... }

@Component
class ServiceImpl2 implements ServiceInterface { ... }

@Component
public class Client {
    // Вызовет ошибку из-за неоднозначности!
    @Autowired
    private ServiceInterface service; 
}
```
**Решения:**
1. Использовать `@Primary` на одном из бинов.
2. Указать `@Qualifier("impl1")` на бине и в точке внедрения.
3. Переименовать поле: `private ServiceInterface serviceImpl1`.

---

**Итог:** Spring сочетает тип, аннотации и имена для разрешения зависимостей. Понимание этого порядка критично для решения конфликтов при внедрении.