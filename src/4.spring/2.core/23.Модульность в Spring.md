Организация модульности в Spring — ключевой навык для Senior-разработчика. Рассмотрим продвинутые подходы:

## 1. Разделение на @Configuration классы

### Базовое разделение по функциональности
```java
// Главная конфигурация
@Configuration
@Import({PersistenceConfig.class, ServiceConfig.class, WebConfig.class})
public class AppConfig {
    // Импортирует все модули
}

// Модуль работы с данными
@Configuration
@EnableJpaRepositories(basePackages = "com.example.repository")
@EnableTransactionManagement
public class PersistenceConfig {
    
    @Bean
    @ConfigurationProperties("spring.datasource")
    public DataSource dataSource() {
        return DataSourceBuilder.create().build();
    }
    
    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        // Конфигурация JPA
    }
}

// Модуль бизнес-логики
@Configuration
@ComponentScan(basePackages = "com.example.service")
public class ServiceConfig {
    
    @Bean
    public SomeService someService() {
        return new SomeServiceImpl();
    }
}

// Web модуль
@Configuration
@EnableWebMvc
@ComponentScan(basePackages = "com.example.controller")
public class WebConfig implements WebMvcConfigurer {
    // Конфигурация MVC
}
```

## 2. Условная загрузка модулей

### Использование @Conditional аннотаций
```java
@Configuration
@ConditionalOnClass(name = "com.thirdparty.SomeExternalService")
@ConditionalOnProperty(name = "app.feature.external.enabled", havingValue = "true")
public class ExternalServiceConfig {
    
    @Bean
    @ConditionalOnMissingBean
    public ExternalService externalService() {
        return new ExternalServiceImpl();
    }
}

@Configuration
@ConditionalOnExpression("${app.feature.cache.enabled:true} && ${app.feature.cache.type} == 'redis'")
public class RedisCacheConfig {
    
    @Bean
    public CacheManager cacheManager(RedisConnectionFactory factory) {
        return RedisCacheManager.create(factory);
    }
}

@Configuration
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
public class WebSecurityConfig extends WebSecurityConfigurerAdapter {
    // Конфигурация безопасности только для web приложений
}
```

### Кастомные условия
```java
public class DatabaseTypeCondition implements Condition {
    @Override
    public boolean matches(ConditionContext context, AnnotatedTypeMetadata metadata) {
        String dbType = context.getEnvironment().getProperty("app.database.type", "h2");
        Map<String, Object> attributes = metadata.getAnnotationAttributes(DatabaseType.class.getName());
        return attributes != null && attributes.get("value").equals(dbType);
    }
}

@Target({ElementType.TYPE, ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Conditional(DatabaseTypeCondition.class)
public @interface DatabaseType {
    String value();
}

@Configuration
@DatabaseType("postgresql")
public class PostgresConfig {
    // Конфигурация для PostgreSQL
}
```

## 3. Модульность через профили

```java
@Configuration
@Profile("dev")
public class DevConfig {
    
    @Bean
    public DataSource devDataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

@Configuration
@Profile("prod")
public class ProdConfig {
    
    @Bean
    @ConfigurationProperties("app.datasource.prod")
    public DataSource prodDataSource() {
        return DataSourceBuilder.create().build();
    }
}

@Configuration
@Profile("cloud")
public class CloudConfig {
    
    @Bean
    @ConditionalOnCloudPlatform(CloudPlatform.CLOUD_FOUNDRY)
    public ServiceConnectorCreator<DataSource, DataSourceConfig> cloudDataSource() {
        // Cloud-specific configuration
    }
}
```

## 4. Автоконфигурация и модули

### Создание Spring Boot Starter
```java
// В файле META-INF/spring.factories
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.example.mystarter.MyAutoConfiguration

@Configuration
@ConditionalOnClass(SomeFeature.class)
@EnableConfigurationProperties(MyStarterProperties.class)
@AutoConfigureAfter(SomeOtherConfiguration.class)
public class MyAutoConfiguration {
    
    @Bean
    @ConditionalOnMissingBean
    public SomeFeature someFeature(MyStarterProperties properties) {
        return new SomeFeature(properties);
    }
}

@ConfigurationProperties("app.my-starter")
public class MyStarterProperties {
    private boolean enabled = true;
    private String endpoint;
    // геттеры и сеттеры
}
```

## 5. Динамическая загрузка модулей

```java
@Configuration
public class DynamicModuleConfig {
    
    @Bean
    public ModuleRegistry moduleRegistry() {
        return new ModuleRegistry();
    }
    
    @Bean
    @ConditionalOnBean(ModuleRegistry.class)
    public ModuleManager moduleManager(ModuleRegistry registry, 
                                     ApplicationContext context) {
        return new ModuleManager(registry, context);
    }
}

@Component
public class ModuleManager {
    private final ModuleRegistry registry;
    private final ApplicationContext context;
    
    public void enableModule(String moduleName) {
        // Логика включения модуля
        registry.enableModule(moduleName);
        refreshContext();
    }
    
    public void disableModule(String moduleName) {
        // Логика выключения модуля
        registry.disableModule(moduleName);
        refreshContext();
    }
}
```

## 6. Event-driven модульность

```java
@Configuration
public class EventModuleConfig {
    
    @Bean
    public ApplicationEventMulticaster applicationEventMulticaster() {
        SimpleApplicationEventMulticaster eventMulticaster = new SimpleApplicationEventMulticaster();
        eventMulticaster.setTaskExecutor(taskExecutor());
        return eventMulticaster;
    }
    
    @Bean
    public TaskExecutor taskExecutor() {
        return new SimpleAsyncTaskExecutor();
    }
}

// Модуль, реагирующий на события
@Component
public class NotificationModule {
    
    @EventListener
    @Async
    public void handleUserRegistered(UserRegisteredEvent event) {
        // Обработка события асинхронно
    }
    
    @EventListener(condition = "#event.priority == 'HIGH'")
    public void handleHighPriority(AlertEvent event) {
        // Обработка только high-priority событий
    }
}
```

## 7. Best Practices для Senior

### Четкое разделение ответственности
```java
@Configuration
@EnableConfigurationProperties({
    DatabaseProperties.class,
    CacheProperties.class,
    SecurityProperties.class
})
@Import({
    DatabaseModuleConfig.class,
    CacheModuleConfig.class, 
    SecurityModuleConfig.class,
    BusinessLogicModuleConfig.class
})
public class ModularApplicationConfig {
    // Импортирует все четко разделенные модули
}
```

### Тестирование модулей
```java
@SpringBootTest
@TestPropertySource(properties = {
    "app.feature.cache.enabled=true",
    "app.feature.external.enabled=false"
})
@Import({CacheConfig.class, MockExternalServiceConfig.class})
class ModularApplicationTest {
    
    @Autowired
    private CacheManager cacheManager;
    
    @Autowired
    @Qualifier("mockExternalService")
    private ExternalService externalService;
    
    @Test
    void testModuleConfiguration() {
        assertThat(cacheManager).isNotNull();
        assertThat(externalService).isInstanceOf(MockExternalService.class);
    }
}
```

### Конфигурация через свойства
```yaml
# application.yml
app:
  modules:
    cache:
      enabled: true
      type: redis
    messaging:
      enabled: false  
    security:
      enabled: true
      mode: jwt
```

Эти подходы позволяют создавать гибкие, поддерживаемые и тестируемые модульные приложения на Spring, соответствующие уровню Senior разработчика.