Для организации конфигурации в Spring-приложениях используются комбинированные подходы в зависимости от сложности системы. Рассмотрим ключевые методы:

---

### 1. **Профили Spring (`@Profile`)**
Профили позволяют изолировать конфигурации для разных окружений.

**Пример:**
```java
@Configuration
@Profile("dev")
public class DevConfig {
    @Bean
    public DataSource dataSource() {
        return new EmbeddedDatabaseBuilder()
            .setType(EmbeddedDatabaseType.H2)
            .build();
    }
}

@Configuration
@Profile({"staging", "prod"})
public class ProdConfig {
    @Bean
    public DataSource dataSource() {
        // Настройка DataSource для Production
        return DataSourceBuilder.create().build();
    }
}
```

**Активация профиля:**
- Через VM-опцию: `-Dspring.profiles.active=dev`
- В `application.properties`: `spring.profiles.active=dev,debug`

---

### 2. **Файлы свойств и `@PropertySource`**
Используются для загрузки специфичных для окружения property-файлов.

**Структура файлов:**
```
src/main/resources/
  application-dev.properties
  application-staging.properties
  application-prod.properties
```

**Пример:**
```java
@Configuration
@PropertySource("classpath:application-${spring.profiles.active}.properties")
public class AppConfig {
    @Value("${db.url}")
    private String dbUrl;
}
```

**Резолвинг свойств:**
```java
@Bean
public static PropertySourcesPlaceholderConfigurer propertyConfig() {
    return new PropertySourcesPlaceholderConfigurer();
}
```

---

### 3. **Spring Cloud Config (для Senior+)**
Централизованное управление конфигурацией через Config Server.

**Config Server:**
```java
@SpringBootApplication
@EnableConfigServer
public class ConfigServerApp {
    public static void main(String[] args) {
        SpringApplication.run(ConfigServerApp.class, args);
    }
}
```

**Конфигурация сервера (`application.yml`):**
```yaml
spring:
  cloud:
    config:
      server:
        git:
          uri: https://github.com/myorg/config-repo
          search-paths: '{application}/{profile}'
```

**Клиентская сторона:**
- **bootstrap.yml:**
  ```yaml
  spring:
    application:
      name: my-service
    cloud:
      config:
        uri: http://config-server:8888
        profile: ${SPRING_PROFILES_ACTIVE:dev}
  ```

- **Динамическое обновление:**  
  Используйте `@RefreshScope` для обновления бинов без перезапуска:
  ```java
  @RestController
  @RefreshScope
  public class MessageController {
      @Value("${app.message}")
      private String message;
  }
  ```

---

### 4. **Дополнительные практики**
- **Иерархия свойств:** Spring Boot автоматически загружает `application-{profile}.properties` из classpath и текущей директории.
- **Docker-совместимость:**  
  Переопределяйте свойства через переменные окружения:
  ```yaml
  environment:
    - SPRING_PROFILES_ACTIVE=prod
    - SPRING_CLOUD_CONFIG_URI=http://config-server:8888
  ```
- **Шифрование:**  
  В Spring Cloud Config используйте `/encrypt` и `/decrypt` endpoints для защиты чувствительных данных.

---

### 5. **Безопасность (Senior+)**
- Настройте аутентификацию Config Server через Spring Security.
- Используйте Vault или KMS для хранения секретов.
- Шифруйте чувствительные свойства (например, пароли БД).

---

**Итог:**
- Для простых проектов: **Профили + `@PropertySource`**.
- Для микросервисных архитектур: **Spring Cloud Config** с резервными профилями.
- Всегда используйте **иммутабельные конфигурации** и избегайте хранения секретов в репозитории.