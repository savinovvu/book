Для реализации retry и circuit breaker в Spring-приложении можно использовать два основных подхода: **Spring Retry** и **Resilience4j**. Оба инструмента интегрируются с Spring и предоставляют аннотации для декларативной настройки. Рассмотрим оба варианта.

---

### 1. Spring Retry
**Spring Retry** предоставляет простой способ добавить повторные попытки вызовов методов.

#### Настройка:
1. **Добавление зависимостей** (Maven):
```xml
<dependency>
    <groupId>org.springframework.retry</groupId>
    <artifactId>spring-retry</artifactId>
    <version>2.0.0</version>
</dependency>
<dependency>
    <groupId>org.springframework</groupId>
    <artifactId>spring-aspects</artifactId>
</dependency>
```

2. **Включение Retry в приложении**:
   Добавьте `@EnableRetry` в главный класс или конфигурацию:
```java
@SpringBootApplication
@EnableRetry
public class Application { ... }
```

3. **Использование**:
   Примените `@Retryable` к методу, который требует повторных попыток, и `@Recover` для метода-фолбэка.
```java
@Service
public class ExternalService {
    
    @Retryable(
        value = {RestClientException.class}, // Повторять при этих исключениях
        maxAttempts = 3,                    // Максимум 3 попытки
        backoff = @Backoff(delay = 1000)    // Задержка 1 секунда
    )
    public String callExternalService() {
        // Логика вызова внешнего сервиса
        return restTemplate.getForObject("https://api.example.com", String.class);
    }

    @Recover
    public String fallback(RestClientException e) {
        return "Fallback response";
    }
}
```

---

### 2. Resilience4j
**Resilience4j** — это более современная библиотека, предлагающая circuit breaker, retry, rate limiter и другие паттерны. Она хорошо интегрируется с Spring Boot.

#### Настройка Retry и Circuit Breaker:
1. **Добавление зависимостей** (Maven):
```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-spring-boot2</artifactId>
    <version>2.1.0</version>
</dependency>
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-aop</artifactId>
</dependency>
```

2. **Конфигурация в `application.yml`**:
```yaml
resilience4j:
  circuitbreaker:
    instances:
      externalService:
        failureRateThreshold: 50    # % ошибок для перехода в OPEN
        waitDurationInOpenState: 10s # Время в OPEN перед переходом в HALF_OPEN
        slidingWindowSize: 10        # Размер окна для анализа ошибок
  retry:
    instances:
      externalService:
        maxAttempts: 3               # Количество попыток
        waitDuration: 1s             # Задержка между попытками
```

3. **Использование аннотаций**:
```java
@Service
public class ExternalService {
    
    @CircuitBreaker(name = "externalService", fallbackMethod = "fallback")
    @Retry(name = "externalService", fallbackMethod = "fallback")
    public String callExternalService() {
        // Логика вызова внешнего сервиса
        return restTemplate.getForObject("https://api.example.com", String.class);
    }

    public String fallback(Exception e) {
        return "Fallback response";
    }
}
```

---

### 3. Комбинирование Retry и Circuit Breaker
- **Retry** повторяет запросы при временных сбоях.
- **Circuit Breaker** предотвращает повторные запросы, когда сервис недоступен.

**Важно**:
- Circuit Breaker должен быть применен **вне** retry, чтобы избежать повторных попыток при открытом circuit breaker.
- В Resilience4j это достигается порядком аннотаций: `@CircuitBreaker` применяется до `@Retry`.

Пример:
```java
@CircuitBreaker(name = "externalService", fallbackMethod = "circuitBreakerFallback")
@Retry(name = "externalService", fallbackMethod = "retryFallback")
public String callExternalService() {
    // Логика вызова
}

public String circuitBreakerFallback(Exception e) {
    return "Circuit breaker opened!";
}

public String retryFallback(Exception e) {
    return "All retry attempts failed";
}
```

---

### 4. Ручная настройка Resilience4j (без аннотаций)
Для большего контроля можно настроить компоненты программно:
```java
@Bean
public CircuitBreakerConfig circuitBreakerConfig() {
    return CircuitBreakerConfig.custom()
        .failureRateThreshold(50)
        .waitDurationInOpenState(Duration.ofSeconds(10))
        .slidingWindowSize(10)
        .build();
}

@Bean
public RetryConfig retryConfig() {
    return RetryConfig.custom()
        .maxAttempts(3)
        .waitDuration(Duration.ofSeconds(1))
        .build();
}
```

---

### Рекомендации:
1. **Spring Retry** подходит для простых сценариев с базовыми retry-стратегиями.
2. **Resilience4j** предлагает больше возможностей для тонкой настройки и мониторинга (например, через Micrometer).
3. Всегда тестируйте поведение приложения при сбоях (например, с помощью **WireMock**).
4. Используйте **fallback-методы** для возврата заглушек или кешированных данных.

Пример полной конфигурации Resilience4j с метриками и мониторингом можно найти в [официальной документации](https://resilience4j.readme.io/docs).