Отличный вопрос! Это одна из классических тем на собеседованиях для Spring-разработчиков. Давайте разберем все по полочкам.

Все три аннотации — `@Component`, `@Service` и `@Repository` — являются **стереотипными аннотациями** (stereotype annotations) и на техническом уровне **ведут себя одинаково**. Любой Spring Bean, помеченный одной из них, будет обнаружен при сканировании компонентов и зарегистрирован в контексте приложения.

**Ключевая разница заключается в семантике и дополнительном поведении.**

### Обзор в виде таблицы

| Аннотация | Уровень | Назначение | Дополнительное поведение |
| :--- | :--- | :--- | :--- |
| **`@Component`** | Общий | Универсальная аннотация для любого класса, которым управляет Spring. | Нет. Базовый "строительный блок". |
| **`@Service`** | Сервисный (Бизнес-слой) | Обозначает класс, содержащий **бизнес-логику**, вычислительные задачи. | **Семантическое**. Указывает разработчикам на назначение класса. |
| **`@Repository`** | Персистентный (Слой Данных) | Обозначает класс, который работает с источниками данных (БД, файлы, etc.). | **Практическое**. **Автоматическая трансляция исключений** в `DataAccessException`. |

---

### Детальное объяснение

#### 1. `@Component` (Базовый кирпичик)

Это самая общая аннотация. Spring регистрирует класс, помеченный ею, как бин. Аннотации `@Service` и `@Repository` сами помечены аннотацией `@Component` (являются ее специализацией).

```java
@Component
public class SimpleMapper {
    // Простой вспомогательный компонент
}
```

**Когда использовать?** Для любых классов, которые не явно подпадают под категории сервиса или репозитория (например, хелперы, кастомные мапперы, утилитные классы).

#### 2. `@Service` (Слой бизнес-логики)

Эта аннотация — **семантический специализированный вариант `@Component`**. Она не добавляет никакой новой функциональности. Ее цель — **четко обозначить намерение разработчика**.

Классы, помеченные `@Service`, содержат основную бизнес-логику приложения, orchestrate-вызовы к репозиториям, могут применять транзакции и т.д.

```java
@Service
public class UserService {

    private final UserRepository userRepository;

    // Инъекция через конструктор
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    // Бизнес-метод: не просто сохраняет, а может делать валидацию, отправлять события и т.д.
    public User createUser(String username, String email) {
        // Проверка бизнес-правил...
        if (userRepository.existsByUsername(username)) {
            throw new UserAlreadyExistsException("Username is taken");
        }
        // Создание сущности...
        User user = new User(username, email);
        // Вызов репозитория для сохранения
        return userRepository.save(user);
    }
}
```

**Когда использовать?** Всегда, когда ваш класс реализует бизнес-логику.

#### 3. `@Repository` (Слой доступа к данным)

Это самая "интересная" аннотация из трех, потому что она, в отличие от `@Service`, добавляет **реальное дополнительное поведение**.

1.  **Автоматическая трансляция исключений (Ваш вопрос!)**
    Классы, помеченные `@Repository`, получают бонус в виде автоматического перехвата всех исключений, специфичных для конкретной технологии доступа к данным (JDBC, JPA/Hibernate, MyBatis), и преобразования их в непроверяемые (unchecked) исключения Spring'а из иерархии `DataAccessException`.

    *   **Без `@Repository`:** Если в вашем DAO-классе, использующем JPA, вылетит `PersistenceException`, оно пробросится выше без изменений.
    *   **С `@Repository`:** Spring "обернет" ваш бин в прокси, который перехватит это `PersistenceException` и преобразует его, например, в `DataIntegrityViolationException` (подкласс `DataAccessException`).

    **Зачем это нужно?**
    *   **Декомпозиция:** Ваш сервисный слой становится независимым от конкретной технологии хранения данных (вы работаете с универсальными `DataAccessException`). Сегодня используете JPA, завтра — MongoDB — сервисный слой не заметит разницы.
    *   **Удобство:** Вам не нужно объявлять все эти исключения в `throws` или оборачивать их в `try-catch`.

2.  **Семантика**
    Как и `@Service`, она четко указывает на роль класса в архитектуре — это класс для работы с данными.

```java
@Repository
public class JpaUserRepository implements UserRepository {

    @PersistenceContext
    private EntityManager entityManager;

    @Override
    public User save(User user) {
        // Если здесь произойдет PersistenceException (например, нарушение уникальности),
        // Spring перехватит ее и преобразует в DataAccessException.
        entityManager.persist(user);
        return user;
    }

    @Override
    public boolean existsByUsername(String username) {
        // ... выполнение запроса с помощью JPA...
    }
}
```

**Когда использовать?** Всегда для классов, которые непосредственно взаимодействуют с источником данных (выполняют SQL-запросы, обращаются к JPA, работают с No-клиентами).

---

### Итог для Spring Senior

1.  **Все они — `@Component`.** Это основа.
2.  **`@Service` и `@Repository` — это семантические "алиасы"** для `@Component`, которые помогают структурировать приложение по слоям (архитектура).
3.  **`@Repository` — единственная, кто дает реальное преимущество "из коробки"** — магию с трансляцией исключений. Это реализуется с помощью пост-обработчика бинов `PersistentExceptionTranslationPostProcessor`, который автоматически подключается при использовании, например, `@EnableJpaRepositories`.
4.  **Правильный выбор аннотации — это про чистоту кода и следование принципам Domain-Driven Design (DDD) или многослойной архитектуре.** Это делает код самодокументируемым и облегчает его поддержку.

**Ошибочное использование**, например, пометить `@Service` класс доступа к БД, не является критической ошибкой и приложение будет работать, но вы:
*   Потеряете удобную трансляцию исключений (для `@Repository`).
*   Введете в заблуждение других разработчиков, которые будут читать ваш код.