Для мокирования бинов в Spring-тестах используются аннотации **`@MockBean`** и **`@SpyBean`** из Spring Boot Test. Вот как их правильно применять:

---

### 1. **`@MockBean`**
Создает **полный мок** бина с помощью Mockito. Все методы по умолчанию возвращают «пустые» значения (null, 0, false), если поведение не задано явно.

**Пример:**
```java
@SpringBootTest
class UserServiceTest {

    @MockBean
    private UserRepository userRepository; // Заменяет реальный бин моком

    @Autowired
    private UserService userService;

    @Test
    void getUser_ShouldReturnUser() {
        // Задаем поведение мока
        Mockito.when(userRepository.findByName("Ivan"))
               .thenReturn(new User("Ivan", "ivan@example.com"));

        User result = userService.getUser("Ivan");

        assertThat(result.getEmail()).isEqualTo("ivan@example.com");
        Mockito.verify(userRepository).findByName("Ivan"); // Проверяем вызов
    }
}
```

**Когда использовать:**
- Когда нужно **полностью заменить** бин мок-объектом.
- Для изоляции тестируемого компонента от зависимостей (например, базы данных, внешних API).

---

### 2. **`@SpyBean`**
Создает **шпион (spy)** на реальном бине. Вызовы методов идут на реальный объект, но позволяют:
- Подменить поведение отдельных методов.
- Проверить, как вызывались методы (количество вызовов, аргументы).

**Пример:**
```java
@SpringBootTest
class NotificationServiceTest {

    @SpyBean
    private EmailSender emailSender; // Шпионим за реальным бинном

    @Autowired
    private NotificationService notificationService;

    @Test
    void sendNotification_ShouldLogAndSendEmail() {
        // Подменяем метод send, но другие методы работают как обычно
        Mockito.doNothing().when(emailSender).send(Mockito.anyString());

        notificationService.sendNotification("Hello!");

        // Проверяем, что метод был вызван с правильным аргументом
        Mockito.verify(emailSender).send("Hello!");
    }
}
```

**Когда использовать:**
- Когда нужно **частично заменить** поведение бина, сохранив логику остальных методов.
- Для проверки взаимодействий с реальным бинном.

---

### Ключевые особенности:
1. **Контекст приложения**:
    - `@MockBean` и `@SpyBean` автоматически регистрируют моки/шпионы в Spring-контексте.
    - Если бин уже существует, он **заменяется** моком/шпионом.

2. **Очистка контекста**:
    - Моки и шпионы **сбрасываются** между тестами (через `@DirtiesContext`), что может замедлить тесты. Старайтесь использовать их только когда это необходимо.

3. **Совместимость**:
    - Работают с `@SpringBootTest`, `@WebMvcTest`, `@DataJpaTest` и другими slice-тестами.

---

### Пример в Slice-тесте (`@WebMvcTest`):
```java
@WebMvcTest(UserController.class)
class UserControllerTest {

    @Autowired
    private MockMvc mockMvc;

    @MockBean
    private UserService userService; // Сервис мокируется, контроллер тестируется изолированно

    @Test
    void getUser_ShouldReturnUserFromService() throws Exception {
        Mockito.when(userService.getUser(1L))
               .thenReturn(new User("Ivan"));

        mockMvc.perform(get("/users/1"))
               .andExpect(status().isOk())
               .andExpect(jsonPath("$.name").value("Ivan"));
    }
}
```

---

### Best Practices:
- **Избегайте избыточного использования**: Мокируйте только внешние зависимости (БД, HTTP-клиенты), а не внутреннюю логику.
- **Для unit-тестов** используйте `Mockito` без Spring (быстрее).
- **Для интеграционных тестов** применяйте `@MockBean`/`@SpyBean` точечно, чтобы не пересоздавать контекст.
