Тестирование Spring Boot приложений — критически важная часть разработки для Senior-уровня. Вот комплексный подход, охватывающий все ключевые аспекты:

---

### 1. **Классификация тестов и стратегия**
**Пирамида тестирования:**
- **Unit-тесты** (70-80%): Проверка отдельных компонентов в изоляции
- **Integration-тесты** (10-20%): Проверка взаимодействия между компонентами
- **End-to-End тесты** (5-10%): Проверка полного workflow приложения

---

### 2. **Unit-тестирование**
**Тестируемые компоненты:**
- Сервисы, утилиты, хелперы
- Контроллеры (изолированно)
- Мэпперы (DTO <-> Entity)

**Ключевые аннотации:**
```java
@ExtendWith(MockitoExtension.class) // JUnit 5
class UserServiceTest {
    
    @Mock
    private UserRepository userRepository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void shouldCreateUser() {
        // given
        UserDto request = new UserDto("test@email.com");
        when(userRepository.save(any(User.class)))
            .thenReturn(new User(1L, "test@email.com"));
        
        // when
        UserResponse result = userService.createUser(request);
        
        // then
        assertThat(result.getId()).isEqualTo(1L);
        verify(userRepository).save(any(User.class));
    }
}
```

**Лучшие практики:**
- Используйте BDD-стиль (given-when-then)
- Проверяйте поведение, а не реализацию
- Минимизируйте моки для соседних компонентов

---

### 3. **Интеграционные тесты**
**Тестирование с реальной БД:**
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = Replace.NONE)
@Testcontainers
class UserRepositoryIntegrationTest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
    }
    
    @Autowired
    private UserRepository userRepository;
    
    @Test
    void shouldFindByEmail() {
        // given
        User user = new User("test@email.com");
        userRepository.save(user);
        
        // when
        Optional<User> found = userRepository.findByEmail("test@email.com");
        
        // then
        assertThat(found).isPresent();
    }
}
```

**Тестирование REST-контроллеров:**
```java
@WebMvcTest(UserController.class)
class UserControllerTest {
    
    @Autowired
    private MockMvc mockMvc;
    
    @MockBean
    private UserService userService;
    
    @Test
    void shouldReturnUser() throws Exception {
        when(userService.getUser(1L))
            .thenReturn(new UserResponse(1L, "test@email.com"));
        
        mockMvc.perform(get("/api/users/1"))
            .andExpect(status().isOk())
            .andExpect(jsonPath("$.email").value("test@email.com"));
    }
}
```

---

### 4. **Слайс-тестирование (Slice Tests)**
Spring Boot предоставляет аннотации для тестирования отдельных слоев:

- **@JsonTest** - тестирование JSON сериализации
- **@DataJpaTest** - тестирование JPA компонентов
- **@WebMvcTest** - тестирование MVC контроллеров
- **@WebFluxTest** - тестирование WebFlux компонентов
- **@RestClientTest** - тестирование REST клиентов

---

### 5. **End-to-End тесты**
**Полное тестирование приложения:**
```java
@SpringBootTest(webEnvironment = WebEnvironment.RANDOM_PORT)
@Testcontainers
@ActiveProfiles("test")
class UserApplicationE2ETest {
    
    @Container
    static PostgreSQLContainer<?> postgres = new PostgreSQLContainer<>("postgres:15");
    
    @Autowired
    private TestRestTemplate restTemplate;
    
    @DynamicPropertySource
    static void configureProperties(DynamicPropertyRegistry registry) {
        registry.add("spring.datasource.url", postgres::getJdbcUrl);
    }
    
    @Test
    void shouldCreateAndRetrieveUser() {
        // Create user
        UserDto request = new UserDto("e2e@test.com");
        ResponseEntity<UserResponse> createResponse = restTemplate
            .postForEntity("/api/users", request, UserResponse.class);
        
        // Get user
        Long userId = createResponse.getBody().getId();
        ResponseEntity<UserResponse> getResponse = restTemplate
            .getForEntity("/api/users/" + userId, UserResponse.class);
        
        assertThat(getResponse.getStatusCode()).isEqualTo(HttpStatus.OK);
        assertThat(getResponse.getBody().getEmail()).isEqualTo("e2e@test.com");
    }
}
```

---

### 6. **Тестирование безопасности**
```java
@WebMvcTest
@WithMockUser(roles = "ADMIN")
class SecurityTest {
    
    @Test
    @WithMockUser(roles = "USER")
    void shouldForbidAccessForUser() throws Exception {
        mockMvc.perform(get("/api/admin/users"))
            .andExpect(status().isForbidden());
    }
}
```

---

### 7. **Конфигурация и профили**
**application-test.properties:**
```properties
spring.datasource.url=jdbc:tc:postgresql:15:///test
spring.jpa.hibernate.ddl-auto=create-drop
logging.level.org.hibernate.SQL=DEBUG
```

**Активация профиля:**
```java
@ActiveProfiles("test")
@SpringBootTest
class TestProfileTest {
    // ...
}
```

---

### 8. **Оптимизация и лучшие практики**

**Производительность тестов:**
- Используйте @DirtiesContext только когда необходимо
- Применяйте @MockBean вместо поднятия полного контекста
- Кешируйте ApplicationContext с @SpringBootTest

**Организация тестов:**
```java
// Паттерн Builder для тестовых данных
UserTestBuilder.builder()
    .withEmail("test@email.com")
    .withName("John")
    .build();

// Общие конфигурации в базовом классе
abstract class BaseIntegrationTest {
    // Общая конфигурация Testcontainers
}
```

**Покрытие и качество:**
- Используйте JaCoCo для измерения покрытия
- Внедрите Mutation Testing (PITest)
- Анализируйте тесты с помощью ArchUnit

---

### 9. **Расширенные сценарии**

**Асинхронное тестирование:**
```java
@WebFluxTest
class ReactiveControllerTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Test
    void shouldGetUser() {
        webTestClient.get().uri("/api/users/1")
            .exchange()
            .expectStatus().isOk()
            .expectBody()
            .jsonPath("$.email").isEqualTo("test@email.com");
    }
}
```

**Тестирование Kafka:**
```java
@EmbeddedKafka
@SpringBootTest
class KafkaTest {
    
    @Autowired
    private KafkaTemplate<String, Object> kafkaTemplate;
    
    @Test
    void shouldSendMessage() {
        // Тестирование отправки/получения сообщений
    }
}
```

---

### 10. **CI/CD интеграция**
```yaml
# GitHub Actions example
jobs:
  test:
    services:
      postgres:
        image: postgres:15
        env:
          POSTGRES_PASSWORD: test
    steps:
      - run: ./mvnw verify
```

---

### Ключевые инструменты:
- **JUnit 5** + AssertJ + Mockito
- **Testcontainers** для изолированных тестов БД
- **Spring Test Context** для кеширования контекста
- **Test slices** для точечного тестирования слоев
- **WireMock** для тестирования HTTP клиентов

Этот подход обеспечивает надежное тестирование Spring Boot приложений на профессиональном уровне, соответствующий стандартам Senior-разработчика.