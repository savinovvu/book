Чтобы эффективно тестировать транзакции в Spring-приложениях, важно понимать различные аспекты работы с `@Transactional` в тестах. Рассмотрим ключевые подходы и лучшие практики:

## 1. Базовая настройка тестового класса

```java
@SpringBootTest
@Transactional // Тесты будут выполняться в транзакции с автоматическим откатом
class UserServiceIntegrationTest {

    @Autowired
    private UserService userService;
    
    @Autowired
    private UserRepository userRepository;
    
    @Autowired
    private TestEntityManager testEntityManager;

    @Test
    void shouldSaveUser() {
        // given
        User user = new User("John", "john@example.com");
        
        // when
        User savedUser = userService.saveUser(user);
        
        // then
        assertThat(savedUser.getId()).isNotNull();
        assertThat(savedUser.getName()).isEqualTo("John");
    }
}
```

## 2. Тестирование отката транзакций

### Тестирование автоматического отката при исключениях

```java
@Test
@Transactional
void shouldRollbackWhenExceptionOccurs() {
    // given
    User user1 = new User("User1", "user1@test.com");
    User user2 = new User("User2", "user2@test.com");
    
    userService.saveUser(user1); // Успешно сохраняется
    
    // when & then
    assertThatThrownBy(() -> userService.saveUserWithException(user2))
        .isInstanceOf(RuntimeException.class);
    
    // Проверяем, что первая запись также откатилась
    // благодаря transactional на уровне теста
    List<User> users = userRepository.findAll();
    assertThat(users).isEmpty(); // Все изменения откатились
}
```

### Тестирование аннотации @Transactional с rollbackFor

```java
@Service
class UserService {
    
    @Transactional(rollbackFor = {ValidationException.class, DataIntegrityViolationException.class})
    public void saveUserWithValidation(User user) {
        if (user.getEmail() == null) {
            throw new ValidationException("Email is required");
        }
        userRepository.save(user);
    }
}

@Test
@Transactional
void shouldRollbackForSpecificException() {
    // given
    User invalidUser = new User("John", null);
    
    // when & then
    assertThatThrownBy(() -> userService.saveUserWithValidation(invalidUser))
        .isInstanceOf(ValidationException.class);
    
    // Проверяем откат транзакции
    assertThat(userRepository.count()).isEqualTo(0);
}
```

## 3. Управление поведением транзакций в тестах

### Принудительный коммит транзакции

```java
@Test
@Transactional
@Commit // Или @Rollback(false) - транзакция будет закоммичена
void shouldCommitTransaction() {
    User user = new User("John", "john@example.com");
    userService.saveUser(user);
    
    // Изменения будут сохранены в базе данных
    // Осторожно: это может повлиять на другие тесты!
}
```

### Отключение транзакционности для конкретного теста

```java
@Test
@Transactional(propagation = Propagation.NOT_SUPPORTED)
void shouldExecuteWithoutTransaction() {
    // Этот тест выполняется без транзакции
    // Полезно для тестирования поведения без транзакционного контекста
}
```

## 4. Тестирование уровней изоляции

```java
@Test
@Transactional(isolation = Isolation.SERIALIZABLE)
void shouldHandleSerializableIsolation() {
    // Тестирование с самым строгим уровнем изоляции
    User user1 = userService.saveUser(new User("User1", "user1@test.com"));
    User user2 = userService.saveUser(new User("User2", "user2@test.com"));
    
    assertThat(userRepository.count()).isEqualTo(2);
}
```

## 5. Тестирование распространения транзакций

```java
@Service
class OrderService {
    
    @Autowired
    private UserService userService;
    
    @Transactional(propagation = Propagation.REQUIRED)
    public void createOrderWithUser(Order order, User user) {
        // Этот метод должен выполняться в существующей транзакции
        // или создавать новую, если её нет
        userService.saveUser(user);
        orderRepository.save(order);
    }
    
    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateUserInNewTransaction(User user) {
        // Всегда создает новую транзакцию
        userService.saveUser(user);
    }
}

@Test
@Transactional
void testTransactionPropagation() {
    User user = new User("John", "john@example.com");
    Order order = new Order(user);
    
    orderService.createOrderWithUser(order, user);
    
    // Обе операции выполняются в одной транзакции
    assertThat(userRepository.count()).isEqualTo(1);
    assertThat(orderRepository.count()).isEqualTo(1);
}
```

## 6. Интеграционные тесты с несколькими транзакциями

```java
@Test
void shouldMaintainDataConsistencyAcrossTransactions() {
    // Первая транзакция
    TransactionTemplate transactionTemplate = new TransactionTemplate(transactionManager);
    transactionTemplate.execute(status -> {
        User user = userService.saveUser(new User("John", "john@example.com"));
        return user;
    });
    
    // Вторая транзакция - проверяем, что данные сохранились
    transactionTemplate.execute(status -> {
        List<User> users = userRepository.findAll();
        assertThat(users).hasSize(1);
        return null;
    });
}
```

## 7. Тестирование таймаутов транзакций

```java
@Test
@Transactional(timeout = 1) // 1 секунда таймаут
void shouldTimeoutWhenOperationTakesTooLong() {
    // given - операция, которая занимает много времени
    List<User> users = generateLargeDataset(10000);
    
    // when & then
    assertThatThrownBy(() -> userService.batchSaveUsers(users))
        .isInstanceOf(TransactionTimedOutException.class);
}
```

## 8. Лучшие практики

### Использование TestEntityManager для отладки

```java
@Test
@Transactional
void shouldUseTestEntityManagerForDebugging() {
    User user = new User("John", "john@example.com");
    
    // Сохраняем через сервис
    userService.saveUser(user);
    
    // Используем TestEntityManager для проверки состояния
    User persistedUser = testEntityManager.find(User.class, user.getId());
    assertThat(persistedUser).isNotNull();
    assertThat(persistedUser.getName()).isEqualTo("John");
    
    // Принудительно сбрасываем контекст для проверки ленивой загрузки
    testEntityManager.flush();
    testEntityManager.clear();
}
```

### Настройка тестовой базы данных

```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:h2:mem:testdb",
    "spring.jpa.hibernate.ddl-auto=create-drop"
})
class UserRepositoryTest {
    // Тесты только для репозитория
}
```

### Очистка данных между тестами

```java
@AfterEach
void cleanup() {
    // Дополнительная очистка, если нужна
    userRepository.deleteAll();
}
```

## 9. Тестирование асинхронных транзакций

```java
@Test
@Transactional
void testAsyncTransaction() throws Exception {
    User user = new User("John", "john@example.com");
    
    CompletableFuture<User> future = userService.saveUserAsync(user);
    User savedUser = future.get(5, TimeUnit.SECONDS);
    
    assertThat(savedUser).isNotNull();
    // Проверяем, что транзакция завершилась успешно
    assertThat(userRepository.findById(savedUser.getId())).isPresent();
}
```

Эти подходы помогут вам создавать надежные тесты для транзакционной логики в Spring-приложениях, обеспечивая предсказуемое поведение и изоляцию тестов друг от друга.