Чтобы реализовать CQRS и Event Sourcing с использованием реактивных потоков в Spring, следует использовать Spring Boot, Project Reactor, Spring WebFlux и реактивные драйверы для базы данных. Вот подробное руководство:

---

### **1. Архитектура**
- **CQRS**: Разделение на команды (запись) и запросы (чтение).
- **Event Sourcing**: Сохранение всех изменений состояния как последовательности событий.
- **Реактивные потоки**: Асинхронная обработка данных с backpressure (Project Reactor).

---

### **2. Зависимости (Maven)**
```xml
<dependencies>
    <!-- Reactor Core -->
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-core</artifactId>
    </dependency>
    
    <!-- Spring WebFlux -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
    
    <!-- Reactive MongoDB -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
    </dependency>
    
    <!-- Testing -->
    <dependency>
        <groupId>io.projectreactor</groupId>
        <artifactId>reactor-test</artifactId>
        <scope>test</scope>
    </dependency>
</dependencies>
```

---

### **3. Модель событий (Event Sourcing)**
```java
public abstract class Event {
    private String aggregateId;
    private Long version;
    // getters, setters
}

// Пример события
public class UserCreatedEvent extends Event {
    private String userId;
    private String name;
    // getters, constructors
}

public class UserUpdatedEvent extends Event {
    private String userId;
    private String newName;
    // getters, constructors
}
```

---

### **4. Агрегат (Aggregate)**
```java
public class UserAggregate {
    private String userId;
    private String name;
    private Long version = 0L;

    public Flux<Event> process(CreateUserCommand command) {
        return Flux.just(
            new UserCreatedEvent(command.getUserId(), command.getName())
        );
    }

    public void apply(UserCreatedEvent event) {
        this.userId = event.getUserId();
        this.name = event.getName();
        this.version = event.getVersion();
    }

    // Аналогично для других команд/событий
}
```

---

### **5. Репозиторий событий (Event Store)**
```java
@Repository
public class EventStore {
    private final ReactiveMongoTemplate mongoTemplate;

    public EventStore(ReactiveMongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    public Flux<Event> loadEvents(String aggregateId) {
        return mongoTemplate.find(
            Query.query(Criteria.where("aggregateId").is(aggregateId)),
            Event.class
        ).sort(Comparator.comparing(Event::getVersion));
    }

    public Mono<Void> saveEvent(Event event) {
        return mongoTemplate.save(event).then();
    }
}
```

---

### **6. Обработчик команд (Command Handler)**
```java
@Service
public class UserCommandHandler {
    private final EventStore eventStore;

    public UserCommandHandler(EventStore eventStore) {
        this.eventStore = eventStore;
    }

    public Mono<String> handleCreateUser(CreateUserCommand command) {
        return eventStore.loadEvents(command.getUserId())
            .reduce(new UserAggregate(), (agg, event) -> {
                // Восстановление состояния агрегата
                if (event instanceof UserCreatedEvent) {
                    agg.apply((UserCreatedEvent) event);
                }
                return agg;
            })
            .flatMap(aggregate -> {
                // Генерация нового события
                Flux<Event> events = aggregate.process(command);
                return events.flatMap(eventStore::saveEvent).then(Mono.just(command.getUserId()));
            });
    }
}
```

---

### **7. Проекции (Projections)**
```java
@Service
public class UserProjection {
    private final ReactiveMongoTemplate mongoTemplate;

    public UserProjection(ReactiveMongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    @EventListener
    public void on(UserCreatedEvent event) {
        UserView view = new UserView(event.getUserId(), event.getName());
        mongoTemplate.save(view).subscribe();
    }

    @EventListener
    public void on(UserUpdatedEvent event) {
        mongoTemplate.findOne(
            Query.query(Criteria.where("userId").is(event.getUserId())), 
            UserView.class
        ).doOnNext(view -> {
            view.setName(event.getNewName());
            mongoTemplate.save(view).subscribe();
        }).subscribe();
    }
}

// Read-модель
@Document(collection = "users_view")
public class UserView {
    @Id
    private String userId;
    private String name;
    // getters, setters
}
```

---

### **8. Контроллеры (CQRS)**
**Команды:**
```java
@RestController
@RequestMapping("/users")
public class UserCommandController {
    private final UserCommandHandler handler;

    public UserCommandController(UserCommandHandler handler) {
        this.handler = handler;
    }

    @PostMapping
    public Mono<ResponseEntity<String>> createUser(@RequestBody CreateUserCommand command) {
        return handler.handleCreateUser(command)
            .map(id -> ResponseEntity.ok(id));
    }
}
```

**Запросы:**
```java
@RestController
@RequestMapping("/users")
public class UserQueryController {
    private final ReactiveMongoTemplate mongoTemplate;

    public UserQueryController(ReactiveMongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

    @GetMapping("/{userId}")
    public Mono<UserView> getUser(@PathVariable String userId) {
        return mongoTemplate.findOne(
            Query.query(Criteria.where("userId").is(userId)), 
            UserView.class
        );
    }
}
```

---

### **9. Конфигурация MongoDB**
```yaml
# application.yml
spring:
  data:
    mongodb:
      uri: mongodb://localhost:27017/reactivedb
```

---

### **10. Тестирование**
```java
@SpringBootTest
class UserCommandHandlerTest {
    @Autowired
    private UserCommandHandler handler;

    @Test
    void testCreateUser() {
        CreateUserCommand command = new CreateUserCommand("123", "John");

        StepVerifier.create(handler.handleCreateUser(command))
            .expectNext("123")
            .verifyComplete();
    }
}
```

---

### **11. Оптимизации**
- **Snapshotting**: Периодическое сохранение состояния агрегата для избежания перезагрузки всех событий.
- **Eventual Consistency**: Использование `@EventListener` с реактивными шинами (Spring Reactive Kafka/RabbitMQ).
- **Error Handling**:
  ```java
  public Mono<String> handleCreateUser(CreateUserCommand command) {
      return eventStore.loadEvents(command.getUserId())
          // ... логика
          .onErrorResume(throwable -> Mono.error(new BusinessException("Ошибка создания")));
  }
  ```

---

### **12. Важные замечания**
1. **Идемпотентность**: Обработчики событий должны быть идемпотентными.
2. **Порядок событий**: Версионирование (version) для контроля порядка.
3. **Транзакционность**: В реактивном стиле используйте атомарные операции MongoDB.

Этот подход обеспечивает масштабируемость, отзывчивость и устойчивость к нагрузкам за счет реактивных потоков и событийно-ориентированной архитектуры.