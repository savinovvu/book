Чтобы реализовать реактивное кеширование с использованием Redis и Lettuce в Spring, следуйте этим шагам:

### 1. **Зависимости**
Добавьте в `pom.xml` (Maven):
```xml
<dependencies>
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis-reactive</artifactId>
    </dependency>
    <dependency>
        <groupId>io.lettuce</groupId>
        <artifactId>lettuce-core</artifactId>
    </dependency>
</dependencies>
```

### 2. **Конфигурация Redis**
```yaml
# application.yml
spring:
  redis:
    host: localhost
    port: 6379
    password: your_password
    timeout: 2000ms
    lettuce:
      pool:
        max-active: 8
        max-idle: 8
```

### 3. **Конфигурационный класс**
```java
@Configuration
@EnableCaching
public class RedisConfig {

    @Bean
    public ReactiveRedisConnectionFactory reactiveRedisConnectionFactory() {
        RedisStandaloneConfiguration config = new RedisStandaloneConfiguration();
        config.setHostName("localhost");
        config.setPort(6379);
        config.setPassword(RedisPassword.of("your_password"));
        return new LettuceConnectionFactory(config);
    }

    @Bean
    public ReactiveRedisTemplate<String, Object> reactiveRedisTemplate(
        ReactiveRedisConnectionFactory factory) {
        StringRedisSerializer keySerializer = new StringRedisSerializer();
        Jackson2JsonRedisSerializer<Object> valueSerializer = 
            new Jackson2JsonRedisSerializer<>(Object.class);
        RedisSerializationContext.RedisSerializationContextBuilder<String, Object> builder =
            RedisSerializationContext.newSerializationContext(keySerializer);
        RedisSerializationContext<String, Object> context = 
            builder.value(valueSerializer).build();
        return new ReactiveRedisTemplate<>(factory, context);
    }
}
```

### 4. **Реактивный сервис кеширования**
```java
@Service
public class CacheService {

    private final ReactiveRedisTemplate<String, Object> redisTemplate;

    public CacheService(ReactiveRedisTemplate<String, Object> redisTemplate) {
        this.redisTemplate = redisTemplate;
    }

    public Mono<Boolean> save(String key, Object value, Duration ttl) {
        return redisTemplate.opsForValue()
            .set(key, value, ttl)
            .doOnSuccess(result -> 
                log.info("Кешировано: ключ={}, ttl={}", key, ttl));
    }

    public <T> Mono<T> get(String key, Class<T> type) {
        return redisTemplate.opsForValue()
            .get(key)
            .cast(type)
            .doOnNext(value -> 
                log.debug("Получено из кеша: ключ={}", key));
    }

    public Mono<Boolean> evict(String key) {
        return redisTemplate.delete(key)
            .map(count -> count > 0);
    }
}
```

### 5. **Использование в бизнес-логике**
```java
@Service
public class UserService {

    private final UserRepository repository;
    private final CacheService cacheService;

    public UserService(UserRepository repository, CacheService cacheService) {
        this.repository = repository;
        this.cacheService = cacheService;
    }

    public Mono<User> findById(String userId) {
        String cacheKey = "user:" + userId;
        return cacheService.get(cacheKey, User.class)
            .switchIfEmpty(
                repository.findById(userId)
                    .flatMap(user -> 
                        cacheService.save(cacheKey, user, Duration.ofMinutes(10))
                    .thenReturn(user)
            ));
    }

    public Mono<Void> updateUser(String userId, User user) {
        String cacheKey = "user:" + userId;
        return repository.save(user)
            .then(cacheService.evict(cacheKey))
            .then();
    }
}
```

### 6. **Расширенное кеширование с аннотациями**
Для реактивного кеширования через аннотации используйте кастомную реализацию:

```java
@Configuration
@EnableReactiveCaching
public class ReactiveCachingConfig {

    @Bean
    public ReactiveCacheManager cacheManager(ReactiveRedisConnectionFactory factory) {
        RedisSerializationContext<String, Object> serializationContext = 
            RedisSerializationContext.java()
            .value(new Jackson2JsonRedisSerializer<>(Object.class))
            .build();
        return new ReactiveRedisCacheManager(
            RedisCacheWriter.nonLockingRedisCacheWriter(factory),
            RedisCacheConfiguration.defaultCacheConfig()
                .serializeValuesWith(serializationContext.getValueSerializationPair())
                .entryTtl(Duration.ofMinutes(10))
        );
    }
}
```

Использование в сервисе:
```java
@Service
public class ProductService {

    @ReactiveCacheable(cacheNames = "products", key = "#id")
    public Mono<Product> findById(String id) {
        // Логика загрузки из БД
    }

    @ReactiveCacheEvict(cacheNames = "products", key = "#product.id")
    public Mono<Product> update(Product product) {
        // Логика обновления
    }
}
```

### 7. **Обработка ошибок**
```java
public Mono<User> findByIdWithFallback(String userId) {
    return cacheService.get("user:" + userId, User.class)
        .onErrorResume(throwable -> {
            log.warn("Ошибка кеша: ", throwable);
            return repository.findById(userId);
        });
}
```

### Ключевые особенности:
1. **Неблокирующие операции** – все операции используют Reactive Streams
2. **Сериализация JSON** – для сложных объектов
3. **TTL поддержка** – автоматическое удаление данных
4. **Интеграция с Spring Cache** – через ReactiveCacheManager
5. **Логирование** – трассировка операций с кешем

### Тестирование:
```java
@SpringBootTest
class CacheServiceTest {

    @Autowired
    private CacheService cacheService;

    @Test
    void testCacheOperations() {
        User user = new User("123", "John");
        StepVerifier.create(
            cacheService.save("user:123", user, Duration.ofMinutes(1))
                .then(cacheService.get("user:123", User.class))
        )
        .expectNextMatches(cached -> cached.getName().equals("John"))
        .verifyComplete();
    }
}
```

Этот подход обеспечивает:
- Полностью реактивный стек
- Эффективное использование ресурсов
- Поддержка современных возможностей Spring Data Redis
- Гибкая конфигурация сериализации
- Интеграция с Spring Cache Annotations