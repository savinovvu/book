Обработка ошибок в Spring WebFlux — критически важная тема для senior-разработчиков. Рассмотрим ключевые аспекты и best practices.

## 1. Основные подходы к обработке ошибок

### Реактивные операторы для ошибок

```java
public class UserService {
    
    public Mono<User> findUserById(String id) {
        return userRepository.findById(id)
            .switchIfEmpty(Mono.error(new UserNotFoundException("User not found: " + id)))
            .onErrorResume(DataAccessException.class, e -> {
                log.error("Database error", e);
                return Mono.error(new ServiceUnavailableException("Service temporary unavailable"));
            });
    }
    
    public Flux<User> findAllUsers() {
        return userRepository.findAll()
            .onErrorReturn(RedisConnectionException.class, User.DEFAULT_USER)
            .timeout(Duration.ofSeconds(5))
            .onErrorMap(TimeoutException.class, 
                e -> new BusinessException("Operation timeout", e));
    }
}
```

## 2. Глобальная обработка исключений

### `@ControllerAdvice` для WebFlux

```java
@ControllerAdvice
@Slf4j
public class GlobalErrorWebExceptionHandler {
    
    // Обработка бизнес-исключений
    @ExceptionHandler(BusinessException.class)
    public ResponseEntity<ErrorResponse> handleBusinessException(
            BusinessException ex, ServerWebExchange exchange) {
        
        ErrorResponse error = ErrorResponse.builder()
            .code("BUSINESS_ERROR")
            .message(ex.getMessage())
            .path(exchange.getRequest().getPath().value())
            .timestamp(Instant.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.BAD_REQUEST)
            .contentType(MediaType.APPLICATION_JSON)
            .body(error);
    }
    
    // Обработка ошибок валидации
    @ExceptionHandler(WebExchangeBindException.class)
    public ResponseEntity<ErrorResponse> handleValidationException(
            WebExchangeBindException ex, ServerWebExchange exchange) {
        
        List<FieldError> fieldErrors = ex.getFieldErrors().stream()
            .map(fieldError -> FieldError.builder()
                .field(fieldError.getField())
                .message(fieldError.getDefaultMessage())
                .build())
            .collect(Collectors.toList());
            
        ErrorResponse error = ErrorResponse.builder()
            .code("VALIDATION_ERROR")
            .message("Validation failed")
            .fieldErrors(fieldErrors)
            .path(exchange.getRequest().getPath().value())
            .timestamp(Instant.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.UNPROCESSABLE_ENTITY)
            .body(error);
    }
    
    // Обработка всех остальных исключений
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllUncaughtException(
            Exception ex, ServerWebExchange exchange) {
        
        log.error("Unhandled exception", ex);
        
        ErrorResponse error = ErrorResponse.builder()
            .code("INTERNAL_ERROR")
            .message("Internal server error")
            .path(exchange.getRequest().getPath().value())
            .timestamp(Instant.now())
            .build();
            
        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
            .body(error);
    }
}
```

## 3. Кастомный `ErrorAttributes`

```java
@Component
public class CustomErrorAttributes extends DefaultErrorAttributes {
    
    @Override
    public Map<String, Object> getErrorAttributes(ServerRequest request, 
            ErrorAttributeOptions options) {
        Map<String, Object> errorAttributes = super.getErrorAttributes(request, options);
        
        Throwable error = getError(request);
        
        // Убираем stacktrace из продакшн-ответов
        errorAttributes.remove("trace");
        
        // Добавляем кастомные поля
        errorAttributes.put("timestamp", Instant.now().toString());
        errorAttributes.put("requestId", request.exchange().getRequest().getId());
        
        if (error instanceof BusinessException) {
            errorAttributes.put("errorCode", ((BusinessException) error).getErrorCode());
        }
        
        return errorAttributes;
    }
}
```

## 4. Functional Endpoints обработка ошибок

```java
@Configuration
public class RouterConfiguration {
    
    @Bean
    public RouterFunction<ServerResponse> userRouter(UserHandler userHandler) {
        return RouterFunctions.route()
            .GET("/users/{id}", userHandler::getUser)
            .filter(errorHandlingFilter())
            .build();
    }
    
    private HandlerFilterFunction<ServerResponse, ServerResponse> errorHandlingFilter() {
        return (request, next) -> next.handle(request)
            .onErrorResume(BusinessException.class, e -> 
                ServerResponse.badRequest()
                    .contentType(MediaType.APPLICATION_JSON)
                    .bodyValue(createErrorResponse(e)))
            .onErrorResume(TimeoutException.class, e -> 
                ServerResponse.status(HttpStatus.SERVICE_UNAVAILABLE)
                    .bodyValue(createErrorResponse(e)))
            .onErrorResume(e -> 
                ServerResponse.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .bodyValue(createErrorResponse(e)));
    }
    
    private ErrorResponse createErrorResponse(Throwable e) {
        return ErrorResponse.builder()
            .message(e.getMessage())
            .timestamp(Instant.now())
            .build();
    }
}

@Component
public class UserHandler {
    
    public Mono<ServerResponse> getUser(ServerRequest request) {
        String userId = request.pathVariable("id");
        
        return userService.findUserById(userId)
            .flatMap(user -> ServerResponse.ok().bodyValue(user))
            .switchIfEmpty(ServerResponse.notFound().build());
    }
}
```

## 5. Retry механизмы с обработкой ошибок

```java
@Service
@Slf4j
public class ExternalApiService {
    
    public Mono<ApiResponse> callExternalApi(String data) {
        return webClient.post()
            .uri("/external/api")
            .bodyValue(data)
            .retrieve()
            .bodyToMono(ApiResponse.class)
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
            .doOnError(e -> log.error("Failed after retries", e))
            .onErrorResume(e -> fallbackResponse(data));
    }
    
    public Mono<ApiResponse> callApiWithConditionalRetry(String data) {
        return webClient.post()
            .uri("/external/api")
            .bodyValue(data)
            .retrieve()
            .bodyToMono(ApiResponse.class)
            .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(2))
            .filter(throwable -> isRetryableException(throwable))
            .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> {
                throw new ServiceUnavailableException("External service unavailable");
            });
    }
    
    private boolean isRetryableException(Throwable throwable) {
        return throwable instanceof ConnectException ||
               throwable instanceof TimeoutException ||
               (throwable instanceof WebClientResponseException && 
                ((WebClientResponseException) throwable).getStatusCode().is5xxServerError());
    }
    
    private Mono<ApiResponse> fallbackResponse(String data) {
        return Mono.just(ApiResponse.builder()
            .status("FALLBACK")
            .data("Fallback data")
            .build());
    }
}
```

## 6. Валидация и обработка ошибок

```java
@RestController
@Validated
public class UserController {
    
    @PostMapping("/users")
    public Mono<ResponseEntity<User>> createUser(
            @Valid @RequestBody Mono<UserDto> userDto) {
        
        return userDto
            .flatMap(dto -> userService.createUser(dto))
            .map(user -> ResponseEntity.status(HttpStatus.CREATED).body(user))
            .onErrorResume(ConstraintViolationException.class, e -> 
                Mono.just(ResponseEntity.badRequest().build()));
    }
    
    @GetMapping("/users")
    public Flux<User> getUsers(
            @RequestParam @Min(0) int page,
            @RequestParam @Max(100) int size) {
        
        return userService.findUsers(page, size);
    }
}

// DTO с валидацией
@Data
public class UserDto {
    @NotBlank(message = "Name is required")
    @Size(min = 2, max = 50, message = "Name must be between 2 and 50 characters")
    private String name;
    
    @Email(message = "Invalid email format")
    @NotBlank(message = "Email is required")
    private String email;
    
    @Min(value = 18, message = "Age must be at least 18")
    @Max(value = 120, message = "Age must be less than 120")
    private Integer age;
}
```

## 7. Мониторинг и логирование ошибок

```java
@Component
@Slf4j
@Order(1)
public class LoggingWebFilter implements WebFilter {
    
    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        long startTime = System.currentTimeMillis();
        String path = exchange.getRequest().getPath().value();
        
        return chain.filter(exchange)
            .doOnSuccess(v -> {
                logRequest(exchange, startTime, null);
            })
            .doOnError(throwable -> {
                logRequest(exchange, startTime, throwable);
            });
    }
    
    private void logRequest(ServerWebExchange exchange, long startTime, Throwable error) {
        long duration = System.currentTimeMillis() - startTime;
        HttpStatus status = exchange.getResponse().getStatusCode();
        
        if (error != null || (status != null && status.is5xxServerError())) {
            log.error("Request failed: {} {} - {}ms - Status: {} - Error: {}", 
                exchange.getRequest().getMethod(), 
                exchange.getRequest().getPath(),
                duration,
                status,
                error != null ? error.getMessage() : "Unknown error",
                error);
        } else {
            log.info("Request completed: {} {} - {}ms - Status: {}", 
                exchange.getRequest().getMethod(), 
                exchange.getRequest().getPath(),
                duration,
                status);
        }
    }
}
```

## 8. Кастомные исключения

```java
public abstract class BaseException extends RuntimeException {
    private final String errorCode;
    private final Instant timestamp;
    
    public BaseException(String message, String errorCode) {
        super(message);
        this.errorCode = errorCode;
        this.timestamp = Instant.now();
    }
}

public class BusinessException extends BaseException {
    public BusinessException(String message) {
        super(message, "BUSINESS_ERROR");
    }
}

public class ValidationException extends BaseException {
    private final List<FieldError> fieldErrors;
    
    public ValidationException(String message, List<FieldError> fieldErrors) {
        super(message, "VALIDATION_ERROR");
        this.fieldErrors = fieldErrors;
    }
}
```

## Best Practices для Senior:

1. **Не раскрывайте внутренние детали** — в prod-режиме скрывайте stack traces
2. **Используйте централизованное логирование** — все ошибки должны логироваться
3. **Стандартизируйте формат ответов** — единый формат для всех ошибок
4. **Разделяйте бизнес-ошибки и системные** — разные HTTP статусы и логика обработки
5. **Используйте retry с backoff** для временных сбоев внешних сервисов
6. **Реализуйте circuit breaker** для предотвращения каскадных сбоев
7. **Тестируйте обработку ошибок** — пишите тесты для всех сценариев

Этот подход обеспечит надежную и поддерживаемую обработку ошибок в реактивных приложениях Spring WebFlux.