Чтобы настроить **graceful shutdown** для реактивных приложений на Spring (WebFlux/Netty), необходимо обеспечить корректное завершение активных соединений и обработку текущих запросов. Вот пошаговое руководство:

---

### **1. Включение Graceful Shutdown**
Добавьте настройку в `application.properties`:
```properties
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=30s
```
- `server.shutdown=graceful` — активирует режим graceful shutdown.
- `spring.lifecycle.timeout-per-shutdown-phase` — время ожидания завершения текущих операций.

---

### **2. Обработка сигналов OS (SIGTERM)**
Spring Boot автоматически обрабатывает SIGTERM, но для кастомной логики используйте `ApplicationListener`:
```java
@Component
public class GracefulShutdownListener implements ApplicationListener<ContextClosedEvent> {
    @Override
    public void onApplicationEvent(ContextClosedEvent event) {
        // Дополнительные действия (например, закрытие внешних соединений)
    }
}
```

---

### **3. Graceful Shutdown для Netty (WebFlux)**
Для реактивных приложений на Netty настройте shutdown hook:
```java
@Configuration
public class NettyGracefulShutdown {
    
    @Bean
    public NettyServerCustomizer nettyServerCustomizer() {
        return server -> server.onChannelClose(); // Корректное закрытие каналов
    }
}
```

---

### **4. Работа с реактивными пулами и подключениями**
- **Базы данных (R2DBC):**
  Закройте соединения через `ConnectionFactory`:
  ```java
  @PreDestroy
  public void destroy() {
      connectionFactory.close(); // Освобождение пула
  }
  ```

- **WebClient:**
  Закройте реактивный клиент:
  ```java
  @Bean
  public WebClient webClient() {
      return WebClient.builder().build();
  }

  @PreDestroy
  public void cleanup() {
      webClient.close();
  }
  ```

---

### **5. Ожидание завершения текущих запросов**
Используйте `Flux`/`Mono` с таймаутами, чтобы операции не обрывались мгновенно:
```java
@RestController
public class ApiController {
    @GetMapping("/slow")
    public Mono<String> slowEndpoint() {
        return Mono.delay(Duration.ofSeconds(10)) // Имитация долгой операции
                  .timeout(Duration.ofSeconds(30)) // Таймаут больше, чем shutdown-phase
                  .thenReturn("OK");
    }
}
```

---

### **6. Интеграция с Kubernetes (Liveness/Readiness Probes)**
Настройте прокси для маршрутизации трафика:
```yaml
livenessProbe:
  httpGet:
    path: /actuator/health
    port: 8080
readinessProbe:
  httpGet:
    path: /actuator/health
    port: 8080
  initialDelaySeconds: 20
  periodSeconds: 5
```

---

### **7. Мониторинг через Spring Actuator**
Добавьте зависимость и настройте endpoint:
```properties
management.endpoints.web.exposure.include=health,info,shutdown
management.endpoint.health.probes.enabled=true
```
Ручной вызов shutdown через HTTP POST:
```bash
curl -X POST http://localhost:8080/actuator/shutdown
```

---

### **8. Кастомные Health Checks**
Реализуйте `ReactiveHealthIndicator` для проверки состояния компонентов:
```java
@Component
public class CustomHealthIndicator implements ReactiveHealthIndicator {
    @Override
    public Mono<Health> health() {
        return checkExternalService().then(Health.up().build());
    }
}
```

---

### **Важные замечания**
- **Таймауты**: Убедитесь, что `timeout-per-shutdown-phase` превышает максимальное время выполнения запросов.
- **Тестирование**: Используйте `Thread.sleep()` в контроллерах для имитации долгих операций и проверьте, что запросы не обрываются.
- **Reactive Streams**: Не блокируйте поток (avoid `block()`), чтобы не нарушать реактивную модель.

---

**Пример полной конфигурации:**
```java
@SpringBootApplication
public class ReactiveApp {
    public static void main(String[] args) {
        SpringApplication.run(ReactiveApp.class, args);
    }

    @PreDestroy
    public void onExit() {
        System.out.println("Closing resources...");
    }
}
```

```properties
# application.properties
server.shutdown=graceful
spring.lifecycle.timeout-per-shutdown-phase=35s
management.endpoints.web.exposure.include=*
```

Таким образом, приложение будет завершать работу, дожидаясь завершения текущих операций в рамках заданного таймаута.