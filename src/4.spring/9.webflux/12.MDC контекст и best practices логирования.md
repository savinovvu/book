Best practices для логирования в реактивных цепочках с сохранением MDC-контекста в Spring (WebFlux):

## 1. Основные подходы

### Использование Context в Reactor
```java
public Mono<String> getUserData(String userId) {
    return Mono.deferContextual(contextView -> {
        // Получение данных из контекста
        String traceId = contextView.getOrDefault("TRACE_ID", "");
        String userId = contextView.getOrDefault("USER_ID", "");
        
        return userRepository.findByUserId(userId)
            .doOnNext(user -> 
                log.info("User found: {}, traceId: {}", user, traceId)
            );
    });
}
```

### Конфигурация MDC для WebFlux
```java
@Configuration
public class MDCConfiguration {

    @Bean
    public WebFilter mdcWebFilter() {
        return (exchange, chain) -> {
            // Инициализация MDC для каждого запроса
            String traceId = exchange.getRequest().getHeaders()
                .getFirst("X-Trace-Id");
            if (traceId == null) {
                traceId = UUID.randomUUID().toString();
            }
            
            return chain.filter(exchange)
                .contextWrite(Context.of("TRACE_ID", traceId));
        };
    }
}
```

## 2. Утилитный класс для работы с MDC

```java
@Component
public class ReactiveMDC {

    private static final String TRACE_ID = "TRACE_ID";
    private static final String USER_ID = "USER_ID";

    public static <T> Function<Context, Context> putTraceId(String traceId) {
        return context -> context.put(TRACE_ID, traceId);
    }

    public static <T> Function<Context, Context> putUserId(String userId) {
        return context -> context.put(USER_ID, userId);
    }

    public static Mono<String> getTraceId() {
        return Mono.deferContextual(contextView -> 
            Mono.just(contextView.getOrDefault(TRACE_ID, "undefined"))
        );
    }

    public static <T> Consumer<Signal<T>> logOnNext(Consumer<T> logStatement) {
        return signal -> {
            if (!signal.isOnNext()) return;
            
            try (MDC.MDCCloseable _ = MDC.putCloseable("traceId", 
                    signal.getContextView().getOrDefault(TRACE_ID, ""))) {
                logStatement.accept(signal.get());
            }
        };
    }
}
```

## 3. Кастомный Appender для Logback

```xml
<!-- logback-spring.xml -->
<configuration>
    <appender name="JSON" class="ch.qos.logback.core.ConsoleAppender">
        <encoder class="net.logstash.logback.encoder.LoggingEventCompositeJsonEncoder">
            <providers>
                <timestamp/>
                <logLevel/>
                <loggerName/>
                <message/>
                <mdc>
                    <key>traceId</key>
                    <key>userId</key>
                </mdc>
                <stackTrace/>
            </providers>
        </encoder>
    </appender>
    
    <root level="INFO">
        <appender-ref ref="JSON" />
    </root>
</configuration>
```

## 4. Интеграция с Micrometer Tracing

```java
@Configuration
public class TracingConfiguration {

    @Bean
    public ObservationHandler<ReactiveObservationContext> reactiveObservationHandler() {
        return new ReactiveObservationHandler() {
            @Override
            public void onStart(ReactiveObservationContext context) {
                context.put(String.class, "traceId", 
                    context.getContext().getObservation().getContext().getTraceId());
            }
        };
    }

    public Mono<String> observedMethod() {
        return Observation.createNotStarted("reactive-operation", observationRegistry)
            .observe(() -> reactiveChain()
                .contextWrite(ReactiveMDC.putTraceId(
                    Observation.current().getContext().getTraceId()))
            );
    }
}
```

## 5. Best Practices

### 5.1 Сохранение контекста между операторами
```java
public Mono<User> processUser(String userId) {
    return ReactiveMDC.getTraceId()
        .flatMap(traceId -> userRepository.findById(userId))
        .doOnEach(ReactiveMDC.logOnNext(user -> 
            log.info("Processing user: {}", user.getName())))
        .flatMap(this::validateUser)
        .contextWrite(ReactiveMDC.putUserId(userId)); // Сохраняем userId в контекст
}
```

### 5.2 Обработка ошибок с контекстом
```java
public Mono<User> getUserSafe(String userId) {
    return userService.findUser(userId)
        .doOnEach(ReactiveMDC.logOnNext(user -> 
            log.info("User found: {}", user)))
        .doOnError(throwable -> 
            ReactiveMDC.getTraceId().subscribe(traceId ->
                log.error("Error fetching user, traceId: {}", traceId, throwable)
            ))
        .onErrorResume(throwable -> Mono.empty())
        .contextWrite(ReactiveMDC.putUserId(userId));
}
```

### 5.3 Параллельная обработка с сохранением контекста
```java
public Flux<User> processUsers(Flux<String> userIds) {
    return userIds
        .flatMap(userId -> processSingleUser(userId)
            .contextWrite(ReactiveMDC.putUserId(userId)),
        5) // concurrency
        .doOnComplete(() -> 
            ReactiveMDC.getTraceId().subscribe(traceId ->
                log.info("All users processed, traceId: {}", traceId)
            ));
}
```

## 6. Тестирование

```java
@SpringBootTest
class ReactiveLoggingTest {

    @Test
    void shouldPreserveMDCContext() {
        StepVerifier.create(
            userService.processUser("123")
                .contextWrite(Context.of("TRACE_ID", "test-trace-123"))
        )
        .expectNextMatches(user -> true)
        .verifyComplete();
    }
}
```

## Ключевые моменты:

1. **Context over ThreadLocal** - используйте Reactor Context вместо ThreadLocal
2. **Explicit propagation** - явно передавайте контекст между операторами
3. **Structured logging** - используйте структурированное логирование (JSON)
4. **Observation integration** - интегрируйте с Micrometer для распределенной трассировки
5. **Error handling** - не забывайте логировать ошибки с контекстом

Правильная настройка MDC в реактивных приложениях значительно упрощает отладку и мониторинг распределенных систем.