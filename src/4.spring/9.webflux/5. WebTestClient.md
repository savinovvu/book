`WebTestClient` — это инструмент для тестирования веб-приложений в реактивных стеках Spring, таких как Spring WebFlux. Он позволяет тестировать HTTP-запросы и ответы, поддерживая реактивные потоки (Mono/Flux). Вот как он работает:

### 1. **Создание экземпляра WebTestClient**
- **Для приложений WebFlux**:
  ```java
  WebTestClient client = WebTestClient.bindToApplicationContext(context).build();
  ```
- **Для конкретного контроллера**:
  ```java
  WebTestClient client = WebTestClient.bindToController(MyController.class).build();
  ```
- **Для маршрутизаторов (RouterFunction)**:
  ```java
  WebTestClient client = WebTestClient.bindToRouterFunction(routerFunction).build();
  ```
- **Для прямого подключения к серверу** (интеграционные тесты):
  ```java
  WebTestClient client = WebTestClient.bindToServer().baseUrl("http://localhost:8080").build();
  ```

### 2. **Выполнение запросов**
Методы для отправки HTTP-запросов:
   ```java
   client.get().uri("/api/data")...
   client.post().uri("/api/save")...
   client.put().uri("/api/update")...
   client.delete().uri("/api/delete")...
   ```

### 3. **Настройка запроса**
- **Заголовки**: `.header("Authorization", "Bearer token")`
- **Тело запроса**: `.body(BodyInserters.fromValue(data))`
- **Параметры**: `.queryParam("key", "value")`
- **Cookies**: `.cookie("name", "value")`

### 4. **Отправка запроса и проверки**
Используется цепочка проверок (assertions):
   ```java
   client.get().uri("/api/data")
       .exchange()
       .expectStatus().isOk() // Проверка статуса
       .expectHeader().contentType(MediaType.APPLICATION_JSON) // Проверка заголовков
       .expectBodyList(MyClass.class).hasSize(3); // Проверка тела ответа
   ```

### 5. **Проверка тела ответа**
- **JSON**:
  ```java
  .expectBody().json("{\"id\":1}");
  ```
- **Список объектов**:
  ```java
  .expectBodyList(MyClass.class).hasSize(5);
  ```
- **Извлечение поля**:
  ```java
  .expectBody().jsonPath("$.name").isEqualTo("John");
  ```

### 6. **Тестирование потоков (SSE)**
Для Server-Sent Events:
   ```java
   client.get().uri("/stream")
       .exchange()
       .expectStatus().isOk()
       .expectBody(String.class)
       .consumeWith(result -> { ... }); // Обработка потоковых данных
   ```

### 7. **Мокирование и изоляция**
- Можно тестировать только веб-слой, подменяя сервисы через `@MockBean`.
- Для изоляции логики маршрутизации используется `bindToRouterFunction`.

### Пример теста
```java
@SpringBootTest
class MyControllerTest {
    @Autowired
    private ApplicationContext context;

    private WebTestClient client;

    @BeforeEach
    void setUp() {
        client = WebTestClient.bindToApplicationContext(context).build();
    }

    @Test
    void testGetData() {
        client.get().uri("/api/users")
            .exchange()
            .expectStatus().isOk()
            .expectBodyList(User.class)
            .hasSize(2)
            .contains(new User("Alice"), new User("Bob"));
    }
}
```

### Преимущества
- **Удобный DSL** для проверок.
- **Поддержка реактивных типов** (Mono/Flux).
- **Гибкость**: подходит для модульных и интеграционных тестов.
- **Интеграция с Spring Security** (тестирование аутентификации/авторизации).

### Важно
- Для традиционных Spring MVC приложений используйте `MockMvc`.
- `WebTestClient` работает асинхронно, но в тестах блокирует поток для удобства (если не используются методы вроде `.returnResult()`).

Таким образом, `WebTestClient` предоставляет мощный инструмент для тестирования реактивных веб-приложений Spring, сочетая простоту использования с гибкостью проверок.