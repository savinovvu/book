Организация взаимодействия с реактивными базами данных (R2DBC/MongoDB) в Spring требует понимания реактивного программирования и специфики работы с неблокирующими драйверами. Рассмотрим оба подхода:

## 1. R2DBC (Reactive Relational Database Connectivity)

### Настройка зависимостей

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-r2dbc</artifactId>
</dependency>
<dependency>
    <groupId>io.r2dbc</groupId>
    <artifactId>r2dbc-postgresql</artifactId>
</dependency>
```

### Конфигурация

```yaml
spring:
  r2dbc:
    url: r2dbc:postgresql://localhost:5432/mydb
    username: user
    password: pass
```

```java
@Configuration
@EnableR2dbcRepositories
public class R2dbcConfig extends AbstractR2dbcConfiguration {
    
    @Override
    @Bean
    public ConnectionFactory connectionFactory() {
        return PostgresqlConnectionFactory.from(
            PostgresqlConnectionConfiguration.builder()
                .host("localhost")
                .port(5432)
                .database("mydb")
                .username("user")
                .password("pass")
                .build()
        );
    }
}
```

### Репозиторий

```java
public interface UserRepository extends ReactiveCrudRepository<User, Long> {
    
    @Query("SELECT * FROM users WHERE email = :email")
    Mono<User> findByEmail(String email);
    
    Flux<User> findByStatus(Status status);
    
    @Modifying
    @Query("UPDATE users SET status = :status WHERE id = :id")
    Mono<Integer> updateUserStatus(Long id, Status status);
}
```

### Кастомные реализации

```java
public interface CustomUserRepository {
    Flux<User> findActiveUsersWithPosts();
}

public class CustomUserRepositoryImpl implements CustomUserRepository {
    
    private final DatabaseClient databaseClient;
    
    public CustomUserRepositoryImpl(DatabaseClient databaseClient) {
        this.databaseClient = databaseClient;
    }
    
    @Override
    public Flux<User> findActiveUsersWithPosts() {
        String sql = """
            SELECT u.*, p.title, p.content 
            FROM users u 
            LEFT JOIN posts p ON u.id = p.user_id 
            WHERE u.status = 'ACTIVE'
            """;
            
        return databaseClient.sql(sql)
            .map((row, metadata) -> {
                User user = new User();
                user.setId(row.get("id", Long.class));
                user.setName(row.get("name", String.class));
                // маппинг остальных полей
                return user;
            })
            .all();
    }
}
```

## 2. Reactive MongoDB

### Настройка зависимостей

```xml
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-mongodb-reactive</artifactId>
</dependency>
```

### Конфигурация

```yaml
spring:
  data:
    mongodb:
      uri: mongodb://user:pass@localhost:27017/mydb
```

```java
@Configuration
@EnableReactiveMongoRepositories
public class MongoConfig extends AbstractReactiveMongoConfiguration {
    
    @Value("${spring.data.mongodb.uri}")
    private String mongoUri;
    
    @Override
    public MongoClient reactiveMongoClient() {
        return MongoClients.create(mongoUri);
    }
    
    @Override
    protected String getDatabaseName() {
        return "mydb";
    }
    
    @Bean
    public ReactiveMongoTemplate reactiveMongoTemplate() {
        return new ReactiveMongoTemplate(reactiveMongoClient(), getDatabaseName());
    }
}
```

### Документ и репозиторий

```java
@Document(collection = "users")
public class User {
    @Id
    private String id;
    private String name;
    private String email;
    private List<Address> addresses;
    private Instant createdAt;
    
    // getters/setters
}

public interface UserRepository extends ReactiveMongoRepository<User, String> {
    
    Flux<User> findByName(String name);
    
    Mono<User> findByEmail(String email);
    
    @Query("{ 'status': ?0 }")
    Flux<User> findByStatus(String status);
    
    Flux<User> findByCreatedAtAfter(Instant date);
}
```

## 3. Сервисный слой

### Базовый сервис

```java
@Service
@Transactional(readOnly = true)
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public Flux<User> findAll() {
        return userRepository.findAll()
            .doOnNext(user -> log.info("Found user: {}", user.getName()));
    }
    
    public Mono<User> findById(String id) {
        return userRepository.findById(id)
            .switchIfEmpty(Mono.error(new UserNotFoundException(id)));
    }
    
    @Transactional
    public Mono<User> create(User user) {
        user.setCreatedAt(Instant.now());
        return userRepository.save(user)
            .doOnSuccess(u -> log.info("Created user: {}", u.getId()));
    }
    
    @Transactional
    public Mono<User> update(String id, User user) {
        return userRepository.findById(id)
            .flatMap(existingUser -> {
                existingUser.setName(user.getName());
                existingUser.setEmail(user.getEmail());
                return userRepository.save(existingUser);
            });
    }
    
    @Transactional
    public Mono<Void> delete(String id) {
        return userRepository.deleteById(id)
            .doOnSuccess(v -> log.info("Deleted user: {}", id));
    }
}
```

## 4. Контроллер

```java
@RestController
@RequestMapping("/api/users")
public class UserController {
    
    private final UserService userService;
    
    public UserController(UserService userService) {
        this.userService = userService;
    }
    
    @GetMapping
    public Flux<User> getAllUsers() {
        return userService.findAll();
    }
    
    @GetMapping("/{id}")
    public Mono<ResponseEntity<User>> getUserById(@PathVariable String id) {
        return userService.findById(id)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    @PostMapping
    public Mono<ResponseEntity<User>> createUser(@RequestBody @Valid User user) {
        return userService.create(user)
            .map(createdUser -> ResponseEntity.status(HttpStatus.CREATED).body(createdUser));
    }
    
    @PutMapping("/{id}")
    public Mono<ResponseEntity<User>> updateUser(@PathVariable String id, @RequestBody User user) {
        return userService.update(id, user)
            .map(ResponseEntity::ok)
            .defaultIfEmpty(ResponseEntity.notFound().build());
    }
    
    @DeleteMapping("/{id}")
    public Mono<ResponseEntity<Void>> deleteUser(@PathVariable String id) {
        return userService.delete(id)
            .then(Mono.just(ResponseEntity.noContent().build()));
    }
}
```

## 5. Продвинутые паттерны

### Реактивные транзакции (R2DBC)

```java
@Service
public class TransactionalService {
    
    private final TransactionalOperator transactionalOperator;
    private final UserRepository userRepository;
    
    public TransactionalService(ReactiveTransactionManager txManager, 
                               UserRepository userRepository) {
        this.transactionalOperator = TransactionalOperator.create(txManager);
        this.userRepository = userRepository;
    }
    
    public Mono<Void> transferBalance(String fromUser, String toUser, BigDecimal amount) {
        return userRepository.findByEmail(fromUser)
            .zipWith(userRepository.findByEmail(toUser))
            .flatMap(tuple -> {
                User from = tuple.getT1();
                User to = tuple.getT2();
                
                from.setBalance(from.getBalance().subtract(amount));
                to.setBalance(to.getBalance().add(amount));
                
                return userRepository.save(from)
                    .then(userRepository.save(to));
            })
            .as(transactionalOperator::transactional)
            .then();
    }
}
```

### Кастомные запросы с ReactiveMongoTemplate

```java
@Repository
public class CustomUserRepositoryImpl implements CustomUserRepository {
    
    private final ReactiveMongoTemplate mongoTemplate;
    
    public CustomUserRepositoryImpl(ReactiveMongoTemplate mongoTemplate) {
        this.mongoTemplate = memplate;
    }
    
    public Flux<User> findUsersWithAggregation() {
        Aggregation aggregation = Aggregation.newAggregation(
            Aggregation.match(Criteria.where("status").is("ACTIVE")),
            Aggregation.group("department").count().as("userCount"),
            Aggregation.project("userCount").and("department").previousOperation()
        );
        
        return mongoTemplate.aggregate(aggregation, "users", UserStats.class);
    }
}
```

## 6. Обработка ошибок

```java
@ControllerAdvice
public class GlobalErrorHandler {
    
    @ExceptionHandler(DataAccessException.class)
    public Mono<ResponseEntity<ErrorResponse>> handleDataAccessException(DataAccessException ex) {
        return Mono.just(ResponseEntity.status(HttpStatus.SERVICE_UNAVAILABLE)
            .body(new ErrorResponse("Database error", ex.getMessage())));
    }
    
    @ExceptionHandler(UserNotFoundException.class)
    public Mono<ResponseEntity<ErrorResponse>> handleUserNotFound(UserNotFoundException ex) {
        return Mono.just(ResponseEntity.status(HttpStatus.NOT_FOUND)
            .body(new ErrorResponse("User not found", ex.getMessage())));
    }
}
```

## Ключевые моменты:

1. **Всегда используйте реактивные типы** (Mono/Flux) по всей цепочке вызовов
2. **Избегайте блокирующих операций** внутри реактивных потоков
3. **Правильно обрабатывайте ошибки** с помощью операторов `onErrorResume`, `onErrorReturn`
4. **Используйте транзакции** для согласованности данных
5. **Тестируйте** с помощью `StepVerifier` из Project Reactor

Такой подход обеспечит полную неблокирующую обработку запросов и высокую производительность при работе с базами данных.