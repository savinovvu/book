**Механизм работы `@Transactional` и прокси в Spring**

---

### **1. Основная концепция**
Аннотация `@Transactional` обеспечивает **декларативное управление транзакциями**. Вместо ручного управления транзакциями в коде, Spring автоматически обрабатывает их через **AOP-прокси**.

---

### **2. Как создается прокси**
- **Режимы проксирования**:
    - **CGLIB** (по умолчанию для классов без интерфейсов): создает подкласс целевого класса.
    - **JDK Dynamic Proxies**: используется, если бин реализует интерфейс(ы).
- **Активация**: При включении `@EnableTransactionManagement` Spring настраивает `TransactionInterceptor` и создает прокси для бинов с `@Transactional`.

---

### **3. Работа прокси при вызове метода**
Когда вызывается метод с `@Transactional`, прокси перехватывает вызов и выполняет следующую логику:

#### **Этапы обработки**:
1. **Создание/Участие в транзакции**:
    - Проверяется наличие активной транзакции (согласно `propagation`, например, `REQUIRED`).
    - Если транзакции нет — создается новая (через `PlatformTransactionManager`).

2. **Выполнение целевого метода**:
    - Вызывается оригинальный метод бина внутри контекста транзакции.

3. **Обработка исключений**:
    - Если метод завершился успешно — транзакция фиксируется (`commit`).
    - Если произошло исключение:
        - Проверяются правила `rollbackFor`/`noRollbackFor`.
        - Если исключение подходит для отката — транзакция откатывается (`rollback`).

4. **Очистка ресурсов**:
    - Восстанавливается предыдущая транзакция (если была при `NESTED`/`REQUIRES_NEW`).
    - Закрываются соединения с БД (если применимо).

---

### **4. Детали реализации прокси**
#### **Пример псевдокода прокси**:
```java
public class TransactionalProxy extends MyService {
    private TransactionManager txManager;

    public void transactionalMethod() {
        TransactionStatus status = txManager.createTransactionIfNeeded();
        try {
            super.transactionalMethod(); // Вызов целевого метода
            txManager.commit(status);
        } catch (Exception e) {
            if (shouldRollback(e)) {
                txManager.rollback(status);
            }
            throw e;
        }
    }
}
```

#### **Важные нюансы**:
- **Self-invocation**: Если метод `A` вызывает метод `B` с `@Transactional` внутри того же класса, прокси не сработает (так как вызов идет минуя прокси). Решение:
    - Использование `self.autowiredBean.method()`.
    - Режим `AspectJ` (не AOP-прокси).

---

### **5. Настройки `@Transactional`**
- **Propagation**: Поведение при наличии транзакции (например, `REQUIRES_NEW` создает новую).
- **Isolation**: Уровень изоляции (например, `READ_COMMITTED`).
- **Timeout**: Максимальное время выполнения.
- **Read-only**: Оптимизации для операций чтения.
- **Rollback rules**: Какие исключения вызывают откат.

---

### **6. Взаимодействие с `PlatformTransactionManager`**
- Прокси делегирует управление транзакциями менеджеру (например, `DataSourceTransactionManager` для JDBC).
- Менеджер работает с `TransactionSynchronizationManager` для привязки ресурсов (например, соединения с БД) к текущему потоку.

---

### **7. Пример работы**
```java
@Service
class UserService {
    @Transactional
    public void createUser(User user) {
        userRepository.save(user);
        // При исключении здесь произойдет автоматический rollback
    }
}
```

**Что происходит**:
1. Прокси `UserService` перехватывает вызов `createUser`.
2. Открывается транзакция через `DataSourceTransactionManager`.
3. Вызывается `userRepository.save(user)`.
4. Если нет исключений — транзакция фиксируется.

---

### **8. Отладочные советы**
- Включите логирование для `@Transactional`:
  ```properties
  logging.level.org.springframework.transaction.interceptor=TRACE
  ```
- Проверяйте, что вызовы `@Transactional` идут через прокси (через Spring-бин, а не напрямую).

---

### **Заключение**
`@Transactional` в Spring — это мощный механизм, основанный на **AOP-прокси**, который автоматизирует управление транзакциями. Прокси перехватывает вызовы методов, делегируя управление транзакциями `PlatformTransactionManager`, и обеспечивает согласованность данных без侵入ности в бизнес-логику. Понимание работы прокси критично для избежания распространенных ошибок (например, self-invocation).