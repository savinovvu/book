Интеграция Spring с JPA/Hibernate — ключевой навык для Senior-разработчика. Разберем важные аспекты с примерами и лучшими практиками.

---

### **1. Конфигурация и настройка**
#### **Java-конфигурация (без XML)**
```java
@Configuration
@EnableTransactionManagement
@EnableJpaRepositories(basePackages = "com.example.repository")
public class JpaConfig {

    @Bean
    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {
        LocalContainerEntityManagerFactoryBean em = new LocalContainerEntityManagerFactoryBean();
        em.setDataSource(dataSource());
        em.setPackagesToScan("com.example.entity");
        em.setJpaVendorAdapter(new HibernateJpaVendorAdapter());
        em.setJpaProperties(additionalProperties());
        return em;
    }

    @Bean
    public DataSource dataSource() {
        return new HikariDataSource(); // Используем HikariCP для производительности
    }

    @Bean
    public PlatformTransactionManager transactionManager(EntityManagerFactory emf) {
        return new JpaTransactionManager(emf);
    }

    private Properties additionalProperties() {
        Properties properties = new Properties();
        properties.setProperty("hibernate.dialect", "org.hibernate.dialect.PostgreSQLDialect");
        properties.setProperty("hibernate.hbm2ddl.auto", "validate");
        properties.setProperty("hibernate.show_sql", "false");
        properties.setProperty("hibernate.format_sql", "true");
        // Кэширование второго уровня
        properties.setProperty("hibernate.cache.use_second_level_cache", "true");
        properties.setProperty("hibernate.cache.region.factory_class", "org.hibernate.cache.ehcache.EhCacheRegionFactory");
        return properties;
    }
}
```

---

### **2. Сущности и маппинг**
#### **Базовая сущность с ленивой загрузкой и оптимистичной блокировкой**
```java
@Entity
@Table(name = "users")
@Cacheable
@org.hibernate.annotations.Cache(usage = CacheConcurrencyStrategy.READ_WRITE)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false, unique = true)
    private String email;

    @OneToMany(mappedBy = "user", fetch = FetchType.LAZY, cascade = CascadeType.ALL)
    private List<Order> orders = new ArrayList<>();

    @Version
    private Long version; // Для оптимистичной блокировки

    // getters/setters
}
```

---

### **3. Репозитории с Spring Data JPA**
#### **Кастомный репозиторий с QueryDSL**
```java
public interface UserRepository extends JpaRepository<User, Long>, CustomUserRepository {
    
    // Держатель блокировки при запросе
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT u FROM User u WHERE u.id = :id")
    Optional<User> findByIdForUpdate(Long id);

    // Projection для DTO
    <T> List<T> findByEmail(String email, Class<T> type);
}

// Кастомные методы
public interface CustomUserRepository {
    List<User> findActiveUsers();
}

@Repository
public class CustomUserRepositoryImpl implements CustomUserRepository {

    @PersistenceContext
    private EntityManager em;

    @Override
    public List<User> findActiveUsers() {
        return em.createQuery("SELECT u FROM User u WHERE u.active = true", User.class)
                .getResultList();
    }
}
```

---

### **4. Транзакции и управление подключениями**
#### **Декларативное управление транзакциями**
```java
@Service
@Transactional
public class UserService {

    @Transactional(readOnly = true)
    public User getUserWithOrders(Long userId) {
        User user = userRepository.findById(userId).orElseThrow();
        user.getOrders().size(); // Инициируем ленивую загрузку в рамках транзакции
        return user;
    }

    @Transactional(propagation = Propagation.REQUIRES_NEW)
    public void updateUserInNewTransaction(User user) {
        userRepository.save(user);
    }
}
```

---

### **5. Производительность и кэширование**
#### **Кэширование второго уровня (EhCache)**
```yaml
# ehcache.xml
<config>
    <cache name="com.example.entity.User">
        <expiry>
            <tti>1800</tti> <!-- 30 минут -->
        </expiry>
        <heap>1000</heap>
    </cache>
</config>
```

#### **Батчинг для массовых операций**
```properties
# application.properties
spring.jpa.properties.hibernate.jdbc.batch_size=50
spring.jpa.properties.hibernate.order_inserts=true
spring.jpa.properties.hibernate.order_updates=true
```

```java
@Transactional
public void bulkInsert(List<User> users) {
    for (int i = 0; i < users.size(); i++) {
        entityManager.persist(users.get(i));
        if (i % 50 == 0) { // Соответствует batch_size
            entityManager.flush();
            entityManager.clear();
        }
    }
}
```

---

### **6. Обработка исключений**
#### **Кастомный обработчик для оптимистичной блокировки**
```java
@ControllerAdvice
public class JpaExceptionHandler {

    @ExceptionHandler(OptimisticLockingFailureException.class)
    public ResponseEntity<String> handleOptimisticLocking(OptimisticLockingFailureException ex) {
        return ResponseEntity.status(HttpStatus.CONFLICT)
                .body("Данные были изменены другим пользователем");
    }
}
```

---

### **7. Интеграционное тестирование**
```java
@DataJpaTest
@AutoConfigureTestDatabase(replace = AutoConfigureTestDatabase.Replace.NONE)
@TestPropertySource(properties = {
    "spring.datasource.url=jdbc:tc:postgresql:13-alpine:///test"
})
class UserRepositoryTest {

    @Autowired
    private TestEntityManager entityManager;

    @Autowired
    private UserRepository userRepository;

    @Test
    void shouldFindUserByEmail() {
        User user = new User();
        user.setEmail("test@example.com");
        entityManager.persistAndFlush(user);

        User found = userRepository.findByEmail("test@example.com", User.class).get(0);
        assertThat(found.getEmail()).isEqualTo(user.getEmail());
    }
}
```

---

### **8. Мониторинг и логирование**
#### **Логирование SQL с параметрами**
```properties
spring.jpa.show-sql=false
spring.jpa.properties.hibernate.format_sql=true
logging.level.org.hibernate.SQL=DEBUG
logging.level.org.hibernate.type.descriptor.sql.BasicBinder=TRACE
```

---

### **Ключевые принципы для Senior:**
1. **Инкапсуляция данных**: Не экспонируйте сущности напрямую в контроллеры — используйте DTO.
2. **Ленивая загрузка**: Всегда инициируйте `JOIN FETCH` или `@EntityGraph` для избежания N+1 проблем.
3. **Транзакционность**: Четко определяйте границы транзакций, избегайте `@Transactional` в контроллерах.
4. **Кэширование**: Используйте кэш второго уровня для часто читаемых редко изменяемых данных.
5. **Производительность**: Мониторьте количество запросов с помощью `spring.jpa.properties.hibernate.generate_statistics=true`.
6. **Миграции**: Используйте Flyway/Liquibase вместо `hibernate.hbm2ddl.auto=update`.

Пример использования DTO с MapStruct:
```java
@Mapper(componentModel = "spring")
public interface UserMapper {
    UserDTO toDTO(User user);
    User toEntity(UserDTO userDTO);
}

@Service
public class UserService {
    public UserDTO getUserDto(Long id) {
        return userMapper.toDTO(userRepository.findById(id).orElseThrow());
    }
}
```

Эти практики помогут построить надежное и производительное приложение с использованием Spring и JPA/Hibernate.