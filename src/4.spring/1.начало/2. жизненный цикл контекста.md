Полный жизненный цикл контекста Spring включает следующие этапы:

---

### **1. Загрузка конфигурации**
- **Описание**: Чтение конфигурационных метаданных (XML, аннотации, Java-конфигурация).
- **Детали**:
  - Для XML: парсинг `applicationContext.xml`.
  - Для аннотаций: сканирование пакетов (`@ComponentScan`).
  - Для Java-конфигурации: обработка классов с `@Configuration`.

---

### **2. Создание экземпляров бинов (Bean Instantiation)**
- **Описание**: Контейнер создает экземпляры бинов на основе их определений (`BeanDefinition`).
- **Детали**:
  - Бины с областью видимости **singleton** создаются на этапе инициализации контекста (если не указано `lazy-init=true`).
  - Для **prototype** бинов создание происходит при каждом запросе.
  - Используется рефлексия (конструктор по умолчанию или фабричные методы).

---

### **3. Внедрение зависимостей (Dependency Injection)**
- **Описание**: Заполнение свойств бина (через поля, сеттеры или конструктор).
- **Детали**:
  - Разрешение зависимостей по типу/имени.
  - Обработка `@Autowired`, `@Inject`, `@Resource`.
  - Циклические зависимости обрабатываются через механизм раннего создания прокси (при использовании `setter`/`field` injection).

---

### **4. Обработка BeanPostProcessor**
- **Этап 1**: `postProcessBeforeInitialization`  
  - Вызывается **до** методов инициализации бина.
  - Пример: логирование, проверка полей, создание прокси для `@Async`.

- **Этап 2**: `postProcessAfterInitialization`  
  - Вызывается **после** методов инициализации.
  - Пример: создание AOP-прокси (если бин помечен аннотациями `@Transactional`, `@Cacheable`).

---

### **5. Инициализация бинов**
- **Шаги**:
  1. Вызов методов, помеченных `@PostConstruct`.
  2. Реализация интерфейса `InitializingBean` (метод `afterPropertiesSet`).
  3. Вызов кастомного метода init (например, через `init-method` в XML или `@Bean(initMethod = "...")`).

---

### **6. Контекст готов к работе**
- **Описание**: Все бины проинициализированы, контекст отправляет событие `ContextRefreshedEvent`.
- **Детали**:
  - Можно подписаться на событие через `@EventListener(ContextRefreshedEvent.class)`.
  - В этот момент бины полностью готовы к использованию.

---

### **7. Использование бинов**
- **Описание**: Выполнение бизнес-логики приложения.
- **Детали**:
  - Singleton-бины переиспользуются.
  - Prototype-бины создаются заново при каждом запросе.

---

### **8. Уничтожение контекста**
- **Триггер**: Вызов `close()` для `ApplicationContext` (например, при завершении приложения).
- **Этапы**:
  1. Вызов методов, помеченных `@PreDestroy`.
  2. Реализация интерфейса `DisposableBean` (метод `destroy`).
  3. Вызов кастомного destroy-метода (через `destroy-method` или `@Bean(destroyMethod = "...")`).
  4. Освобождение ресурсов (например, закрытие соединений с БД).

---

### **Дополнительные аспекты (для Senior)**
1. **BeanFactoryPostProcessor**  
   - Позволяет модифицировать `BeanDefinition` до создания бинов (например, `PropertySourcesPlaceholderConfigurer` для `${...}`-замены).

2. **FactoryBean**  
   - Для создания бинов через кастомную фабрику (например, `SqlSessionFactoryBean` в MyBatis).

3. **Жизненный цикл в профилях и условиях**  
   - Бины могут создаваться условно (через `@Profile`, `@Conditional`).

4. **Lazy-инициализация**  
   - Бин создается только при первом обращении (`@Lazy`).

5. **Влияние AOP на жизненный цикл**  
   - Если бин обернут в прокси, методы жизненного цикла (например, `@PostConstruct`) вызываются для оригинального бина, а не прокси.

---

### **Визуализация**
```
Загрузка конфигурации 
    → Создание BeanDefinition 
    → BeanFactoryPostProcessor 
    → Создание экземпляров бинов 
    → DI 
    → BeanPostProcessor (before) 
    → Инициализация (@PostConstruct, afterPropertiesSet, init-method) 
    → BeanPostProcessor (after) 
    → ContextRefreshedEvent 
    → Использование 
    → @PreDestroy / destroy()
```

---

### **Пример кода**
```java
@Component
public class ExampleBean implements InitializingBean, DisposableBean {
    @PostConstruct
    public void postConstruct() {
        System.out.println("@PostConstruct");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("InitializingBean.afterPropertiesSet");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("@PreDestroy");
    }

    @Override
    public void destroy() {
        System.out.println("DisposableBean.destroy");
    }
}
```

Понимание этих этапов критично для диагностики проблем, оптимизации и расширения возможностей Spring.