**IOC (Inversion of Control)** — это принцип проектирования в программировании, при котором управление созданием и связыванием объектов передается внешнему контейнеру или фреймворку, вместо того чтобы объекты управляли своими зависимостями самостоятельно.

### Как IOC связан с Spring?
Spring Framework — это популярный фреймворк для Java, который реализует IOC через свой **IOC-контейнер**. Вот как это работает:

---

#### 1. **Основная идея IOC**
В традиционном программировании объекты сами создают свои зависимости (например, через `new`). При использовании IOC контроль «инвертируется»: контейнер Spring управляет жизненным циклом объектов (называемых **бинами**) и их зависимостями.

---

#### 2. **IOC-контейнер Spring**
Spring предоставляет контейнер, который:
- Создает бины.
- Связывает зависимости между бинами (через **Dependency Injection, DI**).
- Управляет их жизненным циклом.

Пример зависимости без Spring:
```java
class UserService {
    private UserRepository repository = new UserRepository(); // Жесткая связь
}
```

С Spring:
```java
@Component
class UserService {
    private final UserRepository repository;
    
    // Контейнер внедряет зависимость автоматически
    public UserService(UserRepository repository) {
        this.repository = repository;
    }
}
```

---

#### 3. **Как Spring реализует IOC?**
- **Конфигурация**: Вы описываете бины через аннотации (например, `@Component`, `@Service`) или XML-файлы.
- **Dependency Injection**: Spring внедряет зависимости через конструктор, сеттеры или поля (с помощью `@Autowired`).
- **Сканирование компонентов**: Spring автоматически находит и регистрирует бины в контексте приложения.

Пример:
```java
@Configuration
@ComponentScan("com.example")
public class AppConfig {
    // Конфигурация бинов
}

@Service
class OrderService {
    @Autowired
    private PaymentService paymentService; // Зависимость внедряется Spring
}
```

---

#### 4. **Преимущества IOC в Spring**
- **Слабая связность**: Классы не зависят от конкретных реализаций.
- **Тестируемость**: Легко подменять зависимости (например, с помощью моков).
- **Гибкость**: Конфигурация бинов меняется без изменения кода.
- **Упрощение кода**: Не нужно вручную создавать объекты и управлять их зависимостями.

---

#### 5. **Типы IOC-контейнеров в Spring**
- **BeanFactory**: Базовая реализация, предоставляет возможности для управления бинами.
- **ApplicationContext**: Расширенная версия, добавляет поддержку международization, событий и других функций Enterprise.

---

### Пример работы IOC в Spring
1. **Определение бинов**:
   ```java
   @Component
   public class EmailService {
       public void sendEmail(String message) {
           System.out.println("Sending email: " + message);
       }
   }
   ```

2. **Внедрение зависимости**:
   ```java
   @Service
   public class NotificationService {
       private final EmailService emailService;
       
       // Spring внедряет EmailService через конструктор
       public NotificationService(EmailService emailService) {
           this.emailService = emailService;
       }
   }
   ```

3. **Запуск контейнера**:
   ```java
   public class Main {
       public static void main(String[] args) {
           ApplicationContext context = new AnnotationConfigApplicationContext("com.example");
           NotificationService service = context.getBean(NotificationService.class);
           service.sendNotification("Hello IOC!");
       }
   }
   ```

---

### Итог
**IOC** — это ключевой принцип, который Spring реализует через **IOC-контейнер** и **Dependency Injection**. Это позволяет разработчикам сосредоточиться на бизнес-логике, делегируя управление зависимостями фреймворку.