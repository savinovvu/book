**Жизненный цикл бина в Spring (Senior-уровень)**

Жизненный цикл Spring-бина включает этапы от создания до уничтожения, с возможностью кастомизации через callback-методы и интерфейсы. Рассмотрим детали, важные для senior-разработчика.

---

### **Фазы жизненного цикла**
1. **Instantiation**
   - Создание экземпляра бина через конструктор (или фабричный метод).
   - Если используется **BeanFactory**, ленивая инициализация по умолчанию. Для **ApplicationContext** — большинство бинов создаются при старте контекста.

2. **Population of Properties**
   - Внедрение зависимостей через setter/поля (после создания экземпляра).
   - Обработка `@Autowired`, `@Value`, `@Resource`.

3. **Bean Post-Processing (до инициализации)**
   - `BeanPostProcessor.postProcessBeforeInitialization()` — кастомизация перед init-методами.
   - Пример: обработка аннотаций `@PostConstruct`, проксирование через AOP.

4. **Initialization**
   - Вызов методов, помеченных `@PostConstruct`.
   - Реализация `InitializingBean.afterPropertiesSet()`.
   - Кастомный init-метод (например, через `@Bean(initMethod = "init")`).

5. **Bean Post-Processing (после инициализации)**
   - `BeanPostProcessor.postProcessAfterInitialization()` — финальная настройка.
   - Здесь создаются прокси для AOP, если это необходимо.

6. **Bean Ready**
   - Бин полностью инициализирован и находится в контексте.
   - Может использоваться другими бинами.

7. **Destruction**
   - При закрытии контекста (`ctx.close()`) или остановке приложения.
   - Вызов `@PreDestroy` методов.
   - Реализация `DisposableBean.destroy()`.
   - Кастомный destroy-метод (`@Bean(destroyMethod = "cleanup")`).

---

### **Key Interfaces & Annotations**
- **`Aware`-интерфейсы**
  Позволяют получить доступ к контексту:
  - `BeanNameAware` — имя бина.
  - `BeanFactoryAware` — ссылка на BeanFactory.
  - `ApplicationContextAware` — доступ к контексту (инжектится до `@PostConstruct`).

- **`BeanPostProcessor`**
  Глобальный механизм для модификации бинов до/после инициализации.
  ```java
  @Component
  public class CustomBeanPostProcessor implements BeanPostProcessor {
      @Override
      public Object postProcessBeforeInitialization(Object bean, String beanName) {
          // Логика до инициализации
          return bean;
      }
  }
  ```

- **`@PostConstruct` / `@PreDestroy`**
  JSR-250 аннотации для методов инициализации и очистки. Выполняются до/после жизненного цикла Spring.

- **`InitializingBean` / `DisposableBean`**
  Spring-интерфейсы. Не рекомендуются из-за привязки к Spring API, но используются в рамках фреймворка.

---

### **Особенности для senior-разработчика**
1. **Порядок инициализации**
   - Зависит от порядка регистрации бинов и `@DependsOn`.
   - Циклические зависимости обходятся через прокси (при `setter`-инжекции).

2. **BeanPostProcessor и порядок**
   - `BeanPostProcessor`-ы регистрируются на ранних этапах и применяются ко всем бинам.
   - Их собственный жизненный цикл не обрабатывается через `BeanPostProcessor`.

3. **Proxy-бины**
   - AOP/CGLIB-прокси создаются на этапе `postProcessAfterInitialization`.
   - `@PostConstruct` вызывается для целевого бина, а не прокси.

4. **Scope-зависимое поведение**
   - Для `prototype`-бинов Spring не управляет полным жизненным циклом — destroy-методы не вызываются автоматически.
   - `@Scope("request")` — бин создается и уничтожается для каждого HTTP-запроса.

5. **Conditional Beans**
   - Бины, созданные через `@Conditional`, не регистрируются, если условие не выполнено.

---

### **Пример кастомизации**
```java
@Component
public class CustomBean implements InitializingBean, DisposableBean, BeanNameAware {
    private String beanName;

    @Override
    public void setBeanName(String name) {
        this.beanName = name;
    }

    @PostConstruct
    public void customInit() {
        System.out.println("Custom @PostConstruct");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("InitializingBean.afterPropertiesSet()");
    }

    @PreDestroy
    public void customDestroy() {
        System.out.println("Custom @PreDestroy");
    }

    @Override
    public void destroy() {
        System.out.println("DisposableBean.destroy()");
    }
}
```

---

### **Типичные проблемы**
- **Порядок инициализации** — зависимости между бинами могут приводить к непредсказуемому порядку вызова `@PostConstruct`.
- **Проксирование** — вызов `@PostConstruct` на проксированном бине может привести к исключениям, если прокси инициализируется раньше целевого объекта.
- **Memory leaks** — для `prototype`-бинов необходимо явно вызывать destroy-методы.

Понимание жизненного цикла критично для диагностики сложных проблем, таких как циклические зависимости, порядок инициализации и корректное освобождение ресурсов.