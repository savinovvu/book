**Spring Bean Scopes — области видимости бинов**  
В Spring Framework область видимости (scope) бина определяет его жизненный цикл и то, как он создается и используется в контексте приложения. Spring предоставляет несколько встроенных областей видимости, которые можно настраивать в зависимости от потребностей приложения.

---

### **Стандартные области видимости в Spring**
1. **Singleton (Одиночка)**
    - **Описание**: Создается **единственный экземпляр** бина на весь контейнер Spring. Это область по умолчанию.
    - **Использование**:
      ```java
      @Component
      @Scope("singleton") // или по умолчанию
      public class MyService { ... }
      ```  
    - **Важно**: Не подходит для состояния, зависящего от пользователя (например, в веб-приложениях).

2. **Prototype (Прототип)**
    - **Описание**: Каждый запрос бина через `getBean()` или инъекцию создает **новый экземпляр**.
    - **Использование**:
      ```java
      @Component
      @Scope("prototype")
      public class Processor { ... }
      ```  
    - **Особенности**: Spring не управляет полным жизненным циклом prototype-бина (метод `@PreDestroy` не вызывается).

---

### **Области видимости для веб-приложений**
Эти области доступны в контексте веб-приложений (например, Spring MVC).

3. **Request**
    - **Описание**: Создает отдельный экземпляр бина для **каждого HTTP-запроса**.
    - **Использование**:
      ```java
      @Component
      @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class RequestContext { ... }
      ```  
    - **Где использовать**: Хранение данных запроса, аутентификация.

4. **Session**
    - **Описание**: Создает экземпляр бина для **каждой HTTP-сессии**.
    - **Пример**:
      ```java
      @Component
      @Scope(value = "session", proxyMode = ScopedProxyMode.TARGET_CLASS)
      public class UserPreferences { ... }
      ```  
    - **Где использовать**: Настройки пользователя, корзина покупок.

5. **Application**
    - **Описание**: Бин создается на уровень **ServletContext** и общий для всех сессий.
    - **Пример**:
      ```java
      @Component
      @Scope("application")
      public class AppConfig { ... }
      ```  

6. **WebSocket**
    - **Описание**: Жизненный цикл привязан к WebSocket-сессии.

---

### **Настройка областей видимости**
- **Аннотации**:
  ```java
  @Scope(ConfigurableBeanFactory.SCOPE_PROTOTYPE)
  @Scope(WebApplicationContext.SCOPE_REQUEST)
  ```
- **XML**:
  ```xml
  <bean id="myBean" class="com.example.MyBean" scope="prototype"/>
  ```

---

### **Важные нюансы**
1. **Проксирование для Request/Session**  
   Для инъекции бинов с коротким scope (request, session) в бины с длинным scope (singleton) используется проксирование:
   ```java
   @Scope(value = "request", proxyMode = ScopedProxyMode.TARGET_CLASS)
   ```  
   Spring создает прокси, который обновляет бин при каждом запросе.

2. **Кастомные области видимости**  
   Можно создать свою область, реализовав интерфейс `Scope` и зарегистрировав его в контексте:
   ```java
   configurableBeanFactory.registerScope("myScope", new MyCustomScope());
   ```

3. **Потокобезопасность**
    - Singleton-бины должны быть **потокобезопасными**.
    - Request/Session-бины изолированы для каждого запроса/сессии.

---

### **Пример использования**
```java
@Service
@Scope(value = WebApplicationContext.SCOPE_REQUEST, proxyMode = ScopedProxyMode.TARGET_CLASS)
public class AuthService {
    private String user;
    // Логика, зависящая от запроса
}

@RestController
public class MyController {
    @Autowired
    private AuthService authService; // Для каждого запроса — новый экземпляр
}
```

---

### **Итог**
- **Singleton** — для stateless-компонентов (сервисы, репозитории).
- **Prototype** — для объектов с состоянием, которое не должно разделяться.
- **Request/Session** — для веб-приложений, где данные привязаны к запросу или сессии.
- Все области, кроме singleton, требуют аккуратного управления жизненным циклом и могут использовать прокси.


# Создание кастомной области видимости (Scope) в Spring

Spring позволяет создавать собственные области видимости бинов, реализуя интерфейс `Scope`. Рассмотрим подробный процесс.

## 1. Реализация интерфейса `Scope`

Создаем класс, реализующий `org.springframework.beans.factory.config.Scope`:

```java
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.config.Scope;
import java.util.HashMap;
import java.util.Map;

public class CustomThreadScope implements Scope {
    
    private final ThreadLocal<Map<String, Object>> threadScope = 
        ThreadLocal.withInitial(HashMap::new);

    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Map<String, Object> scope = threadScope.get();
        
        // Если объект еще не создан в текущем потоке - создаем его
        return scope.computeIfAbsent(name, key -> objectFactory.getObject());
    }

    @Override
    public Object remove(String name) {
        Map<String, Object> scope = threadScope.get();
        return scope.remove(name);
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        // В данной реализации не поддерживаем destruction callbacks
        // Для production кода нужно добавить логику очистки
        System.out.println("Destruction callback registered for: " + name);
    }

    @Override
    public Object resolveContextualObject(String key) {
        // Возвращаем null, если не нужно предоставлять контекстные объекты
        return null;
    }

    @Override
    public String getConversationId() {
        return String.valueOf(Thread.currentThread().getId());
    }
}
```

## 2. Более сложный пример с поддержкой очистки

```java
import org.springframework.beans.factory.ObjectFactory;
import org.springframework.beans.factory.config.Scope;
import java.util.Collections;
import java.util.HashMap;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

public class AdvancedCustomScope implements Scope {
    
    private final Map<String, Runnable> destructionCallbacks = 
        new ConcurrentHashMap<>();
    
    private final ThreadLocal<Map<String, Object>> beanMap = 
        ThreadLocal.withInitial(HashMap::new);

    @Override
    public Object get(String name, ObjectFactory<?> objectFactory) {
        Map<String, Object> scope = beanMap.get();
        
        return scope.computeIfAbsent(name, key -> {
            Object object = objectFactory.getObject();
            System.out.println("Created bean: " + name + " in thread: " + 
                Thread.currentThread().getName());
            return object;
        });
    }

    @Override
    public Object remove(String name) {
        Map<String, Object> scope = beanMap.get();
        
        // Вызываем callback уничтожения если он зарегистрирован
        destructionCallbacks.remove(name).run();
        
        return scope.remove(name);
    }

    @Override
    public void registerDestructionCallback(String name, Runnable callback) {
        destructionCallbacks.put(name, callback);
    }

    @Override
    public Object resolveContextualObject(String key) {
        // Можем вернуть thread-specific данные
        if ("threadName".equals(key)) {
            return Thread.currentThread().getName();
        }
        return null;
    }

    @Override
    public String getConversationId() {
        return "thread-" + Thread.currentThread().getId();
    }
    
    // Метод для очистки всех бинов в текущем потоке
    public void clear() {
        Map<String, Object> scope = beanMap.get();
        
        // Вызываем все destruction callbacks
        destructionCallbacks.forEach((name, callback) -> callback.run());
        destructionCallbacks.clear();
        
        scope.clear();
        beanMap.remove();
    }
}
```

## 3. Регистрация кастомного Scope в Spring контексте

### 3.1. Java Config подход

```java
import org.springframework.beans.factory.config.CustomScopeConfigurer;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class ScopeConfig {

    @Bean
    public static CustomScopeConfigurer customScopeConfigurer() {
        CustomScopeConfigurer configurer = new CustomScopeConfigurer();
        
        configurer.addScope("thread", new CustomThreadScope());
        configurer.addScope("custom", new AdvancedCustomScope());
        
        return configurer;
    }
}
```

### 3.2. XML Config подход

```xml
<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
       xsi:schemaLocation="http://www.springframework.org/schema/beans
        http://www.springframework.org/schema/beans/spring-beans.xsd">

    <bean class="org.springframework.beans.factory.config.CustomScopeConfigurer">
        <property name="scopes">
            <map>
                <entry key="thread">
                    <bean class="com.example.CustomThreadScope"/>
                </entry>
                <entry key="custom">
                    <bean class="com.example.AdvancedCustomScope"/>
                </entry>
            </map>
        </property>
    </bean>

</beans>
```

## 4. Использование кастомного Scope

### 4.1. Аннотационный подход

```java
@Component
@Scope("thread") // Используем наш кастомный scope
public class ThreadScopedBean {
    private final String createdInThread = Thread.currentThread().getName();
    
    public String getCreationThread() {
        return createdInThread;
    }
}

@Service
@Scope("custom")
public class CustomScopedService {
    private int invocationCount = 0;
    
    public void doSomething() {
        invocationCount++;
        System.out.println("Invoked " + invocationCount + " times");
    }
}
```

### 4.2. Java Config с явным указанием scope

```java
@Configuration
public class AppConfig {

    @Bean
    @Scope("thread")
    public Processor threadScopedProcessor() {
        return new Processor();
    }
    
    @Bean
    @Scope("custom") 
    public Service customScopedService() {
        return new Service();
    }
}
```

## 5. Пример использования с контроллером

```java
@RestController
public class TestController {
    
    @Autowired
    private ThreadScopedBean threadScopedBean;
    
    @Autowired
    private CustomScopedService customScopedService;
    
    @GetMapping("/test")
    public String test() {
        customScopedService.doSomething();
        
        return String.format(
            "ThreadScopedBean created in thread: %s, current thread: %s",
            threadScopedBean.getCreationThread(),
            Thread.currentThread().getName()
        );
    }
}
```

## 6. Интеграция с Spring Boot

Для Spring Boot приложения можно использовать `@EventListener` для очистки scope:

```java
@Component
public class ScopeCleanupListener {
    
    @Autowired
    private AdvancedCustomScope advancedCustomScope;

    // Очищаем scope при завершении контекста
    @EventListener
    public void onContextClosed(ContextClosedEvent event) {
        advancedCustomScope.clear();
    }
}
```

## 7. Тестирование кастомного Scope

```java
@SpringBootTest
class CustomScopeTest {

    @Autowired
    private ApplicationContext context;

    @Test
    void testThreadScope() {
        // В разных потоках должны быть разные экземпляры
        CompletableFuture<Object> future1 = CompletableFuture.supplyAsync(() -> 
            context.getBean("threadScopedBean"));
            
        CompletableFuture<Object> future2 = CompletableFuture.supplyAsync(() -> 
            context.getBean("threadScopedBean"));

        Object bean1 = future1.join();
        Object bean2 = future2.join();
        
        assertNotSame(bean1, bean2); // Должны быть разные экземпляры
    }
}
```

## Ключевые моменты:

1. **Реализация всех методов** интерфейса `Scope` обязательна
2. **Потокобезопасность** - важно для scope, используемых в многопоточных средах
3. **Управление жизненным циклом** - правильно обрабатывайте destruction callbacks
4. **Регистрация** scope должна происходить до создания бинов, которые его используют
5. **Очистка ресурсов** - предусмотрите механизмы очистки для избежания утечек памяти

Кастомные scope полезны для создания thread-local бинов, бинов с областью видимости на время транзакции, или любых других специфичных жизненных циклов.