В Spring аннотации `@Transactional` и `@Async` используются для управления транзакциями и асинхронным выполнением методов соответственно. Вот ключевые моменты их совместного использования:

---

### 1. **Особенности комбинации `@Async` и `@Transactional`**
- **Разные контексты выполнения**:  
  `@Async` запускает метод в отдельном потоке, а `@Transactional` управляет транзакцией в контексте этого потока. Транзакция **не передаётся** между потоками по умолчанию.
- **Новая транзакция**:  
  Если метод помечен обоими аннотациями, он будет выполняться в новой транзакции (если не заданы параметры `propagation`).

```java
@Async
@Transactional
public void processData() {
    // Этот метод выполняется асинхронно в отдельной транзакции
}
```

---

### 2. **Проблемы и решения**
#### **Проблема 1: Отсутствие передачи транзакции**
- Если вызвать асинхронный метод из другого метода с транзакцией, транзакция **не будет распространена** на асинхронный вызов. Это связано с тем, что Spring использует прокси для управления транзакциями и асинхронностью.

**Пример:**
```java
@Transactional
public void mainMethod() {
    // Эта транзакция не будет применена к asyncMethod
    asyncMethod(); // Выполняется в новом потоке без транзакции
}

@Async
public void asyncMethod() {
    // Требуется отдельная аннотация @Transactional
}
```

**Решение:**  
Добавьте `@Transactional` непосредственно в асинхронный метод.

---

#### **Проблема 2: Порядок аннотаций**
- Аннотации обрабатываются прокси Spring в определённом порядке:  
  `@Async` создаёт прокси, который может "оборачивать" `@Transactional`. Если порядок нарушен, транзакция может не открыться.

**Рекомендуемый порядок:**
```java
@Async
@Transactional(propagation = Propagation.REQUIRES_NEW)
public void asyncMethodWithTransaction() {
    // Код выполняется в новой транзакции
}
```

---

### 3. **Настройка транзакции для `@Async`**
- Используйте параметры `@Transactional` для управления поведением транзакции:
    - `propagation = Propagation.REQUIRES_NEW` — всегда запускает новую транзакцию.
    - `isolation`, `timeout`, `rollbackFor` и т.д.

```java
@Async
@Transactional(propagation = Propagation.REQUIRES_NEW, timeout = 5)
public void asyncMethodWithNewTransaction() {
    // Код выполняется в новой транзакции с таймаутом 5 секунд
}
```

---

### 4. **Требования**
- **Публичные методы**: Обе аннотации работают только для публичных методов.
- **Вызов между бинами**: Асинхронный/транзакционный метод должен вызываться из другого класса (через прокси Spring). Внутренние вызовы в пределах одного класса не сработают.

---

### 5. **Пример конфигурации**
**Включение асинхронности и транзакций:**
```java
@Configuration
@EnableAsync
@EnableTransactionManagement
public class AppConfig {
    // Настройка TaskExecutor для @Async
    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        return executor;
    }
}
```

---

### 6. **Важные предупреждения**
- **Откат транзакции**: Исключения в асинхронном методе должны быть обработаны внутри метода, иначе транзакция откатится.
- **Ожидание завершения**: Если нужно дождаться результата, используйте `Future<>`, но учтите, что это блокирует текущий поток.

```java
@Async
@Transactional
public Future<String> asyncMethodWithResult() {
    // ...
    return new AsyncResult<>("Result");
}
```

---

### Итог
- `@Async` и `@Transactional` могут работать вместе, но транзакция создаётся в новом потоке.
- Всегда помечайте асинхронный метод `@Transactional`, если ему нужна транзакция.
- Используйте `Propagation.REQUIRES_NEW`, чтобы изолировать транзакцию асинхронной задачи.