Жизненный цикл бина в Spring состоит из нескольких этапов, которые можно разделить на три основные фазы: **инициализация, использование и уничтожение**. Вот подробное описание каждого этапа:

---

### **1. Инициализация**
#### **Создание экземпляра (Instantiation)**
- Контейнер Spring создает экземпляр бина через конструктор (используя рефлексию или фабричные методы).
- Для бинов с областью видимости `singleton` (по умолчанию) это происходит при запуске контейнера. Для `prototype` — при каждом запросе.

#### **Внедрение зависимостей (Dependency Injection)**
- Spring заполняет поля бина (через сеттеры, конструктор или прямое присвоение) в соответствии с конфигурацией (`@Autowired`, `@Resource` или XML).

#### **Настройка свойств (Population Properties)**
- Устанавливаются свойства из конфигурации (например, значения из `application.properties` через `@Value`).

#### **Методы обратного вызова (Aware-интерфейсы)**
- Если бин реализует интерфейсы `Aware`, Spring вызывает соответствующие методы:
    - `BeanNameAware`: передает имя бина.
    - `BeanFactoryAware`: передает ссылку на `BeanFactory`.
    - `ApplicationContextAware`: передает контекст (например, для доступа к другим бинам).

#### **Предварительная инициализация (Bean Post-Processing)**
- Вызываются методы `BeanPostProcessor`:
    - `postProcessBeforeInitialization()`: логика перед инициализацией (например, работа с аннотациями `@PostConstruct`).
    - `postProcessAfterInitialization()`: логика после инициализации (например, создание прокси для AOP).

#### **Инициализация (Initialization)**
- Вызываются методы, помеченные аннотацией `@PostConstruct`.
- Если бин реализует `InitializingBean`, вызывается `afterPropertiesSet()`.
- Выполняется кастомный метод инициализации (указанный в `init-method` в XML или `@Bean(initMethod = "..."`).

---

### **2. Использование**
- Бин полностью готов и находится в контексте приложения. Он используется приложением для выполнения бизнес-логики.
- Для бинов с областью видимости `singleton` существует один экземпляр на весь контекст. Для `prototype` — каждый раз создается новый.

---

### **3. Уничтожение (Destruction)**
#### **Предварительное уничтожение**
- Вызываются методы, помеченные аннотацией `@PreDestroy`.
- Если бин реализует `DisposableBean`, вызывается `destroy()`.
- Выполняется кастомный метод уничтожения (указанный в `destroy-method` в XML или `@Bean(destroyMethod = "..."`).

#### **Очистка ресурсов**
- Spring освобождает ресурсы, связанные с бином (например, закрывает соединения с БД).
- Для бинов `prototype` контейнер не управляет уничтожением — это ответственность разработчика.

---

### **Визуализация жизненного цикла**
```
Создание → Внедрение зависимостей → Aware-методы → @PostConstruct → afterPropertiesSet() → init-method → Использование → @PreDestroy → destroy() → destroy-method
```

---

### **Особенности**
- **BeanPostProcessors** могут модифицировать бины на этапах до/после инициализации (например, для AOP, транзакций, валидации).
- Для **ленивых бинов** (`@Lazy`) инициализация происходит при первом обращении, а не при старте контекста.
- **FactoryBean** влияет на создание бинов через фабричные методы.

Пример настройки в коде:
```java
@Component
public class ExampleBean implements InitializingBean, DisposableBean {
    @PostConstruct
    public void init() {
        System.out.println("Инициализация через @PostConstruct");
    }

    @Override
    public void afterPropertiesSet() {
        System.out.println("Инициализация через afterPropertiesSet");
    }

    @PreDestroy
    public void preDestroy() {
        System.out.println("Уничтожение через @PreDestroy");
    }

    @Override
    public void destroy() {
        System.out.println("Уничтожение через destroy()");
    }
}
```

Понимание жизненного цикла бина помогает правильно управлять ресурсами, зависимостями и выполнять кастомную логику при создании/уничтожении объектов.