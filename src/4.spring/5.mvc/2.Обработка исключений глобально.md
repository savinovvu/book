Для глобальной обработки исключений в Spring приложениях используйте **`@ControllerAdvice`** (или **`@RestControllerAdvice`**) в сочетании с **`@ExceptionHandler`**. Это позволяет централизованно перехватывать и обрабатывать исключения из всех контроллеров.

### 1. Базовый пример
```java
@RestControllerAdvice
public class GlobalExceptionHandler {

    // Перехват конкретного исключения
    @ExceptionHandler(ResourceNotFoundException.class)
    public ResponseEntity<ErrorResponse> handleResourceNotFound(ResourceNotFoundException ex) {
        ErrorResponse error = new ErrorResponse("NOT_FOUND", ex.getMessage());
        return new ResponseEntity<>(error, HttpStatus.NOT_FOUND);
    }

    // Перехват общего исключения
    @ExceptionHandler(Exception.class)
    public ResponseEntity<ErrorResponse> handleAllExceptions(Exception ex) {
        ErrorResponse error = new ErrorResponse("INTERNAL_ERROR", "Произошла внутренняя ошибка");
        return new ResponseEntity<>(error, HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
```

### 2. Кастомизация через `@ControllerAdvice`
```java
// Обработка исключений только в указанных пакетах
@ControllerAdvice(basePackages = "com.example.controllers")
// Только для конкретных классов контроллеров
@ControllerAdvice(assignableTypes = {UserController.class, AdminController.class})
public class CustomExceptionHandler { ... }
```

### 3. Объект для ошибок (DTO)
```java
public class ErrorResponse {
    private String code;
    private String message;
    private Instant timestamp;

    // Конструктор, геттеры и сеттеры
    public ErrorResponse(String code, String message) {
        this.code = code;
        this.message = message;
        this.timestamp = Instant.now();
    }
}
```

### 4. Пример использования в контроллере
```java
@RestController
public class UserController {
    
    @GetMapping("/user/{id}")
    public User getUser(@PathVariable Long id) {
        return userService.findById(id)
                .orElseThrow(() -> new ResourceNotFoundException("User not found"));
    }
}
```

### 5. Расширенные сценарии
#### Валидация входных данных (Bean Validation):
```java
@ExceptionHandler(MethodArgumentNotValidException.class)
public ResponseEntity<ErrorResponse> handleValidationErrors(MethodArgumentNotValidException ex) {
    List<String> errors = ex.getBindingResult()
            .getFieldErrors()
            .stream()
            .map(FieldError::getDefaultMessage)
            .collect(Collectors.toList());
    
    ErrorResponse error = new ErrorResponse("VALIDATION_ERROR", errors.toString());
    return new ResponseEntity<>(error, HttpStatus.BAD_REQUEST);
}
```

#### Обработка кастомных исключений:
```java
@ExceptionHandler(BusinessException.class)
public ResponseEntity<ErrorResponse> handleBusinessException(BusinessException ex) {
    ErrorResponse error = new ErrorResponse(ex.getCode(), ex.getMessage());
    return new ResponseEntity<>(error, HttpStatus.CONFLICT);
}
```

### Ключевые моменты:
1. **`@RestControllerAdvice`** = `@ControllerAdvice` + `@ResponseBody` (автоматическая сериализация в JSON).
2. Методы `@ExceptionHandler` могут возвращать произвольные объекты и HTTP-статусы.
3. Порядок обработки: более конкретные исключения имеют приоритет.
4. Для исключений Spring MVC (например, `MethodArgumentNotValidException`) используйте готовые обработчики.

### Важно!
- Глобальный обработчик перехватывает исключения, выброшенные в контроллерах и их сервисах.
- Для обработки исключений безопасности используйте `AuthenticationEntryPoint` и `AccessDeniedHandler`.
- Тестируйте обработку исключений через интеграционные тесты с `@WebMvcTest`.