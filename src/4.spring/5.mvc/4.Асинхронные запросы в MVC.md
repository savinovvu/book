Для реализации асинхронных запросов в Spring MVC с использованием `DeferredResult`, `CompletableFuture` и `@Async`, выполните следующие шаги. Эти подходы позволяют освободить поток контейнера сервлетов и обработать запрос в отдельном потоке, повышая производительность приложений с долгими операциями.

---

### **1. Настройка асинхронной поддержки**
Включите асинхронную обработку в конфигурации Spring:
```java
@Configuration
@EnableAsync
public class AsyncConfig {
    // Дополнительные настройки пула потоков (опционально)
    @Bean
    public TaskExecutor taskExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        executor.setCorePoolSize(5);
        executor.setMaxPoolSize(10);
        executor.setQueueCapacity(25);
        return executor;
    }
}
```
- `@EnableAsync` активирует поддержку `@Async`.
- `TaskExecutor` настраивает пул потоков (по умолчанию используется `SimpleAsyncTaskExecutor`).

---

### **2. Использование `DeferredResult`**
Позволяет вручную управлять результатом запроса из другого потока.

**Пример контроллера:**
```java
@RestController
public class AsyncController {
    private final Queue<DeferredResult<String>> deferredResults = new ConcurrentLinkedQueue<>();

    @GetMapping("/deferred")
    public DeferredResult<String> handleDeferred() {
        DeferredResult<String> deferredResult = new DeferredResult<>(5000L, "Timeout Response");
        deferredResults.add(deferredResult);

        // Имитация асинхронной обработки
        CompletableFuture.runAsync(() -> {
            try {
                Thread.sleep(2000);
                deferredResult.setResult("Hello from DeferredResult!");
            } catch (InterruptedException e) {
                deferredResult.setErrorResult("Error occurred");
            }
        });

        return deferredResult;
    }
}
```
- **Таймаут**: Указывается в конструкторе (здесь 5 секунд).
- **Обработка**: Результат устанавливается вручную через `setResult()`.

---

### **3. Использование `CompletableFuture`**
Возвращает `CompletableFuture` для асинхронной обработки.

**Пример контроллера:**
```java
@RestController
public class AsyncController {
    @Autowired
    private AsyncService asyncService;

    @GetMapping("/completable")
    public CompletableFuture<String> handleCompletable() {
        return asyncService.asyncMethod();
    }
}
```

**Сервис с `@Async`:**
```java
@Service
public class AsyncService {
    @Async
    public CompletableFuture<String> asyncMethod() {
        // Имитация долгой задачи
        return CompletableFuture.supplyAsync(() -> {
            try {
                Thread.sleep(2000);
                return "Hello from CompletableFuture!";
            } catch (InterruptedException e) {
                throw new RuntimeException(e);
            }
        });
    }
}
```
- `@Async` гарантирует выполнение метода в отдельном потоке.
- `CompletableFuture.supplyAsync()` используется для обертки результата.

---

### **4. Обработка исключений**
- Для `DeferredResult`: Используйте `setErrorResult()`.
- Для `CompletableFuture`: Обрабатывайте исключения в методе:
  ```java
  @Async
  public CompletableFuture<String> asyncMethodWithError() {
      return CompletableFuture.supplyAsync(() -> {
          if (someCondition) {
              throw new RuntimeException("Error");
          }
          return "Success";
      }).exceptionally(ex -> "Fallback: " + ex.getMessage());
  }
  ```

---

### **5. Важные замечания**
1. **Пул потоков**: Настройте `TaskExecutor`, чтобы избежать создания потоков для каждого запроса.
2. **Таймауты**: Всегда устанавливайте таймауты для `DeferredResult` и `CompletableFuture`.
3. **Контекст безопасности**: В асинхронных методах теряется контекст SecurityContext. Используйте `SecurityContextHolder.setContext()` для передачи контекста.

---

### **Пример полной конфигурации**
```java
@SpringBootApplication
@EnableAsync
public class Application {
    public static void main(String[] args) {
        SpringApplication.run(Application.class, args);
    }
}
```

**Контроллер с двумя эндпоинтами:**
```java
@RestController
public class AsyncController {
    @Autowired
    private AsyncService asyncService;

    @GetMapping("/deferred")
    public DeferredResult<String> deferred() {
        DeferredResult<String> result = new DeferredResult<>();
        asyncService.processDeferred(result);
        return result;
    }

    @GetMapping("/completable")
    public CompletableFuture<String> completable() {
        return asyncService.processCompletable();
    }
}
```

**Сервис:**
```java
@Service
public class AsyncService {
    @Async
    public void processDeferred(DeferredResult<String> result) {
        // Логика обработки
        result.setResult("Done");
    }

    @Async
    public CompletableFuture<String> processCompletable() {
        return CompletableFuture.completedFuture("Done");
    }
}
```

---

**Итог:**
- **`DeferredResult`** для ручного управления результатом.
- **`CompletableFuture`** для интеграции с Java Concurrency API.
- **`@Async`** для упрощения асинхронного выполнения методов.

Эти инструменты позволяют эффективно обрабатывать долгие операции без блокировки потоков контейнера сервлетов.