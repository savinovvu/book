Отличный вопрос! Эти три аннотации — фундамент для работы с входящими HTTP-запросами в Spring, и понимание их различий критически важно для Spring-разработчика. Давайте разберем их подробно.

### Краткая суть

*   **`@RequestParam`** — для параметров запроса (после `?` в URL).
*   **`@PathVariable`** — для извлечения части самого URL (шаблон в пути).
*   **`@RequestHeader`** — для получения значений из HTTP-заголовков.

---

### Детальное сравнение

#### 1. `@RequestParam` (Параметр запроса)

*   **Что извлекает:** Значения **параметров запроса** (query parameters). Это пары "ключ=значение", которые идут после знака `?` в URL.
*   **Источник:** URL строка запроса.
*   **Синтаксис URL:** `...path?paramName=paramValue&anotherParam=...`
*   **Обязательность:** По умолчанию параметр обязателен (`required = true`). Если он не передан, будет выброшено исключение `MissingServletRequestParameterException`. Можно изменить на `required = false`.
*   **Значение по умолчанию:** Можно задать через `defaultValue = "defaultValue"`.
*   **Типы данных:** Может быть простым типом (String, int, Long) или сложным объектом (если совпадает имя поля и параметр).
*   **Когда использовать:** Для фильтрации, сортировки, пагинации, необязательных данных.

**Пример:**
```java
// Запрос: GET /api/users?role=admin&page=2

@GetMapping("/api/users")
public ResponseEntity<?> getUsers(
    @RequestParam String role,         // role = "admin"
    @RequestParam(defaultValue = "1") int page // page = 2 (если не указан, будет 1)
) {
    // логика
}
```

---

#### 2. `@PathVariable` (Переменная пути)

*   **Что извлекает:** Часть **самого пути URL**. Используется для создания чисто RESTful-ресурсов, где URL идентифицирует сущность.
*   **Источник:** Сегмент URI (шаблон пути).
*   **Синтаксис URL:** `...path/{variableName}/...`
*   **Обязательность:** По умолчанию **обязателен**. Если шаблон есть в маппинге, но переменная не извлечена, это ошибка компиляции/конфигурации.
*   **Когда использовать:** Для идентификации уникального ресурса. Например, получение, обновление или удаление сущности по её ID.

**Пример:**
```java
// Запрос: GET /api/users/42

@GetMapping("/api/users/{userId}")
public ResponseEntity<?> getUserById(
    @PathVariable Long userId // userId = 42
) {
    // логика поиска пользователя с ID = 42
}
```

---

#### 3. `@RequestHeader` (Заголовок запроса)

*   **Что извлекает:** Значение из **HTTP-заголовка** запроса.
*   **Источник:** Заголовки HTTP-запроса (например, `Authorization`, `User-Agent`, `Content-Type`).
*   **Синтаксис URL:** Не имеет прямого отношения к URL. Заголовки передаются "под капотом" HTTP-протокола.
*   **Обязательность:** По умолчанию необязателен (`required = false`).
*   **Когда использовать:** Когда логика зависит от мета-информации запроса: аутентификация/авторизация (токен в `Authorization`), определение типа клиента, работа с кешем, локализация и т.д.

**Пример:**
```java
// Запрос с заголовком: Authorization: Bearer jwt_token_value

@GetMapping("/api/profile")
public ResponseEntity<?> getUserProfile(
    @RequestHeader("Authorization") String authHeader // authHeader = "Bearer jwt_token_value"
) {
    // логика извлечения и проверки JWT токена
}
```

---

### Сводная таблица

| Характеристика | `@RequestParam` | `@PathVariable` | `@RequestHeader` |
| :--- | :--- | :--- | :--- |
| **Источник данных** | Параметры URL (после `?`) | Сегмент URI пути | HTTP-заголовки |
| **Пример URL** | `/users?page=2&size=10` | `/users/123` | (Невидимы в URL) |
| **Синтаксис** | `?key=value&key2=value2` | `/path/{variable}` | `HeaderName: Value` |
| **Обязательность** | `required=true` (по умолч.) | `required=true` (по умолч.) | `required=false` (по умолч.) |
| **Основное использование** | Опциональные параметры, фильтрация | Идентификация ресурсов | Мета-информация, аутентификация |

### Комбинированное использование (Senior Moment)

Настоящая сила проявляется, когда вы используете их вместе в одном методе контроллера для построения гибкого и мощного API.

**Пример: Получение отзывов о товаре с пагинацией и проверкой локали**

```java
// Запрос: GET /api/products/15/reviews?page=0&size=20
// Заголовок: Accept-Language: en-US

@GetMapping("/api/products/{productId}/reviews")
public ResponseEntity<Page<Review>> getProductReviews(
        // Идентифицируем конкретный продукт по пути
        @PathVariable Long productId,

        // Параметры пагинации (необязательные, с значениями по умолчанию)
        @RequestParam(defaultValue = "0") int page,
        @RequestParam(defaultValue = "20") int size,

        // Заголовок для предоставления локализованного контента
        @RequestHeader(value = "Accept-Language", required = false) String locale
) {
    // 1. По productId находим продукт
    // 2. Используем page и size для пагинации запроса в БД
    // 3. locale можно использовать, чтобы вернуть отзывы на нужном языке
    // ...

    return ResponseEntity.ok(reviewPage);
}
```

**Заключение для Senior-разработчика:** Правильный выбор аннотации — это не только вопрос работоспособности кода, но и семантики REST, читаемости API и его предсказуемости для клиентов. `@PathVariable` для иерархии ресурсов, `@RequestParam` для их модификации (фильтры, настройки), а `@RequestHeader` для служебной информации, управляющей процессом обработки запроса.



Отличный вопрос! Это фундаментальное различие в архитектуре HTTP. Давайте разберем по полочкам.

## Местоположение в HTTP-запросе

**Параметры запроса (Query Parameters)** - часть **URL**:
```
GET /api/users?page=1&sort=name&filter=active HTTP/1.1
└───── URL path ───┘└─────────── Query String ─────────┘
```

**Заголовки (Headers)** - отдельная секция **после стартовой строки**:
```
GET /api/users?page=1 HTTP/1.1
Host: api.example.com
Authorization: Bearer xyz123
Content-Type: application/json
User-Agent: Mozilla/5.0...
└────────────────── Headers ──────────────────┘
```

---

## Семантика и назначение

### Параметры запроса
- **Назначение**: Параметры **приложения/бизнес-логики**
- **Контекст**: Специфичны для конкретного endpoint'а
- **Примеры**:
    - `?page=1&size=20` - пагинация
    - `?sort=name&order=desc` - сортировка
    - `?category=electronics&price_max=1000` - фильтрация
    - `?search=keyword` - поиск

### Заголовки HTTP
- **Назначение**: **Мета-информация** о запросе
- **Контекст**: Общие для всего HTTP-протокола
- **Примеры**:
    - `Authorization: Bearer token` - аутентификация
    - `Content-Type: application/json` - формат тела запроса
    - `User-Agent: Mozilla/5.0...` - информация о клиенте
    - `Accept-Language: en-US` - предпочтительный язык

---

## Технические различия

| Характеристика | Параметры запроса | Заголовки HTTP |
|----------------|-------------------|----------------|
| **Местоположение** | В URL (после `?`) | Отдельная секция HTTP-запроса |
| **Видимость** | Видны в браузере, логируются | Скрыты от обычного пользователя |
| **Кэширование** | Участвуют в ключе кэша | Могут влиять на кэширование |
| **Длина** | Ограничены длиной URL (~2048 chars) | Практически без ограничений |
| **Безопасность** | Не для чувствительных данных | Могут содержать токены, ключи |

---

## Практические примеры

### Пример запроса с обоими типами
```
POST /api/orders?validate=true&callback=order_created HTTP/1.1
Host: api.store.com
Authorization: Bearer eyJhbGciOiJIUzI1NiIs...
Content-Type: application/json
X-API-Key: 12345-abcde
User-Agent: MyApp/1.0

{"productId": 123, "quantity": 2}
```

**Параметры запроса** (бизнес-логика):
- `validate=true` - валидировать заказ перед созданием
- `callback=order_created` - имя callback-функции

**Заголовки** (мета-информация):
- `Authorization` - токен доступа
- `Content-Type` - формат тела запроса (JSON)
- `X-API-Key` - идентификатор клиента
- `User-Agent` - информация о клиентском приложении

---

## Когда что использовать?

### Используйте параметры запроса для:
- **Фильтрации данных**: `?category=books&price_min=20`
- **Пагинации**: `?page=2&size=50`
- **Сортировки**: `?sort=price&order=desc`
- **Поиска**: `?q=spring+boot`
- **Опциональных флагов**: `?includeMetadata=true`

### Используйте заголовки для:
- **Аутентификации**: `Authorization: Bearer ...`
- **Определения формата**: `Accept: application/json`
- **Кэширования**: `If-None-Match: "abc123"`
- **Безопасности**: `X-CSRF-Token: ...`
- **Отладки**: `X-Request-ID: uuid`

---

## Spring-специфика

```java
@GetMapping("/api/search")
public ResponseEntity<?> search(
    // Параметры запроса - специфичны для этого endpoint
    @RequestParam String query,
    @RequestParam(defaultValue = "1") int page,
    
    // Заголовки - могут использоваться глобально
    @RequestHeader("Authorization") String auth,
    @RequestHeader(value = "User-Agent", required = false) String userAgent
) {
    // Заголовки часто обрабатываются глобально (интерсепторами, фильтрами)
    // Параметры запроса - обрабатываются непосредственно в контроллере
}
```

**Ключевой вывод**: Параметры запроса определяют **"что"** вы хотите получить, а заголовки определяют **"как"** этот запрос должен быть обработан.