Для реализации JWT аутентификации в реактивном стеке Spring (WebFlux) необходимо выполнить следующие шаги. Пример использует современный подход с функциональными бинами и реактивными компонентами.

### 1. **Зависимости (Maven/Gradle)**
```gradle
dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-webflux'
    implementation 'org.springframework.boot:spring-boot-starter-security'
    implementation 'io.jsonwebtoken:jjwt-api:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-impl:0.11.5'
    runtimeOnly 'io.jsonwebtoken:jjwt-jackson:0.11.5'
}
```

### 2. **Конфигурация JWT утилит**
```java
@Component
public class JwtUtil {
    private final String secret = "your-secret-key";
    private final Duration expiration = Duration.ofHours(1);

    public String generateToken(Authentication authentication) {
        String username = authentication.getName();
        Date now = new Date();
        Date expiry = new Date(now.getTime() + expiration.toMillis());

        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(now)
                .setExpiration(expiry)
                .signWith(SignatureAlgorithm.HS256, secret)
                .compact();
    }

    public Mono<Claims> validateToken(String token) {
        return Mono.fromCallable(() -> 
            Jwts.parserBuilder()
                .setSigningKey(secret)
                .build()
                .parseClaimsJws(token)
                .getBody()
        ).onErrorResume(e -> Mono.empty());
    }
}
```

### 3. **Реактивный AuthenticationManager**
```java
@Configuration
public class SecurityConfig {

    @Bean
    public ReactiveAuthenticationManager authenticationManager(
            ReactiveUserDetailsService userDetailsService) {
        return authentication -> {
            String username = authentication.getName();
            return userDetailsService.findByUsername(username)
                    .filter(userDetails -> 
                        PasswordEncoderFactories
                            .createDelegatingPasswordEncoder()
                            .matches(authentication.getCredentials().toString(), 
                                     userDetails.getPassword())
                    )
                    .switchIfEmpty(Mono.error(new BadCredentialsException("Invalid credentials")))
                    .map(userDetails -> new UsernamePasswordAuthenticationToken(
                            userDetails.getUsername(),
                            userDetails.getPassword(),
                            userDetails.getAuthorities()
                    ));
        };
    }
}
```

### 4. **JWT Authentication WebFilter**
```java
@Component
public class JwtAuthenticationFilter implements WebFilter {
    private final JwtUtil jwtUtil;
    private final ReactiveAuthenticationManager authenticationManager;

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        
        if (token == null) {
            return chain.filter(exchange);
        }

        return jwtUtil.validateToken(token)
                .flatMap(claims -> {
                    String username = claims.getSubject();
                    return authenticationManager.authenticate(
                        new UsernamePasswordAuthenticationToken(username, null)
                    );
                })
                .flatMap(authentication -> {
                    SecurityContextHolder.getContext().setAuthentication(authentication);
                    return chain.filter(exchange);
                })
                .switchIfEmpty(chain.filter(exchange));
    }

    private String extractToken(ServerHttpRequest request) {
        String header = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (header != null && header.startsWith("Bearer ")) {
            return header.substring(7);
        }
        return null;
    }
}
```

### 5. **Конфигурация Security**
```java
@EnableWebFluxSecurity
public class SecurityConfiguration {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(
            ServerHttpSecurity http,
            JwtAuthenticationFilter jwtFilter) {
        
        return http
            .csrf(ServerHttpSecurity.CsrfSpec::disable)
            .authorizeExchange(exchanges -> 
                exchanges
                    .pathMatchers("/auth/login").permitAll()
                    .anyExchange().authenticated()
            )
            .addFilterAt(jwtFilter, SecurityWebFiltersOrder.AUTHENTICATION)
            .build();
    }
}
```

### 6. **Authentication Controller**
```java
@RestController
public class AuthController {
    private final JwtUtil jwtUtil;
    private final ReactiveAuthenticationManager authenticationManager;

    @PostMapping("/auth/login")
    public Mono<ResponseEntity<AuthResponse>> login(@RequestBody AuthRequest request) {
        return authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(
                    request.getUsername(), 
                    request.getPassword()
                )
            )
            .map(authentication -> {
                String token = jwtUtil.generateToken(authentication);
                return ResponseEntity.ok(new AuthResponse(token));
            })
            .onErrorReturn(ResponseEntity.status(HttpStatus.UNAUTHORIZED).build());
    }

    public record AuthRequest(String username, String password) {}
    public record AuthResponse(String token) {}
}
```

### 7. **ReactiveUserDetailsService**
```java
@Service
public class ReactiveUserDetailsServiceImpl implements ReactiveUserDetailsService {
    
    private final Map<String, UserDetails> users = Map.of(
        "user", User.withUsername("user")
                   .password("{bcrypt}$2a$10$...")
                   .roles("USER")
                   .build()
    );

    @Override
    public Mono<UserDetails> findByUsername(String username) {
        return Mono.justOrEmpty(users.get(username));
    }
}
```

### Ключевые моменты:
1. **Реактивность**: Все операции выполняются неблокирующим образом с использованием Mono/Flux.
2. **JWT Filter**: Перехватывает запросы и проверяет JWT токен.
3. **AuthenticationManager**: Проверяет учетные данные и создает контекст аутентификации.
4. **Безопасность паролей**: Используется DelegatingPasswordEncoder.
5. **Обработка ошибок**: Все ошибки аутентификации обрабатываются в реактивном потоке.

### Дополнительные улучшения:
- Добавьте обработку refresh-токенов
- Реализуйте черный список токенов при logout
- Настройте CORS и прочие политики безопасности
- Добавьте мониторинг и логирование событий аутентификации
- Используйте секреты из внешней конфигурации (Vault, Config Server)

Пример тестирования можно выполнить с помощью WebTestClient, проверяя защищенные и публичные эндпоинты.