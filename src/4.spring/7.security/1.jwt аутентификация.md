Рассмотрим детальную реализацию JWT-аутентификации в Spring Security с акцентом на создание `JwtAuthenticationFilter` и интеграцию с `SecurityContextHolder`.

---

### 1. **Общий поток аутентификации через JWT**
1. Клиент отправляет учетные данные (логин/пароль) на эндпоинт входа.
2. Сервер проверяет учетные данные и генерирует JWT.
3. Клиент включает JWT в заголовок `Authorization: Bearer <token>` последующих запросов.
4. `JwtAuthenticationFilter` проверяет токен и устанавливает аутентификацию в `SecurityContextHolder`.

---

### 2. **Зависимости**
```xml
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-api</artifactId>
    <version>0.11.5</version>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-impl</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
<dependency>
    <groupId>io.jsonwebtoken</groupId>
    <artifactId>jjwt-jackson</artifactId>
    <version>0.11.5</version>
    <scope>runtime</scope>
</dependency>
```

---

### 3. **Класс для работы с JWT (JwtUtils)**
```java
@Component
public class JwtUtils {
    private final String secret = "your-secret-key"; // Вынеси в properties
    private final long expiration = 864000000; // 10 дней

    public String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + expiration))
                .signWith(SignatureAlgorithm.HS512, secret)
                .compact();
    }

    public boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(secret).parseClaimsJws(token);
            return true;
        } catch (JwtException | IllegalArgumentException e) {
            return false;
        }
    }

    public String getUsernameFromToken(String token) {
        return Jwts.parser()
                .setSigningKey(secret)
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
}
```

---

### 4. **JwtAuthenticationFilter**
Фильтр перехватывает запросы и проверяет JWT из заголовка.

```java
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {
    private final JwtUtils jwtUtils;
    private final UserDetailsService userDetailsService;

    public JwtAuthenticationFilter(JwtUtils jwtUtils, UserDetailsService userDetailsService) {
        this.jwtUtils = jwtUtils;
        this.userDetailsService = userDetailsService;
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain chain) throws ServletException, IOException {
        try {
            String jwt = parseJwt(request);
            if (jwt != null && jwtUtils.validateToken(jwt)) {
                String username = jwtUtils.getUsernameFromToken(jwt);
                UserDetails userDetails = userDetailsService.loadUserByUsername(username);
                
                UsernamePasswordAuthenticationToken auth = new UsernamePasswordAuthenticationToken(
                    userDetails, 
                    null, 
                    userDetails.getAuthorities()
                );
                auth.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                
                // Интеграция с SecurityContextHolder
                SecurityContextHolder.getContext().setAuthentication(auth);
            }
        } catch (Exception e) {
            logger.error("Cannot set user authentication: {}", e);
        }
        chain.doFilter(request, response);
    }

    private String parseJwt(HttpServletRequest request) {
        String headerAuth = request.getHeader("Authorization");
        if (StringUtils.hasText(headerAuth) && headerAuth.startsWith("Bearer ")) {
            return headerAuth.substring(7);
        }
        return null;
    }
}
```

---

### 5. **Настройка SecurityConfig**
```java
@Configuration
@EnableWebSecurity
@EnableGlobalMethodSecurity(prePostEnabled = true)
public class SecurityConfig {
    private final JwtAuthenticationFilter jwtAuthFilter;

    public SecurityConfig(JwtAuthenticationFilter jwtAuthFilter) {
        this.jwtAuthFilter = jwtAuthFilter;
    }

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http
            .csrf(AbstractHttpConfigurer::disable)
            .sessionManagement(session -> 
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
            .authorizeHttpRequests(authz -> authz
                .requestMatchers("/auth/login").permitAll()
                .anyRequest().authenticated()
            )
            .addFilterBefore(jwtAuthFilter, UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }
}
```

---

### 6. **Эндпоинт для аутентификации**
```java
@RestController
public class AuthController {
    private final AuthenticationManager authenticationManager;
    private final JwtUtils jwtUtils;

    public AuthController(AuthenticationManager authenticationManager, JwtUtils jwtUtils) {
        this.authenticationManager = authenticationManager;
        this.jwtUtils = jwtUtils;
    }

    @PostMapping("/auth/login")
    public ResponseEntity<String> login(@RequestBody AuthRequest request) {
        try {
            Authentication auth = authenticationManager.authenticate(
                new UsernamePasswordAuthenticationToken(request.getUsername(), request.getPassword())
            );
            
            SecurityContextHolder.getContext().setAuthentication(auth);
            String jwt = jwtUtils.generateToken(request.getUsername());
            return ResponseEntity.ok(jwt);
        } catch (BadCredentialsException e) {
            return ResponseEntity.status(401).body("Invalid credentials");
        }
    }
}
```

---

### 7. **Ключевые моменты для Senior-разработчика**
1. **Stateless-архитектура**: Сессии не хранятся на сервере. Весь состояние аутентификации содержится в JWT.
2. **Безопасность токенов**:
    - Используйте `HS512` или `RS512` для подписи.
    - Храните секретный ключ в защищенном месте (Vault, KMS).
    - Реализуйте механизм отзыва токенов через blacklist или короткое время жизни.
3. **Производительность**: `JwtAuthenticationFilter` выполняется на каждый запрос. Оптимизируйте проверку токена.
4. **Тестирование**: Мокируйте `JwtUtils` и `UserDetailsService` в интеграционных тестах.
5. **Микросервисы**: В распределенных системах используйте централизованную валидацию токенов через OAuth2 Server.

---

### 8. **Дополнительные улучшения**
- Добавьте обработку refresh-токенов.
- Реализуйте кастомные исключения для обработки ошибок JWT.
- Используйте `@PreAuthorize` для метод-левел безопасности.
- Внедрите мониторинг попыток неавторизованного доступа.

Пример кастомного исключения:
```java
public class JwtAuthenticationException extends AuthenticationException {
    public JwtAuthenticationException(String msg) {
        super(msg);
    }
}
```

---

Этот код дает промышленное решение для JWT-аутентификации с правильной интеграцией в Spring Security Ecosystem. Для проектов уровня Senior важно обеспечить масштабируемость, безопасность и удобство поддержки.