Отличный вопрос! Это краеугольные камни безопасности, и Spring Security построен именно на этом разделении. Объясню максимально подробно, как и подобает Senior-специалисту.

### Краткий ответ (TL;DR)

*   **Authentication (Аутентификация)** — это ответ на вопрос **"Кто ты?"**. Это процесс проверки подлинности пользователя (или системы).
*   **Authorization (Авторизация)** — это ответ на вопрос **"Что тебе разрешено?"**. Это процесс проверки прав доступа к ресурсам.

Теперь давайте углубимся.

---

### Authentication (Аутентификация) — "Кто ты?"

Это процесс проверки учетных данных (credentials) пользователя для подтверждения его личности. Система пытается удостовериться, что вы именно тот, за кого себя выдаете.

**Как это работает?**
Пользователь предоставляет свои учетные данные. Система проверяет их против своего "источника правды" (база данных, LDAP-сервер и т.д.).

**Типичные примеры учетных данных:**
*   Логин и пароль
*   Отпечаток пальца / Face ID
*   Одноразовый код из SMS / приложения
*   Сертификат

**Результат успешной аутентификации:**
Создается объект `Authentication`, который обычно содержит:
1.  **Principal (Принципал):** Основная информация о пользователе (например, его `username` или объект `UserDetails`).
2.  **Credentials:** Обычно стираются после проверки, чтобы не "светить" пароль.
3.  **Authorities:** Список прав (ролей, разрешений), которые есть у пользователя. *Обратите внимание: авторизация уже начинает подкрадываться сюда.*

**В контексте Spring Security:**
*   **Фильтры аутентификации:** `UsernamePasswordAuthenticationFilter`, `BasicAuthenticationFilter`, `JwtAuthenticationFilter`.
*   **Провайдеры аутентификации:** `DaoAuthenticationProvider` (самый частый, работает с `UserDetailsService`).
*   **Ключевой интерфейс:** `UserDetailsService` (загружает данные пользователя по `username`).

```java
// Пример кода, демонстрирующий процесс аутентификации
@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        // 1. Ищем пользователя в БД (аутентификация)
        User user = userRepository.findByUsername(username)
            .orElseThrow(() -> new UsernameNotFoundException("User not found"));

        // 2. Возвращаем UserDetails, который уже содержит права (authorities) для авторизации
        return new org.springframework.security.core.userdetails.User(
                user.getUsername(),
                user.getPassword(),
                // Следующий шаг - это уже авторизация!
                getAuthorities(user.getRoles())
        );
    }
}
```

---

### Authorization (Авторизация) — "Что тебе разрешено?"

После того как система узнала, "Кто ты" (аутентификация), наступает этап авторизации. Здесь система решает, разрешено ли этому пользователю выполнять определенное действие (доступ к endpoint'у, кнопке в UI, файлу).

**Как это работает?**
Система принимает решение на основе прав (`GrantedAuthority`), которые были присвоены пользователю в процессе аутентификации.

**Примеры решений авторизации:**
*   Может ли пользователь с ролью `USER` обратиться к URL `/api/admin/users`? (**Нет**)
*   Может ли пользователь, у которого есть право `READ_PRIVILEGE`, получить доступ к документу? (**Да**)
*   Видна ли кнопка "Удалить" в интерфейсе для роли `MODERATOR`? (**Да**)

**В контексте Spring Security:**
*   **Аннотации:** `@PreAuthorize`, `@PostAuthorize`, `@Secured`.
*   **Конфигурация в `SecurityFilterChain`:** `.requestMatchers("/admin/**").hasRole("ADMIN")`
*   **Методы в `HttpSecurity`:** `.hasAuthority()`, `.hasRole()`, `.access()`.

```java
// Примеры авторизации в Spring Security

// 1. На уровне конфигурации HTTP-запросов
@Bean
public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
    http
        .authorizeHttpRequests(authz -> authz
            .requestMatchers("/api/public/**").permitAll() // Всегда открыто (минует оба этапа)
            .requestMatchers("/api/admin/**").hasRole("ADMIN") // Авторизация по роли
            .requestMatchers("/api/user/**").hasAnyRole("USER", "ADMIN")
            .anyRequest().authenticated() // Требуется только аутентификация
        );
    return http.build();
}

// 2. На уровне методов (более гибко и рекомендуется)
@RestController
@RequestMapping("/api/orders")
public class OrderController {

    @GetMapping("/{id}")
    @PreAuthorize("hasAuthority('ORDER_READ') or @customSecurityService.canAccessOrder(authentication, #id)")
    // ^ Здесь мы проверяем конкретное право ИЛИ используем кастомную логику
    public ResponseEntity<Order> getOrder(@PathVariable Long id) {
        // ...
    }

    @PostMapping
    @PreAuthorize("hasRole('USER')") // Только пользователи с ролью USER
    public ResponseEntity<Order> createOrder(@RequestBody Order order) {
        // ...
    }
}
```

---

### Итоговая аналогия

Представьте **офисное здание**:

1.  **Authentication (Аутентификация):** Вы подходите к охране и предъявляете **пропуск** (логин/пароль). Охранник сверяет ваше лицо с фото в базе и проверяет, действителен ли пропуск. Вы доказали, что вы — сотрудник компании.
2.  **Authorization (Авторизация):** Теперь, внутри здания, вы пытаетесь открыть дверь в **секретную лабораторию R&D**. Ваш пропуск считывается, и система проверяет, есть ли у вас право доступа в эту комнату. Ваш пропуск (доказавший, кто вы) может не иметь такого права.

### Связь в Spring Security

Процесс выглядит так:

**HTTP Request -> Authentication Filter -> AuthenticationManager -> UserDetailsService -> Создается Authentication Object (с Principal и Authorities) -> SecurityContextHolder -> Authorization Filter/Method Security -> Доступ к ресурсу**

**Ключевой вывод:** Пользователь сначала доложен быть **аутентифицирован**, чтобы система могла провести для него **авторизацию**. Без первого второе невозможно. Spring Security явно разделяет эти две ответственности, что делает систему безопасной, гибкой и легко расширяемой.