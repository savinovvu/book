Чтобы работать с реактивным `ReactiveUserDetailsService` в Spring Security, нужно понять его роль в реактивном стеке. Этот интерфейс используется для загрузки данных пользователя в неблокирующем стиле. Вот подробное руководство:

---

### 1. **Основы ReactiveUserDetailsService**
Интерфейс содержит один метод:
```java
Mono<UserDetails> findByUsername(String username);
```
- Возвращает `Mono<UserDetails>`, что соответствует реактивной модели.
- Используется в цепочке аутентификации для получения данных пользователя.

---

### 2. **Реализация интерфейса**
Пример реализации с использованием реактивного репозитория (например, R2DBC):

```java
@Component
public class CustomReactiveUserDetailsService implements ReactiveUserDetailsService {

    private final UserRepository userRepository; // Реактивный репозиторий

    @Override
    public Mono<UserDetails> findByUsername(String username) {
        return userRepository.findByUsername(username)
                .map(user -> User
                        .withUsername(user.getUsername())
                        .password(user.getPassword())
                        .authorities(user.getRoles())
                        .build()
                );
    }
}
```

**Пояснение:**
- `UserRepository` должен быть реактивным (например, `ReactiveCrudRepository`).
- Преобразуем сущность `User` в Spring Security `UserDetails` через `User.builder()`.

---

### 3. **Интеграция с Spring Security**
Настройте `ServerHttpSecurity` в конфигурации:

```java
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public ReactiveUserDetailsService userDetailsService() {
        return new CustomReactiveUserDetailsService();
    }

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/admin/**").hasRole("ADMIN")
                .anyExchange().authenticated()
            )
            .httpBasic(withDefaults())
            .build();
    }
}
```

---

### 4. **Важные моменты**
- **Реактивность всех компонентов**: Убедитесь, что все цепи (репозиторий, сервисы) неблокирующие.
- **Преобразование пароля**: Если пароль зашифрован, укажите кодировщик в `PasswordEncoder` (например, `BCryptPasswordEncoder`).
- **Обработка ошибок**: Если пользователь не найден, возвращайте `Mono.empty()`, чтобы Spring Security обработал это как неудачную аутентификацию.

---

### 5. **Пример с шифрованием паролей**
```java
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}

// В сервисе:
@Override
public Mono<UserDetails> findByUsername(String username) {
    return userRepository.findByUsername(username)
            .map(user -> User
                    .withUsername(user.getUsername())
                    .password(user.getPassword()) // Пароль уже закодирован
                    .roles(user.getRoles())
                    .passwordEncoder(p -> p) // Не нужно, если пароль уже в кодированном формате
                    .build()
            );
}
```

---

### 6. **Тестирование**
Используйте `WebTestClient` для проверки:
```java
@SpringBootTest
class SecurityTest {

    @Autowired
    private WebTestClient webTestClient;

    @Test
    void whenAuthenticated_thenAccessProtected() {
        webTestClient
            .get().uri("/protected")
            .headers(headers -> headers.setBasicAuth("user", "password"))
            .exchange()
            .expectStatus().isOk();
    }
}
```

---

### 7. **Частые ошибки**
- **Блокирующие вызовы**: Не используйте `block()`, `subscribe()` внутри цепочки.
- **Отсутствие кодировщика паролей**: Убедитесь, что пароли в БД хранятся в закодированном виде.
- **Неверные права доступа**: Проверьте, что роли имеют префикс `ROLE_` (если используете `.roles()`).

---

### Итог
`ReactiveUserDetailsService` — ключевой компонент для реактивной аутентификации. Следуйте принципам:
1. Всегда возвращайте `Mono<UserDetails>`.
2. Используйте реактивные источники данных (R2DBC, MongoDB Reactive).
3. Интегрируйте с `ServerHttpSecurity`.

Это обеспечит масштабируемость и производительность вашего приложения.