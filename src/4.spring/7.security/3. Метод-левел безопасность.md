Метод-уровневая безопасность в Spring Security реализуется через аннотации. Вот подробное руководство:

## 1. Настройка конфигурации

```java
@Configuration
@EnableGlobalMethodSecurity(
    prePostEnabled = true,    // для @PreAuthorize, @PostAuthorize
    securedEnabled = true,    // для @Secured
    jsr250Enabled = true      // для @RolesAllowed (JSR-250)
)
public class MethodSecurityConfig extends GlobalMethodSecurityConfiguration {
    
    @Override
    protected MethodSecurityExpressionHandler createExpressionHandler() {
        DefaultMethodSecurityExpressionHandler expressionHandler = 
            new DefaultMethodSecurityExpressionHandler();
        // Кастомная логика при необходимости
        return expressionHandler;
    }
}
```

## 2. Использование аннотаций

### @PreAuthorize - проверка ДО выполнения метода
```java
@Service
public class UserService {
    
    @PreAuthorize("hasRole('ADMIN')")
    public void deleteUser(Long userId) {
        // Доступно только ADMIN
    }
    
    @PreAuthorize("hasAuthority('WRITE') or hasRole('ADMIN')")
    public void updateUser(User user) {
        // Требуется право WRITE или роль ADMIN
    }
    
    @PreAuthorize("#userId == authentication.principal.id")
    public void updatePersonalInfo(Long userId, UserInfo info) {
        // Пользователь может редактировать только свои данные
    }
    
    @PreAuthorize("@securityService.canAccessUser(principal, #userId)")
    public User getUser(Long userId) {
        // Кастомная проверка через сервис
    }
}
```

### @PostAuthorize - проверка ПОСЛЕ выполнения метода
```java
@Service
public class DocumentService {
    
    @PostAuthorize("returnObject.owner == authentication.name")
    public Document getDocument(Long id) {
        // Возвращает документ только если пользователь - владелец
        return documentRepository.findById(id);
    }
    
    @PostAuthorize("hasPermission(returnObject, 'READ')")
    public Report getConfidentialReport() {
        // Проверка прав на возвращаемый объект
        return reportService.generateReport();
    }
}
```

### @Secured - простые проверки ролей
```java
@Service
public class AdminService {
    
    @Secured("ROLE_ADMIN")
    public void performAdminAction() {
        // Только для ADMIN
    }
    
    @Secured({"ROLE_ADMIN", "ROLE_SUPER_ADMIN"})
    public void sensitiveOperation() {
        // Несколько разрешенных ролей
    }
}
```

## 3. Кастомные выражения и сервисы безопасности

```java
@Component("securityService")
public class CustomSecurityService {
    
    public boolean canAccessUser(User principal, Long targetUserId) {
        return principal.getId().equals(targetUserId) || 
               principal.getAuthorities().stream()
                   .anyMatch(a -> a.getAuthority().equals("ROLE_ADMIN"));
    }
    
    public boolean isResourceOwner(Long resourceId, String username) {
        // Логика проверки владения ресурсом
        return resourceRepository.isOwner(resourceId, username);
    }
}
```

## 4. Специальные выражения SpEL

```java
@Service
public class BusinessService {
    
    // Доступ к параметрам метода
    @PreAuthorize("#user.id == principal.id")
    public void updateUser(@Param("user") User user) {}
    
    // Комбинированные условия
    @PreAuthorize("hasIpAddress('192.168.1.0/24') and hasRole('INTERNAL_USER')")
    public void internalOperation() {}
    
    // Время-based доступ
    @PreAuthorize("T(java.time.LocalTime).now().isAfter(T(java.time.LocalTime).of(9, 0))")
    public void daytimeOperation() {}
}
```

## 5. Фильтрация коллекций

```java
@Repository
public interface UserRepository extends JpaRepository<User, Long> {
    
    @PostFilter("filterObject.active == true")
    List<User> findAll();
    
    @PreFilter("filterObject.owner == authentication.name")
    List<User> saveAll(List<User> users);
}
```

## 6. Best Practices для Senior разработчиков

### 6.1 Централизованная конфигурация прав
```java
@Component
public class SecurityExpressions {
    
    public static final String IS_ADMIN = "hasRole('ADMIN')";
    public static final String CAN_MANAGE_USERS = "hasAnyRole('ADMIN', 'USER_MANAGER')";
    public static final String IS_OWNER = "#userId == principal.id";
    
    private SecurityExpressions() {}
}

// Использование
@PreAuthorize(SecurityExpressions.IS_ADMIN)
public void adminOperation() {}
```

### 6.2 Кастомный Method Security Expression Handler
```java
public class CustomMethodSecurityExpressionHandler 
    extends DefaultMethodSecurityExpressionHandler {
    
    @Override
    protected MethodSecurityExpressionOperations createSecurityExpressionRoot(
        Authentication authentication, MethodInvocation invocation) {
        
        CustomSecurityExpressionRoot root = 
            new CustomSecurityExpressionRoot(authentication);
        root.setPermissionEvaluator(getPermissionEvaluator());
        root.setTrustResolver(getTrustResolver());
        return root;
    }
}

public class CustomSecurityExpressionRoot 
    extends SecurityExpressionRoot implements MethodSecurityExpressionOperations {
    
    public CustomSecurityExpressionRoot(Authentication authentication) {
        super(authentication);
    }
    
    public boolean isInDepartment(String department) {
        // Кастомная логика проверки отдела
        User user = (User) this.getPrincipal();
        return user.getDepartment().equals(department);
    }
    
    // Реализация обязательных методов
    private Object filterObject;
    private Object returnObject;
    
    @Override
    public Object getFilterObject() { return filterObject; }
    
    @Override
    public void setFilterObject(Object obj) { this.filterObject = obj; }
    
    @Override
    public Object getReturnObject() { return returnObject; }
    
    @Override
    public void setReturnObject(Object obj) { this.returnObject = obj; }
}
```

### 6.3 Интеграция с Permission Evaluator
```java
@Component
public class CustomPermissionEvaluator implements PermissionEvaluator {
    
    @Override
    public boolean hasPermission(Authentication authentication, 
                               Object targetDomainObject, Object permission) {
        // Логика проверки прав на объект
        if (targetDomainObject instanceof Document) {
            Document doc = (Document) targetDomainObject;
            return checkDocumentPermission(authentication, doc, permission.toString());
        }
        return false;
    }
    
    @Override
    public boolean hasPermission(Authentication authentication, 
                               Serializable targetId, String targetType, Object permission) {
        // Логика проверки прав по ID и типу
        if ("Document".equals(targetType)) {
            Document doc = documentService.findById((Long) targetId);
            return checkDocumentPermission(authentication, doc, permission.toString());
        }
        return false;
    }
}
```

## 7. Тестирование метод-левел безопасности

```java
@SpringBootTest
@WithMockUser(roles = "USER")
class UserServiceSecurityTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    @WithMockUser(roles = "ADMIN")
    void whenAdmin_thenCanDeleteUser() {
        assertDoesNotThrow(() -> userService.deleteUser(1L));
    }
    
    @Test
    void whenUser_thenCannotDeleteUser() {
        assertThrows(AccessDeniedException.class, 
            () -> userService.deleteUser(1L));
    }
    
    @Test
    @WithMockUser(username = "testuser")
    void whenOwner_thenCanUpdatePersonalInfo() {
        User user = getUserWithId("testuser", 1L);
        assertDoesNotThrow(() -> userService.updatePersonalInfo(1L, user));
    }
}
```

## Ключевые моменты для Senior:

1. **Выбор аннотации**:
    - `@PreAuthorize` - для комплексных проверок с SpEL
    - `@PostAuthorize` - когда нужен доступ к возвращаемому объекту
    - `@Secured` - для простых проверок ролей

2. **Производительность**: `@PostAuthorize` может быть дорогим из-за загрузки данных перед проверкой

3. **Безопасность по умолчанию**: Всегда настраивайте deny-by-default

4. **Композиция аннотаций**: Создавайте кастомные аннотации для частых паттернов безопасности

5. **Логирование**: Добавляйте аудит security-событий

Такой подход обеспечивает гибкую и мощную систему безопасности на уровне методов в Spring-приложениях.