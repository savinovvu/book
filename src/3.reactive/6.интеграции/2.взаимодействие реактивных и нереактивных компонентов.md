Организация взаимодействия между реактивными и нереактивными компонентами требует осторожности, чтобы не нарушить асинхронную природу реактивной системы. Рассмотрим решение для вызова блокирующего REST-сервиса из реактивного кода:

### 1. **Изоляция блокирующего кода**
Оберните блокирующий вызов в отдельный компонент, управляемый специальным планировщиком для блокирующих задач.

```java
public class BlockingServiceWrapper {
    private final WebClient webClient;
    private final Scheduler blockingScheduler = Schedulers.boundedElastic();

    public Mono<String> callBlockingRestService(String param) {
        return Mono.fromCallable(() -> {
            // Имитация блокирующего HTTP-вызова
            return restTemplate.getForObject("https://api.example.com/data", String.class);
        }).subscribeOn(blockingScheduler); // Выполняется в отдельном потоке
    }
}
```

### 2. **Использование Reactor-совместимых обёрток**
Если есть возможность, замените блокирующий клиент на реактивный (например, Spring WebClient):
```java
public Mono<String> callReactiveRestService(String param) {
    return webClient
        .get()
        .uri("https://api.example.com/data/{param}", param)
        .retrieve()
        .bodyToMono(String.class);
}
```

### 3. **Обработка ошибок и таймаутов**
Добавьте обработку исключений и таймаутов для избежания блокировки потоков:
```java
public Mono<String> callWithTimeout(String param) {
    return callBlockingRestService(param)
        .timeout(Duration.ofSeconds(5))
        .onErrorResume(throwable -> Mono.just("fallback"));
}
```

### 4. **Интеграция с реактивной цепочкой**
Используйте полученные данные в реактивном потоке:
```java
public Flux<String> reactiveProcess(List<String> params) {
    return Flux.fromIterable(params)
        .flatMap(param -> callBlockingRestService(param))
        .doOnNext(result -> log.info("Processed: {}", result));
}
```

### 5. **Конфигурация планировщика**
- **Schedulers.boundedElastic()** – оптимален для блокирующих задач, ограничивает число потоков.
- **Schedulers.parallel()** – только для неблокирующих быстрых операций.

### 6. **Важные предупреждения**
- **Не блокируйте event-loop потоки** (например, Schedulers.parallel()).
- **Контролируйте число потоков** для блокирующих операций через boundedElastic.
- **Тестируйте под нагрузкой** – убедитесь, что пул потоков не исчерпывается.

### Альтернативное решение (для Spring)
Используйте `@Async` для выноса блокирующей логики в отдельный поток:
```java
@Async("taskExecutor")
public CompletableFuture<String> asyncCall(String param) {
    String result = restTemplate.getForObject("https://api.example.com/data", String.class);
    return CompletableFuture.completedFuture(result);
}

// В реактивном коде:
Mono.fromFuture(asyncCall(param));
```

### Резюме
1. Изолируйте блокирующие вызовы через `Mono.fromCallable().subscribeOn(boundedElastic())`.
2. Используйте реактивные клиенты где возможно.
3. Добавляйте таймауты и обработку ошибок.
4. Настройте отдельный пул потоков для блокирующих операций.

Этот подход позволяет интегрировать блокирующиеся компоненты без нарушения реактивной модели.