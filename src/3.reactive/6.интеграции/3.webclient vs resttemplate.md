### WebClient vs RestTemplate

**RestTemplate**:
- Синхронный, блокирующий клиент
- Устаревший (в maintenance mode), не рекомендуется для новых проектов
- Простая конфигурация, но менее гибкий
- Поддерживает традиционные шаблоны Spring

**WebClient**:
- Асинхронный, неблокирующий (может использоваться и синхронно)
- Рекомендуемый клиент для новых проектов в Spring 5+
- Более гибкий и функциональный
- Поддерживает реактивные потоки (Reactive Streams)

### Обработка ошибок в WebClient

1. **Базовая обработка через onStatus**:
```java
WebClient webClient = WebClient.create();

Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .onStatus(
        status -> status.is4xxClientError() || status.is5xxServerError(),
        clientResponse -> handleError(clientResponse)
    )
    .bodyToMono(String.class);

// Или с конкретными статусами
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .onStatus(
        status -> status.value() == 404,
        clientResponse -> Mono.error(new ResourceNotFoundException())
    )
    .onStatus(
        status -> status.value() == 500,
        clientResponse -> Mono.error(new ServerErrorException())
    )
    .bodyToMono(String.class);
```

2. **Использование exchange() для более сложных сценариев**:
```java
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .exchange()
    .flatMap(clientResponse -> {
        if (clientResponse.statusCode().isError()) {
            return clientResponse.createException()
                    .flatMap(Mono::error);
        }
        return clientResponse.bodyToMono(String.class);
    });
```

3. **Обработка через глобальный обработчик ошибок**:
```java
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .bodyToMono(String.class)
    .doOnError(WebClientResponseException.class, ex -> {
        // Логирование или дополнительная обработка
        log.error("Error response: {}", ex.getStatusCode());
    });
```

### Повторные запросы (Retry)

1. **Базовый retry**:
```java
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .bodyToMono(String.class)
    .retry(3); // 3 попытки при любой ошибке
```

2. **Retry с условиями**:
```java
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .bodyToMono(String.class)
    .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(2))
        .filter(throwable -> throwable instanceof WebClientResponseException)
        .onRetryExhaustedThrow((retryBackoffSpec, retrySignal) -> {
            throw new RuntimeException("Retry exhausted");
        }));
```

3. **Retry с экспоненциальной задержкой**:
```java
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .bodyToMono(String.class)
    .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
        .maxBackoff(Duration.ofSeconds(10))
        .filter(throwable -> {
            if (throwable instanceof WebClientResponseException) {
                int status = ((WebClientResponseException) throwable).getStatusCode().value();
                return status >= 500; // Повторяем только для 5xx ошибок
            }
            return false;
        }));
```

4. **Кастомная логика retry**:
```java
Mono<String> response = webClient.get()
    .uri("/api/endpoint")
    .retrieve()
    .bodyToMono(String.class)
    .retryWhen(Retry.from(retrySignalFlux -> 
        retrySignalFlux
            .zipWith(Flux.range(1, 4), (signal, attempt) -> {
                if (signal.failure() instanceof WebClientResponseException) {
                    WebClientResponseException ex = 
                        (WebClientResponseException) signal.failure();
                    if (ex.getStatusCode().value() == 503) {
                        return attempt; // Повторяем для 503 ошибок
                    }
                }
                throw Exceptions.propagate(signal.failure());
            })
            .flatMap(attempt -> Mono.delay(Duration.ofSeconds(attempt * 2)))
    ));
```

### Полный пример с обработкой ошибок и retry

```java
@Configuration
public class WebClientConfig {
    
    @Bean
    public WebClient webClient() {
        return WebClient.builder()
            .baseUrl("https://api.example.com")
            .defaultHeader(HttpHeaders.CONTENT_TYPE, MediaType.APPLICATION_JSON_VALUE)
            .build();
    }
}

@Service
public class ApiService {
    
    private final WebClient webClient;
    
    public ApiService(WebClient webClient) {
        this.webClient = webClient;
    }
    
    public Mono<String> fetchDataWithRetry() {
        return webClient.get()
            .uri("/data")
            .retrieve()
            .onStatus(HttpStatus::is5xxServerError, response -> 
                Mono.error(new ServerException("Server error: " + response.statusCode())))
            .onStatus(HttpStatus::is4xxClientError, response -> 
                Mono.error(new ClientException("Client error: " + response.statusCode())))
            .bodyToMono(String.class)
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
                .maxBackoff(Duration.ofSeconds(10))
                .filter(throwable -> 
                    throwable instanceof ServerException) // Повторяем только серверные ошибки
            .doOnError(throwable -> 
                log.error("Failed after retries", throwable));
    }
}
```

### Ключевые моменты:

1. **onStatus()** - для обработки специфических HTTP статусов
2. **retry()** - простой повтор N раз
3. **retryWhen()** - гибкая настройка повторных попыток с задержками
4. **doOnError()** - дополнительная обработка ошибок
5. **exchange()** - для полного контроля над response/error handling

WebClient предоставляет мощные инструменты для обработки ошибок и реализации стратегий повторных запросов, что делает его предпочтительным выбором для современных приложений.