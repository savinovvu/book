Интеграция реактивных потоков с базами данных — ключевой аспект построения высокопроизводительных неблокирующих приложений. Рассмотрим подходы для разных СУБД:

## 1. R2DBC (Reactive Relational Database Connectivity)

### Базовая настройка
```java
@Configuration
@EnableR2dbcRepositories
public class R2dbcConfig extends AbstractR2dbcConfiguration {
    
    @Override
    @Bean
    public ConnectionFactory connectionFactory() {
        return new PostgresqlConnectionFactory(
            PostgresqlConnectionConfiguration.builder()
                .host("localhost")
                .port(5432)
                .database("mydb")
                .username("user")
                .password("pass")
                .build()
        );
    }
}
```

### Репозиторий и использование
```java
public interface UserRepository extends ReactiveCrudRepository<User, Long> {
    
    @Query("SELECT * FROM users WHERE age >= $1")
    Flux<User> findByAgeGreaterThan(int age);
    
    Mono<User> findByEmail(String email);
}

@Service
public class UserService {
    
    private final UserRepository userRepository;
    
    public UserService(UserRepository userRepository) {
        this.userRepository = userRepository;
    }
    
    public Flux<User> getActiveUsers() {
        return userRepository.findAll()
            .filter(User::isActive)
            .delayElements(Duration.ofMillis(10)) // Backpressure control
            .onErrorResume(throwable -> {
                log.error("Error fetching users", throwable);
                return Flux.empty();
            });
    }
    
    public Mono<User> createUser(User user) {
        return userRepository.save(user)
            .doOnSuccess(u -> log.info("User created: {}", u.getId()));
    }
}
```

## 2. Reactive MongoDB

### Конфигурация
```java
@Configuration
@EnableReactiveMongoRepositories
public class MongoConfig extends AbstractReactiveMongoConfiguration {
    
    @Override
    public MongoClient reactiveMongoClient() {
        return MongoClients.create("mongodb://localhost:27017");
    }
    
    @Override
    protected String getDatabaseName() {
        return "reactive_db";
    }
}
```

### Кастомные операции
```java
public interface ReactiveBookRepository extends ReactiveMongoRepository<Book, String> {
    
    Flux<Book> findByTitleContainingIgnoreCase(String title);
    
    @Query("{ 'author': ?0, 'year': { $gte: ?1 } }")
    Flux<Book> findByAuthorAndYearAfter(String author, int year);
    
    Mono<Long> countByCategory(String category);
}

@Service
public class BookService {
    
    private final ReactiveBookRepository bookRepository;
    private final ReactiveMongoTemplate mongoTemplate;
    
    public BookService(ReactiveBookRepository bookRepository, 
                      ReactiveMongoTemplate mongoTemplate) {
        this.bookRepository = bookRepository;
        this.mongoTemplate = mongoTemplate;
    }
    
    public Flux<Book> findBooksWithAggregation() {
        return mongoTemplate.aggregate(
            Aggregation.newAggregation(
                Aggregation.match(Criteria.where("price").gte(10)),
                Aggregation.group("category").count().as("count"),
                Aggregation.sort(Sort.Direction.DESC, "count")
            ),
            "books",
            Book.class
        );
    }
    
    public Mono<Void> bulkInsertBooks(Flux<Book> books) {
        return bookRepository.saveAll(books)
            .then()
            .doOnSuccess(v -> log.info("Bulk insert completed"));
    }
}
```

## 3. Reactive Cassandra

### Конфигурация
```java
@Configuration
@EnableReactiveCassandraRepositories
public class CassandraConfig extends AbstractReactiveCassandraConfiguration {
    
    @Override
    protected String getKeyspaceName() {
        return "my_keyspace";
    }
    
    @Override
    public SchemaAction getSchemaAction() {
        return SchemaAction.CREATE_IF_NOT_EXISTS;
    }
    
    @Override
    protected List<CreateKeyspaceSpecification> getKeyspaceCreations() {
        return Arrays.asList(
            CreateKeyspaceSpecification.createKeyspace("my_keyspace")
                .ifNotExists()
                .withSimpleReplication(1)
        );
    }
}
```

### Репозиторий и сложные запросы
```java
@Table
public class Product {
    @PrimaryKey
    private UUID id;
    private String name;
    private String category;
    private Double price;
    private Instant createdAt;
    
    // getters/setters
}

public interface ReactiveProductRepository extends ReactiveCassandraRepository<Product, UUID> {
    
    @AllowFiltering
    Flux<Product> findByCategoryAndPriceGreaterThan(String category, Double price);
    
    @Query("SELECT * FROM products WHERE category = ?0 LIMIT ?1")
    Flux<Product> findByCategoryWithLimit(String category, int limit);
}

@Service
public class ProductService {
    
    private final ReactiveProductRepository productRepository;
    private final ReactiveCassandraTemplate cassandraTemplate;
    
    public ProductService(ReactiveProductRepository productRepository,
                         ReactiveCassandraTemplate cassandraTemplate) {
        this.productRepository = productRepository;
        this.cassandraTemplate = cassandraTemplate;
    }
    
    public Flux<Product> getExpensiveProductsByCategory(String category, Double minPrice) {
        return productRepository.findByCategoryAndPriceGreaterThan(category, minPrice)
            .transform(this::addBusinessLogic)
            .compose(this::withBackpressure);
    }
    
    private Flux<Product> addBusinessLogic(Flux<Product> products) {
        return products
            .filter(product -> product.getPrice() > 0)
            .map(product -> {
                // Добавляем бизнес-логику
                if (product.getPrice() > 1000) {
                    product.setName(product.getName() + " (PREMIUM)");
                }
                return product;
            });
    }
    
    private Flux<Product> withBackpressure(Flux<Product> products) {
        return products
            .limitRate(100) // Контроль backpressure
            .onBackpressureBuffer(50);
    }
}
```

## 4. Паттерны интеграции

### Транзакции в R2DBC
```java
@Service
public class TransactionalService {
    
    private final DatabaseClient databaseClient;
    private final TransactionalOperator transactionalOperator;
    
    public TransactionalService(DatabaseClient databaseClient,
                              TransactionalOperator transactionalOperator) {
        this.databaseClient = databaseClient;
        this.transactionalOperator = transactionalOperator;
    }
    
    public Mono<Void> transferMoney(Long fromAccount, Long toAccount, BigDecimal amount) {
        return transactionalOperator.transactional(
            databaseClient.sql("UPDATE accounts SET balance = balance - :amount WHERE id = :id")
                .bind("amount", amount)
                .bind("id", fromAccount)
                .then()
                .then(
                    databaseClient.sql("UPDATE accounts SET balance = balance + :amount WHERE id = :id")
                        .bind("amount", amount)
                        .bind("id", toAccount)
                        .then()
                )
        );
    }
}
```

### Обработка ошибок и retry
```java
@Service
public class ResilientDataService {
    
    public Flux<User> getUsersWithRetry() {
        return userRepository.findAll()
            .retryWhen(Retry.backoff(3, Duration.ofSeconds(1))
            .timeout(Duration.ofSeconds(5))
            .onErrorResume(TimeoutException.class, e -> {
                log.warn("Timeout occurred, returning cached data");
                return getCachedUsers();
            });
    }
    
    public Mono<User> saveUserWithCircuitBreaker(User user) {
        return Mono.defer(() -> userRepository.save(user))
            .transformDeferred(CircuitBreakerOperator.of(circuitBreaker))
            .doOnError(e -> log.error("Failed to save user", e));
    }
}
```

## 5. Best Practices

### Backpressure Management
```java
public Flux<Data> streamLargeDataset() {
    return dataRepository.findAll()
        .window(100) // Группируем в батчи
        .concatMap(window -> window.delayElements(Duration.ofMillis(10)), 5) // Параллелизм
        .onBackpressureBuffer(1000, BufferOverflowStrategy.DROP_LATEST);
}
```

### Мониторинг и метрики
```java
@Component
public class DatabaseMetrics {
    
    public Mono<QueryResult> executeWithMetrics(String query) {
        return Mono.from(databaseClient.sql(query).fetch().rowsUpdated())
            .name("database.query")
            .tag("query_type", "update")
            .metrics()
            .map(QueryResult::new);
    }
}
```

Ключевые преимущества реактивного подхода:
- **Неблокирующие операции** — эффективное использование ресурсов
- **Backpressure control** — защита от перегрузки
- **Композиция потоков** — гибкость в построении пайплайнов
- **Резилентность** — встроенные механизмы обработки ошибок

Выбор технологии зависит от конкретных требований: R2DBC для реляционных данных, Reactive MongoDB для документ-ориентированных СУБД, Cassandra для распределенных high-write сценариев.