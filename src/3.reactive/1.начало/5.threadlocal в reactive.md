# ThreadLocal в реактивном программировании

## **Проблема ThreadLocal в реактивном коде**

### Почему ThreadLocal не работает:
```java
// Проблемный пример
public Mono<String> problematicMethod() {
    ThreadLocal<String> context = new ThreadLocal<>();
    context.set("request-id-123");
    
    return Mono.fromCallable(() -> {
        // ОПАСНО: может выполняться в ДРУГОМ потоке!
        return context.get(); // Может вернуть null или данные другого запроса
    });
}
```

### Причины:
1. **Работа с пулом потоков** - операции выполняются в разных потоках
2. **Event-loop модель** - один поток обрабатывает множество запросов
3. **Отсутствие гарантий** - нет привязки потока к конкретному запросу

---

## **Альтернативы ThreadLocal в реактивном мире**

### 1. **Reactor Context (наиболее популярный)**

```java
// Запись в контекст
public Mono<String> processWithContext(String data) {
    return Mono.just(data)
        .flatMap(this::someProcessing)
        .contextWrite(Context.of("requestId", "12345", "user", "john"));
}

// Чтение из контекста
public Mono<String> someProcessing(String data) {
    return Mono.deferContextual(ctx -> {
        String requestId = ctx.get("requestId");
        String user = ctx.getOrDefault("user", "anonymous");
        
        return Mono.just(String.format("[%s] %s: %s", requestId, user, data));
    });
}
```

### 2. **Project Reactor Context с автоматическим распространением**

```java
public class ReactiveContextHolder {
    private static final String REQUEST_ID = "requestId";
    private static final String USER = "user";
    
    public static Mono<String> processRequest(String data) {
        return getRequestId()
            .zipWith(getUser())
            .flatMap(tuple -> {
                String requestId = tuple.getT1();
                String user = tuple.getT2();
                return Mono.just(String.format("[%s] %s: %s", requestId, user, data));
            });
    }
    
    public static Mono<String> getRequestId() {
        return Mono.deferContextual(ctx -> 
            Mono.just(ctx.getOrDefault(REQUEST_ID, "unknown"))
        );
    }
    
    public static Mono<String> getUser() {
        return Mono.deferContextual(ctx -> 
            Mono.just(ctx.getOrDefault(USER, "anonymous"))
        );
    }
}

// Использование
public Mono<String> handleRequest() {
    return ReactiveContextHolder.processRequest("Hello")
        .contextWrite(Context.of(
            "requestId", UUID.randomUUID().toString(),
            "user", "alice"
        ));
}
```

### 3. **WebFlux ServerWebExchange (для веб-приложений)**

```java
@RestController
public class WebFluxController {
    
    @GetMapping("/data")
    public Mono<String> getData(ServerWebExchange exchange) {
        // ServerWebExchange содержит контекст запроса
        exchange.getAttributes().put("startTime", System.currentTimeMillis());
        
        return processBusinessLogic()
            .doOnSuccess(result -> {
                Long startTime = exchange.getAttribute("startTime");
                long duration = System.currentTimeMillis() - startTime;
                System.out.println("Request took: " + duration + "ms");
            });
    }
    
    private Mono<String> processBusinessLogic() {
        return Mono.just("Processed data");
    }
}
```

### 4. **Кастомные декораторы для цепочек**

```java
public class ContextAwareProcessor {
    
    public static <T> Function<Mono<T>, Mono<T>> withContext(String key, Object value) {
        return mono -> mono.contextWrite(ctx -> ctx.put(key, value));
    }
    
    public static <T> Function<Mono<T>, Mono<T>> withRequestId() {
        return withContext("requestId", UUID.randomUUID().toString());
    }
}

// Использование
public Mono<String> complexOperation() {
    return Mono.just("data")
        .transform(ContextAwareProcessor.withRequestId())
        .transform(ContextAwareProcessor.withContext("service", "user-service"))
        .flatMap(this::validate)
        .flatMap(this::process);
}
```

### 5. **Использование Tuples или оберток**

```java
public class ContextCarrier<T> {
    private final T data;
    private final Map<String, Object> context;
    
    public ContextCarrier(T data) {
        this.data = data;
        this.context = new HashMap<>();
    }
    
    public ContextCarrier<T> withContext(String key, Object value) {
        this.context.put(key, value);
        return this;
    }
    
    public Mono<ContextCarrier<T>> toMono() {
        return Mono.just(this);
    }
    
    // Геттеры...
}

// Использование
public Mono<String> processWithCarrier() {
    return new ContextCarrier<>("payload")
        .withContext("requestId", "123")
        .withContext("user", "john")
        .toMono()
        .flatMap(carrier -> processData(carrier));
}
```

---

## **Практические примеры**

### А. Логирование с контекстом

```java
public class ReactiveLogger {
    public static Mono<Void> logWithContext(String message) {
        return Mono.deferContextual(ctx -> {
            String requestId = ctx.getOrDefault("requestId", "unknown");
            String user = ctx.getOrDefault("user", "anonymous");
            
            System.out.printf("[%s] User: %s - %s%n", requestId, user, message);
            return Mono.empty();
        });
    }
}

// Использование в сервисе
public Mono<String> businessMethod(String input) {
    return Mono.just(input)
        .doOnEach(signal -> {
            if (signal.isOnNext()) {
                ReactiveLogger.logWithContext("Processing: " + signal.get())
                    .contextWrite(signal.getContext())
                    .subscribe();
            }
        })
        .map(String::toUpperCase)
        .contextWrite(Context.of("requestId", "req-123", "user", "alice"));
}
```

### Б. Распространение контекста между сервисами

```java
public class ContextPropagator {
    
    public static Consumer<HttpHeaders> propagateContext() {
        return headers -> Mono.deferContextual(ctx -> {
            if (ctx.hasKey("requestId")) {
                headers.add("X-Request-ID", ctx.get("requestId"));
            }
            if (ctx.hasKey("user")) {
                headers.add("X-User", ctx.get("user"));
            }
            return Mono.empty();
        }).subscribeOn(Schedulers.boundedElastic()).subscribe();
    }
    
    public static Function<ClientResponse, Mono<ClientResponse>> extractContext() {
        return response -> Mono.deferContextual(ctx -> {
            Context newContext = ctx;
            
            String requestId = response.headers().header("X-Request-ID").get(0);
            if (requestId != null) {
                newContext = newContext.put("requestId", requestId);
            }
            
            return Mono.just(response)
                .contextWrite(newContext);
        });
    }
}

// Использование с WebClient
public Mono<String> callExternalService() {
    return webClient.get()
        .uri("/external/api")
        .headers(ContextPropagator.propagateContext())
        .exchangeToMono(ContextPropagator.extractContext())
        .flatMap(response -> response.bodyToMono(String.class));
}
```

---

## **Лучшие практики**

### ✅ Правильно:
```java
public Mono<String> goodPractice() {
    return Mono.deferContextual(ctx -> {
        String requestId = ctx.get("requestId");
        return processDataWithContext(requestId);
    })
    .contextWrite(Context.of("requestId", generateRequestId()));
}
```

### ❌ Неправильно:
```java
public Mono<String> badPractice() {
    ThreadLocal<String> threadLocal = new ThreadLocal<>();
    threadLocal.set("value");
    
    return Mono.fromCallable(() -> {
        // ОПАСНО! Может работать в другом потоке
        return threadLocal.get();
    });
}
```

---

## **Заключение**

- **ThreadLocal не работает** в реактивном программировании из-за модели пула потоков
- **Reactor Context** - основная альтернатива для хранения request-scoped данных
- **Контекст автоматически распространяется** по цепочке вызовов
- **ServerWebExchange** полезен для web-specific контекста
- **Кастомные решения** нужны для сложных сценариев распространения между сервисами

Реактивный контекст обеспечивает тот же функционал, что и ThreadLocal, но безопасно работает в асинхронной среде с пулами потоков.