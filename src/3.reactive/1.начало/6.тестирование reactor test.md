# Reactor Test: средства тестирования реактивного кода

Библиотека `reactor-test` предоставляет мощные инструменты для тестирования реактивных потоков. Вот основные компоненты:

## **1. StepVerifier - основной инструмент тестирования**

### Базовое использование:
```java
@Test
void testSimpleFlux() {
    Flux<String> flux = Flux.just("A", "B", "C");
    
    StepVerifier.create(flux)
        .expectNext("A")
        .expectNext("B")
        .expectNext("C")
        .verifyComplete();
}
```

### Проверка ошибок:
```java
@Test
void testError() {
    Flux<String> flux = Flux.error(new RuntimeException("Error!"));
    
    StepVerifier.create(flux)
        .verifyError(RuntimeException.class);
    
    // Или с проверкой сообщения
    StepVerifier.create(flux)
        .verifyErrorMatches(throwable -> 
            throwable.getMessage().equals("Error!"));
}
```

## **2. Тестирование временных последовательностей**

### Virtual Time Scheduler:
```java
@Test
void testVirtualTime() {
    StepVerifier.withVirtualTime(() -> 
        Flux.interval(Duration.ofHours(1))
            .take(2)
            .map(i -> "Event " + i)
    )
    .expectSubscription()
    .thenAwait(Duration.ofHours(2)) // "перематываем" время
    .expectNext("Event 0", "Event 1")
    .verifyComplete();
}
```

### Тестирование задержек:
```java
@Test
void testWithDelays() {
    StepVerifier.withVirtualTime(() -> 
        Mono.delay(Duration.ofDays(1))
            .map(i -> "Done")
    )
    .expectSubscription()
    .expectNoEvent(Duration.ofDays(1)) // проверяем что ничего не происходит
    .expectNext("Done")
    .verifyComplete();
}
```

## **3. TestPublisher - управляемый источник данных**

### Создание тестового Publisher:
```java
@Test
void testWithTestPublisher() {
    TestPublisher<String> testPublisher = TestPublisher.create();
    
    Flux<String> flux = testPublisher.flux();
    
    StepVerifier.create(flux)
        .then(() -> testPublisher.next("A", "B"))
        .expectNext("A", "B")
        .then(() -> testPublisher.complete())
        .verifyComplete();
}
```

### Тестирование ошибок с TestPublisher:
```java
@Test
void testPublisherWithError() {
    TestPublisher<String> testPublisher = TestPublisher.create();
    
    StepVerifier.create(testPublisher.flux())
        .then(() -> testPublisher.next("data"))
        .expectNext("data")
        .then(() -> testPublisher.error(new RuntimeException("Test error")))
        .verifyError(RuntimeException.class);
}
```

## **4. Тестирование контекста**

### Проверка Context в реактивных цепочках:
```java
@Test
void testContextPropagation() {
    Mono<String> mono = Mono.deferContextual(ctx -> 
        Mono.just("Value: " + ctx.get("key"))
    );
    
    StepVerifier.create(mono)
        .expectAccessibleContext()
        .contains("key", "test-value")
        .then()
        .expectNext("Value: test-value")
        .verifyComplete();
}
```

## **5. Сложные сценарии тестирования**

### Тестирование backpressure:
```java
@Test
void testBackpressure() {
    Flux<Integer> flux = Flux.range(1, 10);
    
    StepVerifier.create(flux, 1) // запрашиваем 1 элемент
        .expectNext(1)
        .thenRequest(3) // запрашиваем еще 3
        .expectNext(2, 3, 4)
        .thenRequest(6) // запрашиваем оставшиеся
        .expectNextCount(6)
        .verifyComplete();
}
```

### Тестирование сценариев отмены:
```java
@Test
void testCancellation() {
    Flux<Long> infiniteFlux = Flux.interval(Duration.ofMillis(100));
    
    StepVerifier.create(infiniteFlux)
        .expectNext(0L)
        .expectNext(1L)
        .thenCancel()
        .verify();
}
```

## **6. PublisherProbe - для ветвлений в реактивных цепочках**

### Тестирование разных путей выполнения:
```java
@Test
void testPublisherProbe() {
    PublisherProbe<String> probe = PublisherProbe.of(Mono.just("fallback"));
    
    Mono<String> source = Mono.<String>empty()
        .switchIfEmpty(probe.mono());
    
    StepVerifier.create(source)
        .expectNext("fallback")
        .verifyComplete();
    
    // Проверяем, что probe был использован
    probe.assertWasSubscribed();
    probe.assertWasRequested();
    probe.assertWasNotCancelled();
}
```

## **7. Интеграция с Spring Boot Test**

### Тестирование @RestController с WebTestClient:
```java
@SpringBootTest
@AutoConfigureWebTestClient
class ReactiveControllerTest {
    
    @Autowired
    private WebTestClient webTestClient;
    
    @Test
    void testReactiveEndpoint() {
        webTestClient.get()
            .uri("/api/data")
            .exchange()
            .expectStatus().isOk()
            .expectBodyList(String.class)
            .hasSize(3)
            .contains("A", "B", "C");
    }
}
```

### Тестирование сервисов:
```java
@ExtendWith(SpringExtension.class)
@SpringBootTest
class UserServiceTest {
    
    @Autowired
    private UserService userService;
    
    @Test
    void testFindUserById() {
        StepVerifier.create(userService.findById("123"))
            .assertNext(user -> {
                assertThat(user.getId()).isEqualTo("123");
                assertThat(user.getName()).isNotBlank();
            })
            .verifyComplete();
    }
}
```

## **8. Продвинутые техники**

### Тестирование ретраев:
```java
@Test
void testRetryMechanism() {
    AtomicInteger attempt = new AtomicInteger();
    Mono<String> unreliableMono = Mono.fromCallable(() -> {
        if (attempt.incrementAndGet() < 3) {
            throw new RuntimeException("Temporary error");
        }
        return "Success";
    });
    
    Mono<String> withRetry = unreliableMono
        .retryWhen(Retry.backoff(3, Duration.ofMillis(100)));
    
    StepVerifier.create(withRetry)
        .expectNext("Success")
        .verifyComplete();
}
```

### Тестирование параллельных операций:
```java
@Test
void testParallelExecution() {
    Flux<String> flux = Flux.range(1, 10)
        .parallel(2)
        .runOn(Schedulers.parallel())
        .map(i -> "item-" + i)
        .sequential();
    
    StepVerifier.create(flux)
        .expectNextCount(10)
        .verifyComplete();
}
```

## **9. Кастомные Assertions**

### Создание переиспользуемых проверок:
```java
class CustomReactiveAssertions {
    
    public static <T> StepVerifier.FirstStep<T> assertFlux(Flux<T> flux) {
        return StepVerifier.create(flux);
    }
    
    public static Consumer<String> shouldStartWith(String prefix) {
        return value -> assertThat(value).startsWith(prefix);
    }
}

// Использование
@Test
void testWithCustomAssertions() {
    Flux<String> flux = Flux.just("prefix-1", "prefix-2");
    
    CustomReactiveAssertions.assertFlux(flux)
        .assertNext(CustomReactiveAssertions.shouldStartWith("prefix-"))
        .assertNext(CustomReactiveAssertions.shouldStartWith("prefix-"))
        .verifyComplete();
}
```

## **10. Mocking реактивных типов**

### Использование Mockito с реактивными типами:
```java
@ExtendWith(MockitoExtension.class)
class ReactiveServiceTest {
    
    @Mock
    private ReactiveRepository repository;
    
    @InjectMocks
    private UserService userService;
    
    @Test
    void testWithMocks() {
        when(repository.findById("123"))
            .thenReturn(Mono.just(new User("123", "John")));
        
        StepVerifier.create(userService.getUser("123"))
            .assertNext(user -> assertThat(user.getName()).isEqualTo("John"))
            .verifyComplete();
        
        verify(repository).findById("123");
    }
}
```

## **Зависимость Maven/Gradle**

```xml
<!-- Maven -->
<dependency>
    <groupId>io.projectreactor</groupId>
    <artifactId>reactor-test</artifactId>
    <scope>test</scope>
</dependency>
```

```gradle
// Gradle
testImplementation 'io.projectreactor:reactor-test'
```

## **Лучшие практики**

1. **Всегда используйте StepVerifier** вместо блокирующих вызовов
2. **Применяйте Virtual Time** для тестирования временных операций
3. **Используйте TestPublisher** для сложных сценариев данных
4. **Тестируйте контекст** в распределенных системах
5. **Проверяйте backpressure** в высоконагруженных приложениях

Reactor Test предоставляет полный набор инструментов для надежного тестирования реактивных приложений, от простых последовательностей до сложных сценариев с временными задержками и управлением потоком данных.