# Реактивный подход vs Многопоточность: концептуальное сравнение

## **Реактивный подход (Reactive Programming)**

### Основная концепция
Реактивное программирование — это **парадигма, ориентированная на потоки данных и асинхронную обработку** с распространением изменений.

### Ключевые принципы:
- **Асинхронность и неблокирующие операции**
- **Обработка потоков данных** (data streams)
- **Событийно-ориентированная архитектура**
- **Backpressure** — управление нагрузкой между производителем и потребителем

### Реактивные паттерны:
```java
// Пример Reactor (Spring WebFlux)
Flux.interval(Duration.ofMillis(100))
    .map(i -> i * 2)
    .filter(i -> i % 4 == 0)
    .subscribe(
        data -> System.out.println("Received: " + data),
        error -> System.err.println("Error: " + error),
        () -> System.out.println("Completed")
    );
```

---

## **Традиционная многопоточность (Thread-based)**

### Основная концепция
Создание и управление отдельными потоками выполнения для параллельной обработки задач.

### Ключевые подходы:
- **Thread/Runnable**
- **ExecutorService/ThreadPool**
- **Synchronized блоки**
- **Lock/Monitor механизмы**

```java
// Традиционная многопоточность
ExecutorService executor = Executors.newFixedThreadPool(10);
for (int i = 0; i < 100; i++) {
    executor.submit(() -> {
        // Синхронная блокирующая операция
        String result = blockingHttpCall();
        processResult(result);
    });
}
```

---

## **Сравнительная таблица**

| Аспект | Реактивный подход | Традиционная многопоточность |
|--------|-------------------|-------------------------------|
| **Модель выполнения** | Асинхронная, неблокирующая | Синхронная, блокирующая |
| **Использование потоков** | Малое число потоков (обычно = числу ядер) | Много потоков (1 запрос = 1 поток) |
| **Потребление памяти** | Низкое (меньше стеков потоков) | Высокое (каждый поток ~1MB стека) |
| **Масштабируемость** | Высокая (тысячи соединений на поток) | Ограничена количеством потоков |
| **Сложность** | Высокая (кривая обучения) | Средняя (интуитивно понятнее) |
| **Обработка ошибок** | Функциональный стиль (onError) | Try-catch в каждом потоке |
| **Backpressure** | Встроенная поддержка | Требует ручной реализации |
| **Контекст переключения** | Минимальный (event loop) | Высокий (переключение потоков) |

---

## **Архитектурные различия**

### Реактивная архитектура (Event Loop)
```
┌─────────────┐    ┌─────────────┐
│   Event     │    │   Worker    │
│   Loop      │───▶│   Threads   │
│ (1 thread)  │    │  (N threads)│
└─────────────┘    └─────────────┘
      │                    │
      ▼                    ▼
 I/O операции       CPU-intensive
 completion          задачи
```

### Многопоточная архитектура (Thread-per-request)
```
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Request   │    │   Thread    │    │    I/O      │
│    1        │───▶│      1      │───▶│  Operation  │
└─────────────┘    └─────────────┘    └─────────────┘
┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   Request   │    │   Thread    │    │    I/O      │
│    2        │───▶│      2      │───▶│  Operation  │
└─────────────┘    └─────────────┘    └─────────────┘
```

---

## **Производительность и ресурсы**

### Память:
- **Реактивный**: ~1-4 потока на CPU ядро
- **Многопоточный**: 100-1000+ потоков (1-2GB только на стеки)

### Контекст переключения:
- **Реактивный**: минимальные переключения (в пределах event loop)
- **Многопоточный**: частые дорогостоящие переключения контекста

### Пример нагрузки:
```java
// Реактивный - 10к соединений на 4 потока
@RestController
public class ReactiveController {
    @GetMapping("/reactive")
    public Mono<String> getData() {
        return webClient.get()
                       .uri("/api/data")
                       .retrieve()
                       .bodyToMono(String.class);
    }
}

// Многопоточный - 10к соединений = 10к потоков
@RestController  
public class TraditionalController {
    @GetMapping("/traditional")
    public String getData() {
        // Блокирует поток на время выполнения
        return restTemplate.getForObject("/api/data", String.class);
    }
}
```

---

## **Use Cases**

### Реактивный подход лучше для:
- **Высоконагруженные I/O приложения** (веб-сервисы, API гейтвеи)
- **Стриминговые приложения** (real-time данные, чаты)
- **Микросервисы** с большим количеством сетевых вызовов
- **Приложения с ограниченными ресурсами**

### Многопоточность лучше для:
- **CPU-intensive задачи** (обработка изображений, вычисления)
- **Легаси системы** с синхронными библиотеками
- **Простые приложения** с низкой нагрузкой
- **Когда важнее простота разработки**

---

## **Spring Boot реализация**

### Реактивный стек (WebFlux):
```java
@SpringBootApplication
public class ReactiveApp {
    public static void main(String[] args) {
        SpringApplication.run(ReactiveApp.class, args);
    }
}

@RestController
class ReactiveController {
    @GetMapping("/flux")
    public Flux<String> getStream() {
        return Flux.interval(Duration.ofSeconds(1))
                   .map(i -> "Data " + i);
    }
}
```

### Традиционный стек (Web MVC):
```java
@SpringBootApplication
public class TraditionalApp {
    public static void main(String[] args) {
        SpringApplication.run(TraditionalApp.class, args);
    }
}

@RestController
class TraditionalController {
    @GetMapping("/list")
    public List<String> getList() {
        return Arrays.asList("data1", "data2", "data3");
    }
}
```

---

## **Гибридный подход**

Современные приложения часто используют комбинацию:
```java
@Service
public class HybridService {
    
    // Реактивный для I/O операций
    public Mono<String> fetchDataAsync(String id) {
        return webClient.get()
                       .uri("/api/data/" + id)
                       .retrieve()
                       .bodyToMono(String.class);
    }
    
    // Многопоточный для CPU-intensive задач
    @Async
    public CompletableFuture<String> processData(String data) {
        // Тяжелые вычисления в отдельном потоке
        String result = heavyComputation(data);
        return CompletableFuture.completedFuture(result);
    }
}
```

---

## **Заключение**

- **Реактивный подход** — для масштабируемости и эффективности при I/O нагрузке
- **Многопоточность** — для простоты разработки и CPU-intensive задач
- **Выбор зависит** от конкретных требований проекта, нагрузки и команды

Современная тенденция — переход к реактивным подходам для веб-приложений, особенно в микросервисной архитектуре, где эффективность использования ресурсов критически важна.