**Операторы преобразования в реактивном программировании:**

## **map**
- Преобразует каждый элемент потока в другой элемент синхронно
- Сохраняет порядок и количество элементов
```java
Observable.just(1, 2, 3)
    .map(x -> x * 2)  // [2, 4, 6]
```

## **flatMap**
- Преобразует каждый элемент в новый поток (Observable)
- Объединяет все потоки в один, может менять порядок элементов
- Все внутренние потоки выполняются параллельно
```java
Observable.just(1, 2, 3)
    .flatMap(x -> Observable.just(x, x * 10))
    // Результат: 1, 10, 2, 20, 3, 30 (порядок может меняться)
```

## **concatMap**
- Аналогичен flatMap, но сохраняет строгий порядок элементов
- Внутренние потоки выполняются последовательно
```java
Observable.just(1, 2, 3)
    .concatMap(x -> Observable.just(x, x * 10))
    // Результат: 1, 10, 2, 20, 3, 30 (порядок гарантирован)
```

## **switchMap**
- При получении нового элемента отменяет предыдущий внутренний поток
- Полезен для поиска, когда важен только последний запрос
```java
searchInputObservable
    .switchMap(query -> api.search(query))
    // При новом поиске старый запрос отменяется
```

## **Разница между flatMap и concatMap**

| Аспект | flatMap | concatMap |
|--------|---------|-----------|
| **Порядок** | Не гарантирован | Строгий порядок |
| **Параллелизм** | Параллельное выполнение | Последовательное выполнение |
| **Backpressure** | Может перегрузить систему | Более безопасен |

## **Когда использовать**

**flatMap** - когда:
- Порядок не важен
- Нужна максимальная производительность
- Операции независимы друг от друга

**concatMap** - когда:
- Важен строгий порядок обработки
- Операции должны выполняться последовательно
- Работа с ресурсами, требующими порядка

**switchMap** - когда:
- Нужен только последний результат (поиск, автодополнение)
- Хотим отменять предыдущие операции

## **Примеры использования**

```java
// flatMap - параллельные HTTP запросы
userIds.flatMap(id -> api.getUser(id))

// concatMap - последовательная запись в файл
data.concatMap(item -> writeToFile(item))

// switchMap - поиск с отменой старых запросов
searchText.switchMap(query -> searchApi(query))
```

Выбор оператора зависит от требований к порядку, параллелизму и обработке backpressure в вашем конкретном сценарии.