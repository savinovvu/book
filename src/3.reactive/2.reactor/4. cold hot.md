### Холодные (Cold) и горячие (Hot) потоки в Reactor

#### **Холодные потоки (Cold Streams)**
- **Определение**: Холодные потоки **генерируют данные заново для каждого подписчика**. Каждая подписка запускает отдельное выполнение потока, и данные передаются независимо.
- **Аналогия**: Как просмотр фильма по запросу — каждый зритель начинает с начала.
- **Поведение**:
    - Ленивая инициализация: данные начинают emit только при подписке.
    - Независимое выполнение для каждого `Subscriber`.
- **Примеры в Reactor**:
    1. **`Flux.range`**:
       ```java
       Flux<Integer> coldFlux = Flux.range(1, 3);
       coldFlux.subscribe(v -> System.out.println("Subscriber 1: " + v)); // Вывод: 1, 2, 3
       coldFlux.subscribe(v -> System.out.println("Subscriber 2: " + v)); // Вывод: 1, 2, 3 (заново)
       ```
    2. **`Flux.fromIterable`**:
       ```java
       Flux<String> coldFlux = Flux.fromIterable(Arrays.asList("A", "B", "C"));
       coldFlux.subscribe(v -> System.out.println("Sub 1: " + v)); // Вывод: A, B, C
       coldFlux.subscribe(v -> System.out.println("Sub 2: " + v)); // Вывод: A, B, C (заново)
       ```

#### **Горячие потоки (Hot Streams)**
- **Определение**: Горячие потоки **исполняются независимо от подписчиков**. Данные генерируются один раз, и подписчики получают только те данные, которые emit после их подписки.
- **Аналогия**: Прямая трансляция — зрители видят события с момента подключения.
- **Поведение**:
    - Активны даже без подписчиков.
    - Общие данные для всех подписчиков.
- **Примеры в Reactor**:
    1. **`ConnectableFlux`**:
       ```java
       ConnectableFlux<Integer> hotFlux = Flux.range(1, 3).delayElements(Duration.ofMillis(500)).publish();
       hotFlux.connect(); // Начинает emit данных, даже без подписчиков
       
       Thread.sleep(600);
       hotFlux.subscribe(v -> System.out.println("Subscriber 1: " + v)); // Может пропустить часть данных
       ```
    2. **`Flux.share()`**:
       ```java
       Flux<Integer> hotFlux = Flux.range(1, 3)
           .delayElements(Duration.ofMillis(500))
           .share(); // Превращает холодный поток в горячий
       
       hotFlux.subscribe(v -> System.out.println("Sub 1: " + v));
       Thread.sleep(600);
       hotFlux.subscribe(v -> System.out.println("Sub 2: " + v)); // Sub 2 получит не все данные.
       ```
    3. **`Flux.broadcast()`** (через `publish().autoConnect()`):
       ```java
       Flux<Integer> hotFlux = Flux.range(1, 3)
           .publish()
           .autoConnect(1); // Запускается при первом подписчике
       
       hotFlux.subscribe(v -> System.out.println("Sub 1: " + v)); // Запускает поток
       Thread.sleep(100);
       hotFlux.subscribe(v -> System.out.println("Sub 2: " + v)); // Получает остаток данных.
       ```

### Ключевые различия
| Характеристика       | Холодный поток                          | Горячий поток                          |
|----------------------|----------------------------------------|---------------------------------------|
| **Источник данных**  | Независимый для каждого подписчика.    | Общий для всех подписчиков.           |
| **Время генерации**  | При подписке.                          | Независимо от подписчиков.            |
| **Примеры**          | `Flux.range`, `Flux.fromIterable`.     | `ConnectableFlux`, `Flux.share()`.    |

### Когда использовать?
- **Cold**: Если данные должны быть уникальными для каждой подписки (например, HTTP-запросы).
- **Hot**: Для общих событий (например, уведомления в реальном времени, данные с датчиков).