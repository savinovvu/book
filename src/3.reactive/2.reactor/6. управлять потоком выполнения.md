### Управление потоком выполнения в Reactor

В Reactor управление потоком выполнения осуществляется с помощью **Schedulers**, которые позволяют контролировать многопоточность и распределять задачи по конкретным исполнителям (например, пулам потоков). Ключевые операторы для управления потоком:

1. **`subscribeOn`**  
   Определяет **Scheduler**, на котором будет выполняться вся цепочка операторов (от источника до подписки).  
   Пример:
   ```java
   Flux.range(1, 10)
       .subscribeOn(Schedulers.parallel())
       .subscribe();
   ```

2. **`publishOn`**  
   Влияет на все последующие операторы после его вызова, переключая их выполнение на указанный **Scheduler**.  
   Пример:
   ```java
   Flux.range(1, 10)
       .map(i -> i * 2)
       .publishOn(Schedulers.boundedElastic())
       .subscribe();
   ```

3. **Параллельные потоки**  
   Использование `Flux.parallel()` и `ParallelFlux` для параллельной обработки элементов:
   ```java
   Flux.range(1, 10)
       .parallel()
       .runOn(Schedulers.parallel())
       .subscribe();
   ```

---

### Schedulers и их реализации

**Schedulers** — это фабрики потоков, управляющие многопоточностью в Reactor. Основные реализации:

1. **`Schedulers.immediate()`**  
   Выполняет задачи в текущем потоке (без асинхронности).

2. **`Schedulers.single()`**  
   Один общий поток для всех задач. Удобен для последовательных задач.

3. **`Schedulers.elastic()`**  
   **Устарел**. Создавал пул потоков, который автоматически расширялся. Заменен на `boundedElastic`.

4. **`Schedulers.boundedElastic()`**  
   Пул с ограниченным числом потоков (по умолчанию = 10 * число ядер). Подходит для **блокирующих операций** (например, I/O). Автоматически управляет очередью задач.

5. **`Schedulers.parallel()`**  
   Фиксированный пул потоков (размер = числу ядер). Оптимален для **CPU-интенсивных задач**.

6. **`Schedulers.fromExecutorService(ExecutorService)`**  
   Интеграция с кастомным `ExecutorService`.

---

### Примеры использования

```java
// Блокирующая задача в boundedElastic
Mono.fromCallable(() -> blockingIoMethod())
    .subscribeOn(Schedulers.boundedElastic())
    .subscribe();

// Параллельная обработка
Flux.range(1, 100)
    .parallel()
    .runOn(Schedulers.parallel())
    .map(i -> i * 2)
    .sequential() // Возврат к обычному Flux
    .subscribe();

// Комбинация publishOn и subscribeOn
Flux.just("data")
    .publishOn(Schedulers.parallel()) // Последующие операторы в parallel
    .map(str -> str.toUpperCase())
    .subscribeOn(Schedulers.boundedElastic()) // Источник в boundedElastic
    .subscribe();
```

---

### Рекомендации

- Используйте **`boundedElastic`** для блокирующих операций (например, сетевые запросы, работа с БД).
- Используйте **`parallel`** для CPU-задач, которые можно распараллелить.
- Избегайте блокирующих вызовов в потоках `parallel`, чтобы не снижать производительность.
- Для тестирования подключайте **`StepVerifier`** с виртуальным временем или явно указывайте `Schedulers`.

```java
// Тестирование с виртуальным временем
StepVerifier.withVirtualTime(() -> Mono.delay(Duration.ofDays(1)))
            .expectSubscription()
            .expectNoEvent(Duration.ofDays(1))
            .expectNext(0L)
            .verifyComplete();
```

Управление потоком в Reactor через `Schedulers` обеспечивает гибкость и эффективность при работе с асинхронными и параллельными задачами.