Чтобы мокировать реактивные вызовы (Mono/Flux) в тестах с помощью Mockito, следуйте этим подходам:

### 1. **Базовое мокирование Mono/Flux**
Используйте стандартные методы Mockito, чтобы задать поведение моков.

```java
import reactor.core.publisher.Mono;
import org.mockito.Mockito;

// Мокируем сервис
MyReactiveService service = Mockito.mock(MyReactiveService.class);

// Мокируем Mono
Mockito.when(service.findDataById("1"))
       .thenReturn(Mono.just("test-data"));

// Мокируем Flux
Mockito.when(service.streamData())
       .thenReturn(Flux.just("a", "b", "c"));
```

### 2. **Мокирование ошибок**
```java
// Для ошибки в Mono
Mockito.when(service.findDataById("error"))
       .thenReturn(Mono.error(new RuntimeException("Error!")));

// Для ошибки в Flux
Mockito.when(service.streamData())
       .thenReturn(Flux.error(new IllegalStateException()));
```

### 3. **Проверка вызовов с реактивными типами**
Используйте `StepVerifier` (из reactor-test) для проверки результатов:
```java
import reactor.test.StepVerifier;

StepVerifier.create(service.findDataById("1"))
    .expectNext("test-data")
    .verifyComplete();

// Проверка ошибки
StepVerifier.create(service.findDataById("error"))
    .expectError(RuntimeException.class)
    .verify();
```

### 4. **Аргумент-матчеры для реактивных методов**
Если метод принимает параметры, используйте аргумент-матчеры:
```java
Mockito.anyString(), Mockito.anyInt() и т.п.

Mockito.when(service.findDataById(Mockito.anyString()))
       .thenReturn(Mono.just("default-data"));
```

### 5. **Мокирование цепочек вызовов**
Если метод возвращает Mono/Flux, который преобразуется в цепочке, мокируйте исходный вызов:
```java
// Исходный мок
Mockito.when(service.findDataById("1"))
       .thenReturn(Mono.just("raw-data"));

// Тестируем цепочку
StepVerifier.create(service.findDataById("1").map(String::toUpperCase))
    .expectNext("RAW-DATA")
    .verifyComplete();
```

### 6. **Использование `@MockBean` в Spring Boot**
В Spring-тестах используйте `@MockBean` для автоматической замены бинов в контексте:
```java
@SpringBootTest
class MyServiceTest {
    @MockBean
    private MyReactiveService service;

    @Test
    void test() {
        Mockito.when(service.findDataById("1"))
               .thenReturn(Mono.just("mock-data"));

        StepVerifier.create(service.findDataById("1"))
            .expectNext("mock-data")
            .verifyComplete();
    }
}
```

### 7. **Верификация вызовов**
Убедитесь, что метод был вызван с нужными параметрами:
```java
Mockito.verify(service, Mockito.times(1))
       .findDataById("1");
```

### Пример полного теста
```java
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import reactor.test.StepVerifier;

class MyServiceTest {
    @Mock
    private MyReactiveService service;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
    }

    @Test
    void testFindData() {
        // Задаем поведение
        Mockito.when(service.findDataById("123"))
               .thenReturn(Mono.just("result"));

        // Запускаем и проверяем
        StepVerifier.create(service.findDataById("123"))
                .expectNext("result")
                .verifyComplete();

        // Проверяем вызов
        Mockito.verify(service).findDataById("123");
    }
}
```

### Важно:
- Всегда используйте `StepVerifier` для тестирования реактивных потоков.
- Не мокируйте сами реактивные типы (например, `Mono.just()`), а мокируйте методы, которые их возвращают.
- Для сложных сценариев (например, повторные вызовы) используйте `thenReturn` с несколькими возвращаемыми значениями.