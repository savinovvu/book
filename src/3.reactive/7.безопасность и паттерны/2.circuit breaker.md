**Circuit Breaker (Предохранитель)** в реактивных приложениях — это паттерн для повышения отказоустойчивости, который предотвращает каскадные сбои и позволяет системе элегантно обрабатывать временные неполадки внешних сервисов. Принцип работы аналогичен электронному предохранителю:
- **Closed** (Закрыт): Запросы выполняются как обычно.
- **Open** (Открыт): При превышении порога ошибок предохранитель "разрывает цепь", и запросы немедленно отклоняются без вызова внешнего сервиса.
- **Half-Open** (Полуоткрыт): Через заданное время разрешается ограниченное количество пробных запросов. Если они успешны — предохранитель закрывается, иначе снова открывается.

В реактивных приложениях (например, с Project Reactor) Circuit Breaker интегрируется с неблокирующими потоками данных (Mono/Flux).

---

### **Опыт использования Resilience4j с Reactor**
**Resilience4j** — популярная библиотека для реализации паттернов отказоустойчивости, включая Circuit Breaker. Она хорошо сочетается с Reactor через операторы `transformDeferred` и специальные адаптеры.

#### **1. Добавление зависимостей**
```xml
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-reactor</artifactId>
    <version>2.0.2</version>
</dependency>
<dependency>
    <groupId>io.github.resilience4j</groupId>
    <artifactId>resilience4j-circuitbreaker</artifactId>
    <version>2.0.2</version>
</dependency>
```

#### **2. Настройка Circuit Breaker**
```java
CircuitBreakerConfig config = CircuitBreakerConfig.custom()
    .failureRateThreshold(50) // Порог ошибок в %
    .slidingWindowSize(5)     // Размер окна для анализа ошибок
    .waitDurationInOpenState(Duration.ofSeconds(60))
    .permittedNumberOfCallsInHalfOpenState(3)
    .build();

CircuitBreakerRegistry registry = CircuitBreakerRegistry.of(config);
CircuitBreaker circuitBreaker = registry.circuitBreaker("myService");
```

#### **3. Интеграция с Reactor**
```java
public Mono<String> callExternalService() {
    return Mono.fromCallable(() -> httpClient.callExternalApi())
        .transformDeferred(CircuitBreakerOperator.of(circuitBreaker))
        .onErrorMap(CallNotPermittedException.class, e -> 
            new ServiceUnavailableException("Service temporarily unavailable"))
        .timeout(Duration.ofSeconds(5));
}
```

#### **4. Обработка состояний предохранителя**
- **Open State**: При открытом предохранителе вызовы выбрасывают `CallNotPermittedException`.
- **Half-Open**: Resilience4j автоматически управляет пробными запросами.
- **События**: Можно слушать события (например, переход в OPEN) через `CircuitBreaker.EventPublisher`.

#### **5. Комбинирование с другими операторами Reactor**
```java
Mono<String> result = callExternalService()
    .retryWhen(Retry.fixedDelay(3, Duration.ofSeconds(2))
    .doOnError(e -> log.error("Failed after retries", e));
```

---

### **Ключевые преимущества Resilience4j с Reactor**
1. **Неблокирующая реализация**: Не блокирует потоки, что критично для реактивных приложений.
2. **Интеграция с Mono/Flux**: Операторы `transformDeferred` гарантируют применение Circuit Breaker к каждому подписчику.
3. **Гибкая конфигурация**: Настройки порогов, таймаутов, обработки исключений.
4. **Метрики и мониторинг**: Интеграция с Micrometer для сбора метрик.

---

### **Пример полного кода**
```java
@RestController
public class MyController {
    private final WebClient webClient;
    private final CircuitBreaker circuitBreaker;

    public MyController() {
        this.webClient = WebClient.builder().baseUrl("http://external-service").build();
        this.circuitBreaker = CircuitBreaker.of("weatherService", 
            CircuitBreakerConfig.custom()
                .failureRateThreshold(50)
                .waitDurationInOpenState(Duration.ofSeconds(30))
                .build()
        );
    }

    @GetMapping("/data")
    public Mono<String> getData() {
        return webClient.get()
            .uri("/api/data")
            .retrieve()
            .bodyToMono(String.class)
            .transformDeferred(CircuitBreakerOperator.of(circuitBreaker))
            .onErrorResume(e -> Mono.just("Fallback data"));
    }
}
```

---

### **Советы по использованию**
- **Тестирование**: Используйте `StepVerifier` для проверки сценариев:
  ```java
  StepVerifier.create(getData())
      .expectNext("Fallback data")
      .verifyComplete();
  ```
- **Исключения**: Настройте `ignoreExceptions` в конфигурации, чтобы не учитывать некритичные ошибки (например, `4xx` клиентские ошибки).
- **Комбинация с Retry**: Добавляйте повторные попытки, но осторожно — это может усугубить нагрузку при открытом предохранителе.

Resilience4j с Reactor обеспечивает надежный механизм защиты систем от сбоев, сохраняя реактивную модель без блокирующих операций.