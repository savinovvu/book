Управление состоянием в реактивных приложениях с использованием Reactor (Project Reactor для Java) требует особого подхода. Рассмотрим ключевые аспекты:

## 1. Основные принципы управления состоянием

### Иммутабельность и чистые функции
```java
public class UserState {
    private final String id;
    private final String name;
    private final List<String> roles;
    
    public UserState updateName(String newName) {
        return new UserState(this.id, newName, this.roles);
    }
}
```

### Reactor Context для хранения состояния
```java
public Mono<String> getUserData(String userId) {
    return Mono.deferContextual(ctx -> {
        String requestId = ctx.get("requestId");
        String authToken = ctx.getOrEmpty("authToken")
                            .map(Object::toString)
                            .orElse("anonymous");
        
        return userRepository.findById(userId)
            .map(user -> user + " [request: " + requestId + "]")
            .contextWrite(Context.of("authToken", "bearer-token"));
    });
}

// Использование
getUserData("123")
    .contextWrite(Context.of("requestId", "req-123"))
    .subscribe();
```

## 2. Паттерны кеширования в Reactor

### In-Memory кеширование с Caffeine
```java
@Component
public class UserCacheService {
    private final Cache<String, Mono<User>> cache;
    
    public UserCacheService() {
        this.cache = Caffeine.newBuilder()
            .expireAfterWrite(Duration.ofMinutes(30))
            .maximumSize(10_000)
            .build();
    }
    
    public Mono<User> getUser(String id) {
        return cache.get(id, 
            key -> userRepository.findById(key)
                .cache() // Кешируем результат Mono
                .doOnNext(user -> 
                    log.info("User {} loaded from DB", user.getId()))
        );
    }
}
```

### Кеширование с реактивными операторами
```java
public class ProductService {
    
    public Mono<Product> getProductWithCache(String id) {
        return Mono.fromCallable(() -> id)
            .flatMap(this::getFromCache)
            .switchIfEmpty(Mono.defer(() -> 
                getFromDatabase(id)
                    .flatMap(this::putToCache)
            ));
    }
    
    private Mono<Product> getFromCache(String id) {
        return redisTemplate.opsForValue()
            .get("product:" + id)
            .map(this::deserializeProduct);
    }
    
    private Mono<Product> putToCache(Product product) {
        return redisTemplate.opsForValue()
            .set("product:" + product.getId(), 
                 serializeProduct(product),
                 Duration.ofHours(1))
            .thenReturn(product);
    }
}
```

### Time-based кеширование
```java
public Mono<List<Product>> getFeaturedProducts() {
    return productRepository.findFeatured()
        .cache(Duration.ofMinutes(5)) // Автоматическое инвалидирование
        .doOnSubscribe(s -> 
            log.info("Loading featured products from cache or source"));
}
```

## 3. Использование Sinks для кастомных потоков

### Hot Stream с Sinks.Many
```java
@Component
public class EventBus {
    private final Sinks.Many<Event> eventSink;
    private final Flux<Event> eventStream;
    
    public EventBus() {
        this.eventSink = Sinks.many().multicast().onBackpressureBuffer();
        this.eventStream = eventSink.asFlux().publish().autoConnect();
    }
    
    public void publish(Event event) {
        eventSink.tryEmitNext(event);
    }
    
    public Flux<Event> getStream() {
        return eventStream;
    }
    
    public Flux<Event> getStreamForType(EventType type) {
        return eventStream
            .filter(event -> event.getType() == type)
            .onBackpressureDrop(event -> 
                log.warn("Dropped event: {}", event));
    }
}
```

### Stateful Sink для управления состоянием
```java
public class CounterService {
    private final Sinks.Many<Integer> counterSink;
    private final AtomicInteger currentCount;
    private final Flux<Integer> counterStream;
    
    public CounterService() {
        this.counterSink = Sinks.many().replay().latest();
        this.currentCount = new AtomicInteger(0);
        this.counterStream = counterSink.asFlux();
    }
    
    public void increment() {
        int newValue = currentCount.incrementAndGet();
        counterSink.tryEmitNext(newValue);
    }
    
    public void reset() {
        currentCount.set(0);
        counterSink.tryEmitNext(0);
    }
    
    public Flux<Integer> getCounterStream() {
        return counterStream;
    }
}
```

### Sinks для request-response коммуникации
```java
public class RequestResponseProcessor {
    private final Sinks.Many<Request> requestSink;
    private final Flux<Response> responseStream;
    
    public RequestResponseProcessor() {
        this.requestSink = Sinks.many().unicast().onBackpressureBuffer();
        
        this.responseStream = requestSink.asFlux()
            .flatMap(this::processRequest)
            .publish()
            .autoConnect();
    }
    
    public Mono<Response> sendRequest(Request request) {
        return Mono.create(sink -> {
            // Отправляем запрос
            requestSink.tryEmitNext(request);
            
            // Ждем ответ с matching correlationId
            responseStream
                .filter(response -> 
                    response.getCorrelationId().equals(request.getId()))
                .next()
                .subscribe(sink::success, sink::error);
        });
    }
    
    private Mono<Response> processRequest(Request request) {
        return Mono.fromCallable(() -> 
            new Response("processed: " + request.getData(), 
                        request.getId())
        ).delayElement(Duration.ofMillis(100));
    }
}
```

## 4. Продвинутые паттерны

### State Management с scan оператором
```java
public class ShoppingCartService {
    
    public Flux<CartState> cartStateStream(String userId) {
        return getCartEvents(userId)
            .scan(CartState.empty(), this::reduceState)
            .distinctUntilChanged();
    }
    
    private CartState reduceState(CartState current, CartEvent event) {
        return switch (event.getType()) {
            case ADD_ITEM -> current.addItem(event.getItem());
            case REMOVE_ITEM -> current.removeItem(event.getItemId());
            case CLEAR -> CartState.empty();
        };
    }
}
```

### Debounced State Updates
```java
public class SearchService {
    
    public Flux<List<Product>> searchProducts(String query) {
        return Flux.just(query)
            .debounce(Duration.ofMillis(300)) // Анти-дребезг
            .distinctUntilChanged()
            .switchMap(this::executeSearch)
            .cache(1); // Кешируем последний результат
    }
    
    private Mono<List<Product>> executeSearch(String query) {
        return productRepository.search(query)
            .timeout(Duration.ofSeconds(5))
            .onErrorReturn(Collections.emptyList());
    }
}
```

### Resource Management с usingWhen
```java
public Mono<Transaction> executeTransaction(TransactionRequest request) {
    return Mono.usingWhen(
        transactionManager.beginTransaction(), // Resource acquisition
        transaction -> processTransaction(request, transaction),
        transaction -> transaction.commit(),    // Async commit
        (transaction, error) -> transaction.rollback(), // Rollback on error
        transaction -> transaction.rollback()   // Rollback on cancel
    );
}
```

## 5. Best Practices

1. **Используйте иммутабельные структуры данных** для состояния
2. **Разделяйте горячие и холодные потоки** соответствующими Sinks
3. **Всегда обрабатывайте backpressure** с помощью соответствующих стратегий
4. **Используйте context для request-scoped данных**
5. **Кешируйте правильно** - учитывайте TTL и размер кеша
6. **Обрабатывайте ошибки в Sinks** с помощью tryEmitError
7. **Тестируйте с StepVerifier** и Virtual Time

```java
@Test
void testEventBus() {
    EventBus eventBus = new EventBus();
    
    StepVerifier.create(eventBus.getStream().take(2))
        .then(() -> {
            eventBus.publish(new Event("test1"));
            eventBus.publish(new Event("test2"));
        })
        .expectNextMatches(e -> e.getData().equals("test1"))
        .expectNextMatches(e -> e.getData().equals("test2"))
        .verifyComplete();
}
```

Эти паттерны помогут создать эффективное и масштабируемое реактивное приложение с грамотным управлением состоянием.