Вот пример реализации аутентификации в реактивном Spring-приложении с использованием Spring Security 5 и `ReactiveSecurityContextHolder`:

```java
@Configuration
@EnableWebFluxSecurity
public class SecurityConfig {

    @Bean
    public SecurityWebFilterChain securityWebFilterChain(ServerHttpSecurity http) {
        return http
            .authorizeExchange(exchanges -> exchanges
                .pathMatchers("/public/**").permitAll()
                .anyExchange().authenticated()
            )
            .httpBasic(withDefaults())
            .formLogin(withDefaults())
            .authenticationManager(authenticationManager())
            .securityContextRepository(securityContextRepository())
            .build();
    }

    @Bean
    public ReactiveAuthenticationManager authenticationManager() {
        UserDetailsRepositoryReactiveAuthenticationManager manager = 
            new UserDetailsRepositoryReactiveAuthenticationManager(userDetailsService());
        manager.setPasswordEncoder(passwordEncoder());
        return manager;
    }

    @Bean
    public ReactiveUserDetailsService userDetailsService() {
        UserDetails user = User.builder()
            .username("user")
            .password(passwordEncoder().encode("password"))
            .roles("USER")
            .build();
        return new MapReactiveUserDetailsService(user);
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public ServerSecurityContextRepository securityContextRepository() {
        return new WebSessionServerSecurityContextRepository();
    }
}
```

Для работы с аутентификацией в реактивных контроллерах используйте `ReactiveSecurityContextHolder`:

```java
@RestController
public class UserController {

    @GetMapping("/profile")
    public Mono<String> getCurrentUser() {
        return ReactiveSecurityContextHolder.getContext()
            .map(SecurityContext::getAuthentication)
            .map(Authentication::getName)
            .map(username -> "Текущий пользователь: " + username);
    }

    @PostMapping("/login")
    public Mono<ResponseEntity<?>> login(@RequestBody AuthRequest request) {
        return authenticationManager.authenticate(
            new UsernamePasswordAuthenticationToken(request.username(), request.password())
        )
        .map(authentication -> {
            SecurityContextImpl context = new SecurityContextImpl(authentication);
            return new WebSessionServerSecurityContextRepository()
                .save(ReactiveSecurityContextHolder.withSecurityContext(Mono.just(context)))
                .thenReturn(ResponseEntity.ok("Аутентификация успешна"));
        })
        .flatMap(mono -> mono);
    }
}
```

Для кастомной JWT-аутентификации:

```java
@Component
public class JwtAuthenticationFilter implements WebFilter {

    @Override
    public Mono<Void> filter(ServerWebExchange exchange, WebFilterChain chain) {
        String token = extractToken(exchange.getRequest());
        if (token != null && validateToken(token)) {
            return Mono.just(createAuthentication(token))
                .flatMap(authentication -> {
                    SecurityContext context = new SecurityContextImpl(authentication);
                    return chain.filter(exchange)
                        .contextWrite(ReactiveSecurityContextHolder.withSecurityContext(Mono.just(context)));
                });
        }
        return chain.filter(exchange);
    }

    private Authentication createAuthentication(String token) {
        String username = extractUsername(token);
        return new UsernamePasswordAuthenticationToken(
            username, 
            null, 
            Arrays.asList(new SimpleGrantedAuthority("ROLE_USER"))
        );
    }
}
```

**Ключевые моменты:**

1. **ReactiveAuthenticationManager** - центральный компонент для проверки учетных данных
2. **ServerSecurityContextRepository** - хранит контекст безопасности в WebSession
3. **ReactiveSecurityContextHolder** - предоставляет доступ к контексту в реактивном контексте
4. **WebFilter** для кастомной аутентификации (например, JWT)

**Паттерны безопасности:**
- Используйте BCrypt для хеширования паролей
- JWT для statless-аутентификации
- CSRF-токены для защиты от межсайтовой подделки запросов
- CORS-настройки для контроля междоменных запросов

**Пример DTO для аутентификации:**
```java
public record AuthRequest(String username, String password) {}
```

Все операции должны быть реактивными и неблокирующими. Для хранения сессий рекомендуется использовать Redis в реактивном режиме.