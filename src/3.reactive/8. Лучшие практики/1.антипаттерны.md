В реактивном программировании (например, в Project Reactor, RxJava) есть несколько распространенных антипаттернов, которые нарушают принципы реактивности и могут привести к проблемам с производительностью, стабильностью и поддерживаемостью кода. Вот основные из них:

---

### 1. **Блокирующие вызовы внутри цепочки**
**Проблема**: Использование блокирующих операций (например, I/O, сетевые запросы, работа с БД) внутри реактивной цепочки разрушает асинхронную модель и может заблокировать общий пул потоков.

**Пример**:
```java
Mono.fromCallable(() -> {
    // Блокирующий вызов (например, JDBC)
    return blockingRepository.findById(id);
}).subscribeOn(Schedulers.boundedElastic()); // Вынужденное использование отдельного пула
```
**Почему антипаттерн**: Реактивные фреймворки рассчитаны на неблокирующие операции. Блокирующие вызовы сводят на нет преимущества асинхронности.

**Решение**: Использовать нативные реактивные драйверы (например, R2DBC для БД, WebClient для HTTP).

---

### 2. **Игнорирование Backpressure**
**Проблема**: Если производитель данных (Publisher) генерирует данные быстрее, чем потребитель (Subscriber) может их обработать, это приводит к переполнению памяти или сбоям.

**Пример**:
```java
Flux.range(1, 1_000_000)
    .doOnNext(item -> {
        // Медленная обработка
        Thread.sleep(10);
    })
    .subscribe();
```
**Почему антипаттерн**: Отсутствие механизма обратного давления приводит к накоплению необработанных данных.

**Решение**: Использовать операторы для управления backpressure (например, `onBackpressureBuffer`, `onBackpressureDrop`, `limitRate`).

---

### 3. **Разрыв цепочки (Breaking the Chain)**
**Проблема**: Использование глобальных состояний или побочных эффектов вне реактивной цепочки нарушает её целостность.

**Пример**:
```java
List<String> result = new ArrayList<>();
flux.collectList().subscribe(result::addAll); // Разрыв цепочки
```
**Почему антипаттерн**: Усложняет тестирование, нарушает иммутабельность и приводит к race condition.

**Решение**: Строить полную цепочку операторов и возвращать `Mono/Flux` до конца.

---

### 4. **Злоупотребление `subscribe()`**
**Проблема**: Вызов `subscribe()` в середине цепочки или внутри операторов (например, `flatMap`) создает незавершенные подписки.

**Пример**:
```java
flux.flatMap(item -> {
    Mono.just(item).subscribe(); // Неявная подписка
    return process(item);
});
```
**Почему антипаттерн**: Утечки памяти, потеря ошибок, неконтролируемая асинхронность.

**Решение**: Переиспользовать существующие цепочки, избегать вложенных `subscribe`.

---

### 5. **Игнорирование ошибок**
**Проблема**: Необработанные исключения прерывают работу потока без восстановления.

**Пример**:
```java
Flux.just(1, 0)
    .map(num -> 10 / num) // ArithmeticException при делении на 0
    .subscribe();
```
**Почему антипаттерн**: Приложение может аварийно завершиться или работать нестабильно.

**Решение**: Использовать операторы обработки ошибок (`onErrorReturn`, `onErrorResume`, `retry`).

---

### 6. **Неправильное использование Schedulers**
**Проблема**: Неверный выбор пула потоков (например, блокирующие задачи на `Schedulers.parallel()`).

**Пример**:
```java
Flux.range(1, 10)
    .publishOn(Schedulers.parallel())
    .map(item -> blockingCall(item)); // Блокирующий вызов на неподходящем пуле
```
**Почему антипаттерн**: Истощение потоков, деградация производительности.

**Решение**:
- Блокирующие задачи: `Schedulers.boundedElastic()`.
- CPU-интенсивные задачи: `Schedulers.parallel()`.
- Неблокирующиеся операции: оставлять на пуле по умолчанию.

---

### 7. **Избыточная кэширование Mono/Flux**
**Проблема**: Кэширование результатов без учета их изменчивости или времени жизни.

**Пример**:
```java
Mono<String> data = httpClient.get().cache(); // Бесконечное кэширование
```
**Почему антипаттерн**: Устаревшие данные, повышенное потребление памяти.

**Решение**: Использовать `cache` с ограничением по времени или количеству элементов.

---

### 8. **Игнорирование отмены подписки**
**Проблема**: Неосвобожденные ресурсы (например, сетевые соединения) при отмене подписки.

**Пример**:
```java
flux.subscribe(
    data -> process(data),
    error -> log.error(error),
    () -> cleanup() // Не вызывается при отмене
);
```
**Почему антипаттерн**: Утечки ресурсов.

**Решение**: Использовать `doOnCancel`, `doFinally` для очистки.

---

### 9. **Создание потоков в конструкторах**
**Проблема**: Запуск реактивных цепочек в конструкторах классов до вызова `subscribe()`.

**Пример**:
```java
public class Service {
    private final Flux<String> flux = Flux.create(sink -> {
        // Запуск при инициализации (до подписки)
    });
}
```
**Почему антипаттерн**: Холодные (cold) потоки могут не работать, как ожидается.

**Решение**: Откладывать выполнение до подписки (например, используя `Mono.defer`).

---

### 10. **Смешивание императивного и реактивного стилей**
**Проблема**: Попытки синхронно дождаться результатов (`block()`) в реактивном коде.

**Пример**:
```java
String result = httpClient.get()
    .bodyToMono(String.class)
    .block(); // Блокировка текущего потока
```
**Почему антипаттерн**: Уничтожает неблокирующие преимущества.

**Решение**: Сохранять асинхронную модель до границы системы (например, до контроллера в Spring WebFlux).

---

### Заключение
Реактивное программирование требует соблюдения определённых принципов: неблокируемость, асинхронность, управление backpressure и ресурсами. Нарушение этих принципов ведет к антипаттернам, которые сводят на нет все преимущества подхода. Всегда анализируйте код на наличие блокирующих операций, утечек ресурсов и правильности работы с потоками данных.