Отличная задача! Воссоздадим, как мог бы выглядеть файл `01-Процесс-дизайна-старт.md` из гипотетической книги Алекса Сю (Alex Xu) о дизайне систем на русском языке.

Это будет не дословный перевод (книга в основном на английском), а адаптация ключевых идей и процесса в стиле, характерном для его работ (как, например, в "System Design Interview").

---

# 01: Процесс дизайна системы — С чего начать

**Автор:** Алекс Сю (Alex Xu)
**Роль:** Senior Architect / Developer

## Введение

Дизайн системы — это не искусство, а инженерная дисциплина. Хороший дизайн не рождается из гениального озарения, а является результатом структурированного процесса. Цель этого процесса — создать систему, которая является **работоспособной, эффективной, надежной и масштабируемой**.

Частая ошибка на собеседованиях и в реальной работе — бросаться рисовать коробки и линии, не поняв сути проблемы. Этот документ — ваш план, как избежать этой ловушки.

## Шаг 1: Четко определите цель (Узнайте "Что?" прежде чем "Как?")

Прежде чем проектировать, вы должны полностью понять, *что* вы проектируете. Задавайте вопросы и уточняйте требования.

### 1.1. Сбор функциональных требований (Features)
*Что система должна ДЕЛАТЬ?*

*   **Пример для сервиса типа TinyURL:**
    *   Пользователь может ввести длинный URL и получить короткую ссылку.
    *   При переходе по короткой ссылке пользователь перенаправляется на оригинальный URL.
    *   Пользователи анонимны, регистрации нет.
    *   Ссылки действуют бессрочно.

*   **Ключевой вопрос:** "Каковы основные функции, которые должен видеть конечный пользователь?"

### 1.2. Сбор нефункциональных требований (Метрики и ограничения)
*Насколько ХОРОШО система должна это делать?*

Это самые важные вопросы для архитектора.

*   **Масштабируемость (Scalability):** Какой объем данных и трафика мы ожидаем?
    *   **Ключевые вопросы:**
        *   "Сколько новых ссылок создается в секунду (запись)?"
        *   "Сколько редиректов по ссылкам в секунду (чтение)?"
        *   "Какой будет объем данных через 5 лет?"
*   **Надежность (Reliability):** Насколько система должна быть доступна?
    *   **Ключевой вопрос:** "Каков допустимый процент времени простоя? (например, 99.9%, 99.99%?)"
*   **Производительность (Latency):** Как быстро должна работать система?
    *   **Ключевые вопросы:**
        *   "Какова максимальная задержка при создании короткой ссылки?"
        *   "Какова максимальная задержка при редиректе? (Она должна быть крайне мала!)"
*   **Доступность (Availability):** Может ли система терпеть сбои и оставаться работоспособной? (Часто путают с Reliability).

---

## Шаг 2: Прикидочный расчет (Back-of-the-envelope Estimation)

Теперь, имея требования, мы переводим их в конкретные числа. Это помогает выбрать правильные технологии и архитектурные решения.

**Продолжим пример с TinyURL:**

*   **Допущения:**
    *   Ежемесячно активных пользователей: 10 миллионов.
    *   Каждый пользователь создает в среднем 1 ссылку в месяц.
*   **Расчеты:**
    *   **Запросов на запись (QPS) в секунду:**
        *   Новых ссылок в месяц: `10M пользователей * 1 ссылка = 10M`
        *   QPS = `10M / (30 дней * 24 часа * 3600 секунд) ≈ ~4 операции/сек`
    *   **Запросов на чтение (QPS) в секунду:**
        *   Допустим, соотношение чтения к записи 100:1.
        *   QPS для редиректов = `4 * 100 = 400 операций/сек`
    *   **Объем данных:**
        *   Предположим, что каждая ссылка хранится 500 байт.
        *   Объем за 5 лет: `10M ссылок/мес * 12 месяцев * 5 лет * 500 байт ≈ 3 ТБ`

**Вывод:** Наша система должна быть оптимизирована под **очень высокую нагрузку на чтение** (400 QPS — это уже серьезно для одной базы данных) и накопление значительного объема данных (3 ТБ).

---

## Шаг 3: Модель данных (Data Model)

Как мы будем хранить информацию? На этом этапе мы решаем, какие "сущности" есть в нашей системе и как они связаны.

**Пример для TinyURL:**

*   **Основная сущность:** `UrlMapping`
    *   `id: BIGINT (Primary Key, Auto-increment)` — можно использовать для генерации короткой ссылки.
    *   `short_url_key: VARCHAR(10)` — уникальный ключ короткой ссылки (например, `a1B2c3`).
    *   `long_url: TEXT` — исходный длинный URL.
    *   `created_at: DATETIME`
    *   `expires_at: DATETIME` (если требуется)

**Почему это важно?** Выбор модели данных напрямую повлияет на то, какую базу данных мы выберем (SQL vs NoSQL) и как будем строить логику приложения.

---

## Шаг 4: Высокоуровневая архитектура (High-Level Design)

Теперь мы можем набросать первую схему. На этом этапе мы идентифицируем основные компоненты системы.

```
[Клиент] (Браузер/Приложение)
        |
        | (HTTP-запросы)
        |
    [Балансировщик нагрузки] (Load Balancer)
        |
        | (распределяет трафик)
        |
+-----------------------------------------------+
|          [Серверы приложения] (Web Servers)   |
| - Создание короткой ссылки (запись)           |
| - Редирект по короткой ссылке (чтение)        |
+-----------------------------------------------+
        |                    |
        | (запись)           | (чтение)
        |                    |
+------------------+     +------------------+
|  [Сервис хранения]   |     |    [Кеш]         |
|  (База данных)    |     |   (например, Redis) |
+------------------+     +------------------+
```

**Компоненты:**

1.  **Балансировщик нагрузки:** Равномерно распределяет входящие запросы между несколькими серверами приложения.
2.  **Серверы приложения (Web Servers):** Обрабатывают бизнес-логику (генерация короткого ключа, редирект).
3.  **Сервис хранения (Database):** Надежно хранит соответствия `short_url` -> `long_url`. Исходя из расчетов, нам может подойти как SQL (PostgreSQL), так и NoSQL (Cassandra) база.
4.  **Кеш (Cache):** Критически важен для обработки пиковых нагрузок на чтение (400 QPS). Мы можем разместить в кеше самые популярные ссылки, чтобы снизить нагрузку на базу данных.

---

## Резюме и следующий шаг

На этом этапе мы:
1.  **Поняли проблему** через функциональные и нефункциональные требования.
2.  **Количественно оценили** масштаб системы.
3.  **Определили, как будем хранить данные.**
4.  **Набросали высокоуровневую схему** с основными компонентами.

Это фундамент. В следующей главе мы углубимся в **детализацию дизайна**: выбор алгоритма для генерации короткой ссылки, глубокая проработка схемы базы данных, стратегии кеширования, репликация, шардирование и план устранения "узких мест" (bottlenecks).

---
*Следующая глава: [02: Детализация дизайна и глубокое погружение](./02-Процесс-дизайна-углубление.md)*