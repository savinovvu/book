## О чём задача?

Дан массив символов chars. Нужно сжать его, используя следующий алгоритм:

Начинаем с пустой строки s
Для каждой группы последовательных повторяющихся символов:
Если длина группы равна 1, добавляем символ в s
Если длина группы больше 1, добавляем символ + число (длину группы)
Полученную строку s нужно записать обратно в массив chars
Возвращаем новую длину массива после сжатия

Важные ограничения:
Нужно модифицировать исходный массив chars
Использовать O(1) дополнительной памяти
Последующие элементы массива не важны

Пример:

text
Input: chars = ["a","a","b","b","c","c","c"]
Output: 6, chars = ["a","2","b","2","c","3"]
Объяснение: Группы: "aa", "bb", "ccc" → "a2b2c3"


## Решение на Java

```java
class Solution {
    public int compress(char[] chars) {
        // Указатель для записи сжатых символов
        int writeIndex = 0;
        // Указатель для чтения исходного массива
        int readIndex = 0;
        
        // Проходим по всему массиву
        while (readIndex < chars.length) {
            // Текущий символ, который мы обрабатываем
            char currentChar = chars[readIndex];
            // Счётчик повторений текущего символа
            int count = 0;
            
            // Подсчитываем количество повторений текущего символа
            while (readIndex < chars.length && chars[readIndex] == currentChar) {
                readIndex++;
                count++;
            }
            
            // Записываем символ в массив
            chars[writeIndex] = currentChar;
            writeIndex++;
            
            // Если символ повторяется более 1 раза, записываем цифры
            if (count > 1) {
                // Преобразуем число в строку и записываем каждую цифру
                String countStr = String.valueOf(count);
                for (char digit : countStr.toCharArray()) {
                    chars[writeIndex] = digit;
                    writeIndex++;
                }
            }
        }
        
        // writeIndex указывает на позицию после последнего записанного символа,
        // что равно длине сжатого массива
        return writeIndex;
    }
}
```




## Временная сложность:
O(n)

## Пространственная сложность:
O(1)
