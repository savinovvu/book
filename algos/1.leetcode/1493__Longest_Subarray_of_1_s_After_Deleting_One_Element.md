## О чём задача?

Задача: Дан бинарный массив nums. Нужно удалить ровно один элемент из массива и вернуть длину самого длинного подмассива, состоящего только из единиц. Если такого подмассива нет, вернуть 0.

Примеры:

nums = [1,1,0,1] → удаляем 0 → [1,1,1] → результат: 3

nums = [0,1,1,1,0,1,1,0,1] → удаляем первый 0 → [1,1,1,1,1,1,0,1] → самый длинный подмассив единиц имеет длину 5

nums = [1,1,1] → удаляем один элемент → [1,1] → результат: 2




## Решение на Java

```java
class Solution {
    public int longestSubarray(int[] nums) {
        int prevCount = 0; // Длина ПРЕДЫДУЩЕГО сегмента единиц
        int currCount = 0; // Длина ТЕКУЩЕГО сегмента единиц
        int maxLength = 0; // Максимальная длина
        boolean hasZero = false; // Есть ли хотя бы один ноль в массиве

        for (int num : nums) {
            if (num == 1) {
                // Продолжаем текущий сегмент единиц
                currCount++;
            } else {
                // Встретили ноль
                hasZero = true;
                // Текущий сегмент становится предыдущим
                prevCount = currCount;
                // Начинаем новый текущий сегмент
                currCount = 0;
            }
            // Суммируем предыдущий и текущий сегменты
            // (эквивалентно удалению нуля между ними)
            maxLength = Math.max(maxLength, prevCount + currCount);
        }

        // Специальный случай: если нулей нет вообще
        // Нужно удалить одну единицу, поэтому вычитаем 1
        return hasZero ? maxLength : maxLength - 1;
    }
}
```

## Временная сложность:
Временная сложность: O(n)

## Пространственная сложность:
Пространственная сложность: O(1)
