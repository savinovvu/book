## О чём задача?

Нужно спроектировать банкомат, 
который изначально содержит банкноты номиналами: 20, 50, 100, 200 и 500 долларов.

Банкомат должен поддерживать две операции:

deposit(int[] banknotesCount) - пополнить банкомат банкнотами
withdraw(int amount) - снять указанную сумму, используя наименьшее количество банкнот

Особенности:

При снятии нужно использовать банкноты наибольшего номинала

Если невозможно выдать запрошенную сумму, вернуть [-1]

При успешном снятии вернуть массив из 5 элементов, 
показывающий количество выданных банкнот каждого номинала

Пример:

text
Input:
["ATM", "deposit", "withdraw", "deposit", "withdraw", "withdraw"]
[[], [[0,0,1,2,1]], [600], [[0,1,0,1,1]], [600], [550]]

Output:
[null, null, [0,0,1,0,1], null, [-1], [0,1,0,0,1]]


## Решение на Java

```java
class ATM {
    // Номиналы купюр в порядке возрастания (для удобства обработки с конца)
    private final int[] denominations = {20, 50, 100, 200, 500};
    
    // Количество купюр каждого номинала в банкомате
    private long[] banknotesCount;
    
    // Конструктор
    public ATM() {
        banknotesCount = new long[5]; // 5 типов купюр
    }
    
    /**
     * Пополнение банкомата
     * @param banknotesCount - массив с количеством добавляемых купюр каждого номинала
     * В порядке: [20, 50, 100, 200, 500]
     */
    public void deposit(int[] banknotesCount) {
        // Просто добавляем купюры к существующим
        for (int i = 0; i < 5; i++) {
            this.banknotesCount[i] += banknotesCount[i];
        }
    }
    
    /**
     * Снятие денег из банкомата
     * @param amount - запрашиваемая сумма
     * @return массив с количеством выданных купюр каждого номинала или [-1] при ошибке
     */
    public int[] withdraw(int amount) {
        // Создаем временный массив для отслеживания выданных купюр
        int[] result = new int[5];
        
        // Создаем копию текущего состояния банкомата для временных расчетов
        long[] tempCount = banknotesCount.clone();
        
        // Пытаемся выдать сумму, начиная с самых крупных купюр
        for (int i = 4; i >= 0; i--) {
            if (amount >= denominations[i]) {
                // Вычисляем максимальное количество купюр данного номинала, которое можно выдать
                // Не больше чем: 1) нужно для суммы, 2) имеется в банкомате
                long count = Math.min(amount / denominations[i], tempCount[i]);
                
                // Уменьшаем запрашиваемую сумму
                amount -= count * denominations[i];
                
                // Запоминаем сколько купюр этого номинала мы выдали
                result[i] = (int) count;
                
                // Уменьшаем временный счетчик купюр
                tempCount[i] -= count;
            }
        }
        
        // Если не удалось полностью выдать запрошенную сумму
        if (amount != 0) {
            return new int[]{-1};
        }
        
        // Если операция успешна, обновляем реальное состояние банкомата
        banknotesCount = tempCount;
        
        return result;
    }
}

/**
 * Пример использования:
 * ATM atm = new ATM();
 * atm.deposit(new int[]{0,0,1,2,1}); // Вносим: 0x20, 0x50, 1x100, 2x200, 1x500
 * atm.withdraw(600); // Снимаем 600 -> [0,0,1,0,1] (1x100 + 1x500)
 */
```


## Подробные комментарии к решению


## Временная сложность:


## Пространственная сложность:

