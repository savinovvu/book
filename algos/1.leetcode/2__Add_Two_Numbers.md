## О чём задача?

Даны два непустых связных списка, представляющих два неотрицательных целых числа. Цифры хранятся в обратном порядке, и каждый узел содержит одну цифру. Нужно сложить два числа и вернуть сумму в виде связного списка.

Предположения:

Числа не содержат ведущих нулей, кроме самого числа 0

Цифры хранятся в обратном порядке (младшие разряды в начале)

Пример:

text
Input: l1 = [2,4,3], l2 = [5,6,4]
Output: [7,0,8]
Объяснение: 342 + 465 = 807 → в обратном порядке: [7,0,8]

Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
Output: [8,9,9,9,0,0,0,1]


## Решение на Java

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {
                // Создаем фиктивную голову результирующего списка
        // Это упрощает логику, так как нам не нужно обрабатывать отдельно первый элемент
        ListNode dummyHead = new ListNode(0);
        // Текущий указатель для построения результата
        ListNode current = dummyHead;
        // Переменная для хранения переноса (carry)
        int carry = 0;
        
        // Продолжаем пока есть узлы в любом из списков или есть перенос
        while (l1 != null || l2 != null || carry != 0) {
            // Получаем значения текущих узлов (0 если узел null)
            int val1 = (l1 != null) ? l1.val : 0;
            int val2 = (l2 != null) ? l2.val : 0;
            
            // Вычисляем сумму текущих цифр и переноса
            int sum = val1 + val2 + carry;
            
            // Вычисляем новую цифру для текущей позиции
            int digit = sum % 10;
            // Вычисляем перенос для следующей позиции
            carry = sum / 10;
            
            // Создаем новый узел с вычисленной цифрой
            current.next = new ListNode(digit);
            // Перемещаем указатель на новый узел
            current = current.next;
            
            // Переходим к следующим узлам в исходных списках (если они существуют)
            if (l1 != null) l1 = l1.next;
            if (l2 != null) l2 = l2.next;
        }
        
        // Возвращаем результат, начиная с первого реального узла
        // (фиктивная голова была вспомогательной)
        return dummyHead.next;
    }
}

```


## Подробные комментарии к решению


## Временная сложность:
O(max(m,n))

## Пространственная сложность:
O(max(m,n))
