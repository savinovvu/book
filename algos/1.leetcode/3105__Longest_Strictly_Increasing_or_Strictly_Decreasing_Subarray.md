## О чём задача?

Дан массив целых чисел nums. 
Нужно найти длину самой длинной подмассива, которая является строго возрастающей или строго убывающей.

Определения:

Строго возрастающий: nums[i] < nums[i+1] для всех i в подмассиве

Строго убывающий: nums[i] > nums[i+1] для всех i в подмассиве

Примеры:

text
Input: nums = [1,4,3,3,2]
Output: 2
Объяснение:
- Строго возрастающие: [1,4] → длина 2
- Строго убывающие: [4,3] → длина 2

Input: nums = [3,3,3,3]
Output: 1
Объяснение: Все элементы одинаковые, максимальная длина = 1

Input: nums = [3,2,1]
Output: 3
Объяснение: [3,2,1] строго убывающий → длина 3
## Решение на Java

```java
class Solution {
    public int longestMonotonicSubarray(int[] nums) {
        // Крайние случаи: пустой массив или массив с одним элементом
        if (nums == null || nums.length == 0) return 0;
        if (nums.length == 1) return 1;
        
        // maxLength - максимальная длина найденного подмассива
        // incLength - длина текущего возрастающего подмассива
        // decLength - длина текущего убывающего подмассива
        int maxLength = 1; // Начинаем с 1, так как минимальный подмассив - один элемент
        int incLength = 1;
        int decLength = 1;
        
        // Проходим по массиву, начиная со второго элемента
        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > nums[i - 1]) {
                // Случай 1: строго возрастающая последовательность
                // Увеличиваем счетчик возрастающей последовательности
                incLength++;
                // Сбрасываем убывающую последовательность, так как текущий элемент больше предыдущего
                decLength = 1;
            } else if (nums[i] < nums[i - 1]) {
                // Случай 2: строго убывающая последовательность
                // Увеличиваем счетчик убывающей последовательности
                decLength++;
                // Сбрасываем возрастающую последовательность, так как текущий элемент меньше предыдущего
                incLength = 1;
            } else {
                // Случай 3: элементы равны
                // Сбрасываем обе последовательности, так как для строгой монотонности
                // элементы не должны быть равны
                incLength = 1;
                decLength = 1;
            }
            
            // На каждой итерации обновляем максимальную длину
            // Сравниваем текущую максимальную длину с длинами обеих последовательностей
            maxLength = Math.max(maxLength, Math.max(incLength, decLength));
        }
        
        return maxLength;
    }
}
```


## Подробные комментарии к решению


## Временная сложность:
O(n)

## Пространственная сложность:
O(1)
