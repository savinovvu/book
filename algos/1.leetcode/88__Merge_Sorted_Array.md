## О чём задача?

Даны два отсортированных массива nums1 и nums2, 
и два целых числа m и n, представляющие количество элементов в nums1 и nums2 соответственно.

Нужно объединить nums1 и nums2 в один отсортированный массив, записанный внутри nums1.

Важные особенности:

Массив nums1 имеет длину m + n, где:

Первые m элементы - валидные элементы из nums1

Последние n элементы равны 0 и должны быть заменены элементами из nums2

Массив nums2 имеет длину n

Нужно модифицировать nums1 на месте

Пример:

text
Input: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
Output: [1,2,2,3,5,6]

Input: nums1 = [1], m = 1, nums2 = [], n = 0
Output: [1]

Input: nums1 = [0], m = 0, nums2 = [1], n = 1
Output: [1]


## Решение на Java

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        // Указатели для отслеживания текущих позиций в массивах
        int i = m - 1;    // Последний значимый элемент в nums1
        int j = n - 1;    // Последний элемент в nums2
        int k = m + n - 1; // Последняя позиция в результирующем массиве nums1
        
        // Проходим с конца обоих массивов и заполняем nums1 с конца
        while (i >= 0 && j >= 0) {
            // Сравниваем элементы с конца и помещаем больший в конец nums1
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--; // Двигаем указатель nums1 назад
            } else {
                nums1[k] = nums2[j];
                j--; // Двигаем указатель nums2 назад
            }
            k--; // Двигаем указатель результирующего массива назад
        }
        
        // Если в nums2 остались элементы (nums1 уже закончился)
        // Копируем оставшиеся элементы из nums2 в nums1
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }

        // Если в nums1 остались элементы (nums2 уже закончился)
        // Они уже на своих местах, ничего делать не нужно
    }
}
```

## Временная сложность:
O(m + n)

## Пространственная сложность:
O(1)
