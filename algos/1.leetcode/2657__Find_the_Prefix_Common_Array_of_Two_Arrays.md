## О чём задача?

Условие задачи:
Даны две перестановки A и B массива [1, 2, ..., n]. Нужно найти массив C такой, что C[i] - это количество общих элементов между префиксами A[0...i] и B[0...i].

Формально:

text
C[i] = |{A[0], A[1], ..., A[i]} ∩ {B[0], B[1], ..., B[i]}|
Пример:

text
Input: A = [1,3,2,4], B = [3,1,2,4]
Output: [0,2,3,4]

Объяснение:
i=0: A[0]=1, B[0]=3 → общие: {} → 0
i=1: A[0..1]={1,3}, B[0..1]={3,1} → общие: {1,3} → 2  
i=2: A[0..2]={1,3,2}, B[0..2]={3,1,2} → общие: {1,2,3} → 3
i=3: A[0..3]={1,3,2,4}, B[0..3]={3,1,2,4} → общие: {1,2,3,4} → 4

Т.е. считаем сколько было общих элементов на каждом шаге массива слева направо
## Решение на Java

```java
class Solution {
    public int[] findThePrefixCommonArray(int[] a, int[] b) {
        int n = a.length; // Получаем длину массивов (оба имеют одинаковую длину n)
        int[] c = new int[n]; // Создаем результирующий массив c длиной n
        int[] count = new int[n + 1]; // Массив для подсчета скоьлко раз встречался элемент в массивах
        int common = 0; // Счетчик общих элементов в текущих префиксах

        // Проходим по всем индексам от 0 до n-1
        for (int i = 0; i < n; i++) {
            // ОБРАБОТКА ЭЛЕМЕНТА ИЗ МАССИВА a
            // Увеличиваем счетчик для текущего элемента из массива a
            count[a[i]]++;

            // Проверяем, стал ли счетчик равным 2
            // Если count[a[i]] == 2, это означает, что элемент a[i] встречался 
            // один раз в массиве a и один раз в массиве b (в текущих префиксах)
            if (count[a[i]] == 2) {
                common++; // Увеличиваем счетчик общих элементов
            }

            // ОБРАБОТКА ЭЛЕМЕНТА ИЗ МАССИВА b
            // Увеличиваем счетчик для текущего элемента из массива b
            count[b[i]]++;

            // Проверяем, стал ли счетчик равным 2
            // Если count[b[i]] == 2, это означает, что элемент b[i] встречался 
            // один раз в массиве b и один раз в массиве a (в текущих префиксах)
            if (count[b[i]] == 2) {
                common++; // Увеличиваем счетчик общих элементов
            }

            // Записываем текущее количество общих элементов в результирующий массив
            c[i] = common;
        }

        // Возвращаем результирующий массив c
        return c;
    }
}
```


## Подробные комментарии к решению


## Временная сложность:
O(n)

## Пространственная сложность:
O(n)
